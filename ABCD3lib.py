#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Thu Feb 27 15:20:35 2020 by generateDS.py version 2.35.14.
# Python 3.7.4 (default, Feb  7 2020, 18:29:37)  [Clang 10.0.1 (clang-1001.0.46.4)]
#
# Command line options:
#   ('-f', '')
#   ('-o', 'ABCD3lib.py')
#   ('--member-specs', 'list')
#
# Command line arguments:
#   ABCD3.xsd
#
# Command line:
#   ./generateDS.py -f -o "ABCD3lib.py" --member-specs="list" ABCD3.xsd
#
# Current working directory (os.getcwd()):
#   django
#

from six.moves import zip_longest
import os
import sys
import re as re_
import base64
import datetime as datetime_
import decimal as decimal_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
SaveElementTreeNode = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    try:
        if isinstance(infile, os.PathLike):
            infile = os.path.join(infile)
    except AttributeError:
        pass
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for an example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#
# Additionally, the generatedsnamespaces module can contain a python
# dictionary named GenerateDSNamespaceTypePrefixes that associates element
# types with the namespace prefixes that are to be added to the
# "xsi:type" attribute value.  See the exportAttributes method of
# any generated element type and the generation of "xsi:type" for an
# example of the use of this table.
# An example table:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceTypePrefixes = {
#         "ElementtypeC": "aaa:",
#         "ElementtypeD": "bbb:",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}
try:
    from generatedsnamespaces import GenerateDSNamespaceTypePrefixes as GenerateDSNamespaceTypePrefixes_
except ImportError:
    GenerateDSNamespaceTypePrefixes_ = {}

#
# You can replace the following class definition by defining an
# importable module named "generatedscollector" containing a class
# named "GdsCollector".  See the default class definition below for
# clues about the possible content of that class.
#
try:
    from generatedscollector import GdsCollector as GdsCollector_
except ImportError:

    class GdsCollector_(object):

        def __init__(self, messages=None):
            if messages is None:
                self.messages = []
            else:
                self.messages = messages

        def add_message(self, msg):
            self.messages.append(msg)

        def get_messages(self):
            return self.messages

        def clear_messages(self):
            self.messages = []

        def print_messages(self):
            for msg in self.messages:
                print("Warning: {}".format(msg))

        def write_messages(self, outstream):
            for msg in self.messages:
                outstream.write("Warning: {}\n".format(msg))


#
# The super-class for enum types
#

try:
    from enum import Enum
except ImportError:
    Enum = object

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        __hash__ = object.__hash__
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_parse_string(self, input_data, node=None, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_parse_integer(self, input_data, node=None, input_name=''):
            try:
                ival = int(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires integer value: %s' % exp)
            return ival
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            try:
                value = int(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires integer value')
            return value
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integer valuess')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_parse_float(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires float or double value: %s' % exp)
            return fval_
        def gds_validate_float(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires float value')
            return value
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of float values')
            return values
        def gds_format_decimal(self, input_data, input_name=''):
            return ('%s' % input_data).rstrip('0')
        def gds_parse_decimal(self, input_data, node=None, input_name=''):
            try:
                decimal_value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return decimal_value
        def gds_validate_decimal(self, input_data, node=None, input_name=''):
            try:
                value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return value
        def gds_format_decimal_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_decimal_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    decimal_.Decimal(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of decimal values')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_parse_double(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires double or float value: %s' % exp)
            return fval_
        def gds_validate_double(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires double or float value')
            return value
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(
                        node, 'Requires sequence of double or float values')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_parse_boolean(self, input_data, node=None, input_name=''):
            if input_data in ('true', '1'):
                bval = True
            elif input_data in ('false', '0'):
                bval = False
            else:
                raise_parse_error(node, 'Requires boolean value')
            return bval
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            if input_data not in (True, 1, False, 0, ):
                raise_parse_error(
                    node,
                    'Requires boolean value '
                    '(one of True, 1, False, 0)')
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in (True, 1, False, 0, ):
                    raise_parse_error(
                        node,
                        'Requires sequence of boolean values '
                        '(one of True, 1, False, 0)')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"), )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_check_cardinality_(
                self, value, input_name,
                min_occurs=0, max_occurs=1, required=None):
            if value is None:
                length = 0
            elif isinstance(value, list):
                length = len(value)
            else:
                length = 1
            if required is not None :
                if required and length < 1:
                    self.gds_collector_.add_message(
                        "Required value {}{} is missing".format(
                            input_name, self.gds_get_node_lineno_()))
            if length < min_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is below "
                    "the minimum allowed, "
                    "expected at least {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        min_occurs, length))
            elif length > max_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is above "
                    "the maximum allowed, "
                    "expected at most {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        max_occurs, length))
        def gds_validate_builtin_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value, input_name=input_name)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_validate_defined_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            # provide default value in case option --disable-xml is used.
            content = ""
            content = etree_.tostring(node, encoding="unicode")
            return content
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.items()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            def excl_select_objs_(obj):
                return (obj[0] != 'parent_object_' and
                        obj[0] != 'gds_collector_')
            if type(self) != type(other):
                return False
            return all(x == y for x, y in zip_longest(
                filter(excl_select_objs_, self.__dict__.items()),
                filter(excl_select_objs_, other.__dict__.items())))
        def __ne__(self, other):
            return not self.__eq__(other)
        # Django ETL transform hooks.
        def gds_djo_etl_transform(self):
            pass
        def gds_djo_etl_transform_db_obj(self, dbobj):
            pass
        # SQLAlchemy ETL transform hooks.
        def gds_sqa_etl_transform(self):
            return 0, None
        def gds_sqa_etl_transform_db_obj(self, dbobj):
            pass
        def gds_get_node_lineno_(self):
            if (hasattr(self, "gds_elementtree_node_") and
                    self.gds_elementtree_node_ is not None):
                return ' near line {}'.format(
                    self.gds_elementtree_node_.sourceline)
            else:
                return ""
    
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ''
# Set this to false in order to deactivate during export, the use of
# name space prefixes captured from the input document.
UseCapturedNS_ = True
CapturedNsmap_ = {}
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


def encode_str_2_3(instr):
    return instr


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if node is not None:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name_=name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class BiologicalStatus(Enum):
    """Code for the (propagation-)provenance of the unit."""
    _1_00='100' # Wild
    _1_10='110' # Natural
    _1_20='120' # Semi-natural/wild
    _2_00='200' # Weedy
    _3_00='300' # Traditional cultivar/landrace
    _4_00='400' # Breeding/research material
    _4_10='410' # Breeder's line
    _4_11='411' # Synthetic population
    _4_12='412' # Hybrid
    _4_13='413' # Founder stock/base population
    _4_14='414' # Inbred line (parent of hybrid cultivar)
    _4_15='415' # Segregating population
    _4_20='420' # Mutant/genetic stock
    _5_00='500' # Advanced/improved cultivar
    _9_99='999' # Other


class CodeOfNomenclatureEnum(Enum):
    """An enumeration of the Codes of Nomenclature"""
    BACTERIOLOGICAL='Bacteriological'
    BOTANICAL='Botanical'
    VIRAL='Viral'
    ZOOLOGICAL='Zoological'
    CULTIVATED='Cultivated'


class CollectingAcquisitionSource(Enum):
    """Code for the (location-)provenance of the unit. The coding scheme
    proposed can be used at 2 different levels of detail: either by using
    the general codes such as 10, 20, 30, 40 or by using the more specific
    codes such as 11, 12 etc."""
    _1_0='10' # Wild habitat
    _1_1='11' # Forest/woodland
    _1_2='12' # Shrubland
    _1_3='13' # Grassland
    _1_4='14' # Desert/tundra
    _1_5='15' # Aquatic habitat
    _2_0='20' # Farm or cultivated habitat
    _2_1='21' # Field
    _2_2='22' # Orchard
    _2_3='23' # Backyard, kitchen or home garden (urban, peri-urban or rural)
    _2_4='24' # Fallow land
    _2_5='25' # Pasture
    _2_6='26' # Farm store
    _2_7='27' # Threshing floor
    _2_8='28' # Park
    _3_0='30' # Market or shop
    _4_0='40' # Institute, Experimental station, Research organisation, Genebank
    _5_0='50' # Seed company
    _6_0='60' # Weedy, disturbed or ruderal habitat
    _6_1='61' # Roadside
    _6_2='62' # Field margin
    _9_9='99' # Other


class HigherTaxonRankEnum(Enum):
    """A taxonomic rank designation above the rank of genus."""
    REGNUM='regnum' # Higher Taxon Rank for the kingdom (lat. regnum).
    SUBREGNUM='subregnum' # Higher Taxon Rank for the subkingdom (lat. subregnum).
    SUPERPHYLUM='superphylum' # Higher Taxon Rank for the superphylum (or Superdivision in Botany).
    PHYLUM='phylum' # Higher Taxon Rank for the Phylum (or Division in Botany).
    SUBPHYLUM='subphylum' # Higher Taxon Rank for the subphylum (or Subdivision in Botany).
    SUPERCLASSIS='superclassis' # Higher Taxon Rank for the superclass (lat. superclassis).
    CLASSIS='classis' # Higher Taxon Rank for the class (lat. classis).
    SUBCLASSIS='subclassis' # Higher Taxon Rank for the subclass (lat. subclassis).
    SUPERCOHORS='supercohors' # Higher Taxon Rank for the supercohort (lat. supercohors).
    COHORS='cohors' # Higher Taxon Rank for the outdated rank of cohort (lat. cohors).
    SUBCOHORS='subcohors' # Higher Taxon Rank for the subcohort (lat. subcohors).
    SUPERORDO='superordo' # Higher Taxon Rank for the superorder (lat. superordo).
    ORDO='ordo' # Higher Taxon Rank for the order (lat. ordo).
    SUBORDO='subordo' # Higher Taxon Rank for the suborder (lat. subordo).
    SUPERFAMILIA='superfamilia' # Abbreviation for the botanical taxonomic rank form species (lat: forma species).
    FAMILIA='familia' # Higher Taxon Rank for the superfamily (lat. superfamilia).
    SUBFAMILIA='subfamilia' # Higher Taxon Rank for the subfamily (lat. subfamilia).
    TRIBUS='tribus' # Higher Taxon Rank for the tribe (lat. tribus).
    GENUSGROUP='genusgroup' # Higher Taxon Rank element for Higher Taxon Names that are in an unspecified genus-group in Zoology.
    UNRANKED='unranked' # Higher Taxon Rank element for Higher Taxon Names that are unranked.


class RankAbbreviation(Enum):
    """The abbreviation of a taxonomic rank as used in (botanical) name
    strings."""
    SUBGEN='subgen.' # Abbreviation for the botanical taxonomic rank subgenus.
    SECT='sect.' # Abbreviation for the botanical taxonomic rank section (lat: sectio).
    SUBSP='subsp.' # Abbreviation for the botanical taxonomic rank subspecies.
    VAR='var.' # Abbreviation for the botanical taxonomic rank variety (lat: varietas).
    SUBVAR='subvar.' # Abbreviation for the botanical taxonomic rank subvariety (lat: subvarietas).
    FORMA='forma' # Latin name for the botanical taxonomic rank form (abbr.: f.).
    F='f.' # Abbreviation for the botanical taxonomic rank form (lat: forma).
    SUBFORMA='subforma' # Latin name for the botanical taxonomic rank subform (abbr.: subf.).
    SUBF='subf.' # Abbreviation for the botanical taxonomic rank subform (lat: subforma).
    FSPEC='f.spec.' # Abbreviation for the botanical taxonomic rank form species (lat: forma species).


class RecordBasisEnum(Enum):
    """A standard designator for the nature of the object of the record.
    "MaterialSample" is added as "A resource describing the physical
    results of a sampling (or sub-sampling) event. In biological
    collections, the material sample is typically collected, and either
    preserved or destructively processed"."""
    PRESERVED_SPECIMEN='PreservedSpecimen'
    LIVING_SPECIMEN='LivingSpecimen'
    FOSSIL_SPECIMEN='FossilSpecimen'
    MINERAL_SPECIMEN='MineralSpecimen'
    OTHER_SPECIMEN='OtherSpecimen'
    MATERIAL_SAMPLE='MaterialSample'
    HUMAN_OBSERVATION='HumanObservation'
    MACHINE_OBSERVATION='MachineObservation'
    DRAWING_OR_PHOTOGRAPH='DrawingOrPhotograph'
    MULTIMEDIA_OBJECT='MultimediaObject'
    ABSENCE_OBSERVATION='AbsenceObservation'


class SexCodeEnum(Enum):
    """Sex of the organism (Male, Female, Unknown, Not applicable (e.g. for a
    fungus in a herbarium), MiXed)."""
    M='M'
    F='F'
    U='U'
    N='N'
    X='X'


class StatusType(Enum):
    """Information about the presence, absence or other basic status of permits
    associated with the sample(s). Material collected after 2014-10-12
    cannot be in "Unknown" permit status!"""
    PERMITAVAILABLE='Permit available'
    PERMITNOTREQUIRED='Permit not required'
    PERMITNOTAVAILABLE='Permit not available'
    UNKNOWN='Unknown'


class TypeGermplasmStorage(Enum):
    """Code for the type of storage of the unit in the collection. If germplasm
    is maintained under different types of storage, multiple choices are
    allowed (separated by a semicolon). (Refer to FAO/IPGRI Genebank
    Standards 1994 for details on storage type.)"""
    _1_0='10' # Seed collection
    _1_1='11' # Short term
    _1_2='12' # Medium term
    _1_3='13' # Long term
    _2_0='20' # Field collection
    _3_0='30' # In vitro collection (Slow growth)
    _4_0='40' # Cryopreserved collection
    _9_9='99' # Other


class TypeType(Enum):
    """A permit is a document that allows someone to take an action that
    otherwise would not be allowed."""
    CONTRACT='Contract'
    COPYRIGHT='Copyright'
    DATAUSE='Data use'
    EXEMPTION_PERMIT='Exemption Permit'
    EXPORT_PERMIT='Export Permit'
    GENETICALLY_MODIFIED_ORGANISM='Genetically Modified Organism'
    HUMAN_PATHOGENS='Human Pathogens'
    INTELLECTUAL_PROPERTY_RIGHTS='Intellectual Property Rights'
    INTERNATIONALLY_RECOGNIZED_CERTIFICATEOF_COMPLIANCE='Internationally Recognized Certificate of Compliance'
    IMPORT_PERMIT='Import Permit'
    COLLECTING_PERMIT='Collecting Permit'
    MATERIAL_TRANSFER_AGREEMENT='Material Transfer Agreement'
    MEMORANDUMOF_COOPERATION='Memorandum of Cooperation'
    MEMORANDUMOF_UNDERSTANDING='Memorandum of Understanding'
    PATENT='Patent'
    PHYTOSANITARY='Phytosanitary'
    SALVAGE='Salvage'
    VETERINARY_CERTIFICATE='Veterinary Certificate'


class spatialFitDataType(Enum):
    """from http://rs.tdwg.org/dwc/basetypes.xsd to support compatibility with
    DwC Spatial Extensions"""
    UNDEFINED='undefined'


class DataSets(GeneratedsSuper):
    """TDWG root element: container for one or more DataSets."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('DataSet', 'DataSetType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'DataSet', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/DataSet', 'type': 'DataSetType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, DataSet=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if DataSet is None:
            self.DataSet = []
        else:
            self.DataSet = DataSet
        self.DataSet_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DataSets)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DataSets.subclass:
            return DataSets.subclass(*args_, **kwargs_)
        else:
            return DataSets(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DataSet(self):
        return self.DataSet
    def set_DataSet(self, DataSet):
        self.DataSet = DataSet
    def add_DataSet(self, value):
        self.DataSet.append(value)
    def insert_DataSet_at(self, index, value):
        self.DataSet.insert(index, value)
    def replace_DataSet_at(self, index, value):
        self.DataSet[index] = value
    def hasContent_(self):
        if (
            self.DataSet
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='DataSets', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DataSets')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DataSets')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DataSets', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DataSets'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='DataSets', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DataSet_ in self.DataSet:
            namespaceprefix_ = self.DataSet_nsprefix_ + ':' if (UseCapturedNS_ and self.DataSet_nsprefix_) else ''
            DataSet_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DataSet', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DataSet':
            obj_ = DataSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DataSet.append(obj_)
            obj_.original_tagname_ = 'DataSet'
# end class DataSets


class Gathering(GeneratedsSuper):
    """Elements describing the event and site of collecting or observing a
    unit."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('ID', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'ID', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Gathering-ID', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('Date', 'DateTime', 0, 1, {'minOccurs': '0', 'name': 'Date', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Gathering-Date', 'type': 'DateTime'}, None),
        MemberSpec_('GatheringAgents', 'GatheringAgentsType', 0, 1, {'minOccurs': '0', 'name': 'GatheringAgents', 'type': 'GatheringAgentsType'}, None),
        MemberSpec_('GatheringAgentsText', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'GatheringAgentsText', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/GatheringAgentsText', 'type': 'StringL'}, None),
        MemberSpec_('Permits', 'PermitsType', 0, 1, {'minOccurs': '0', 'name': 'Permits', 'type': 'PermitsType'}, None),
        MemberSpec_('Project', 'ProjectType', 0, 1, {'minOccurs': '0', 'name': 'Project', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/Project', 'type': 'ProjectType'}, None),
        MemberSpec_('PlatformName', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'PlatformName', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/platformName', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('Method', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'Method', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Gathering-Method', 'type': 'StringL'}, None),
        MemberSpec_('ValidDistributionFlag', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'ValidDistributionFlag', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/validDistributionFlag', 'type': 'xs:boolean'}, None),
        MemberSpec_('EstablishmentMeans', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'EstablishmentMeans', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/establishmentMeans', 'type': 'StringL'}, None),
        MemberSpec_('LocalityText', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'LocalityText', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/localityText', 'type': 'StringL'}, None),
        MemberSpec_('Country', 'Country', 0, 1, {'minOccurs': '0', 'name': 'Country', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/Country', 'type': 'Country'}, None),
        MemberSpec_('NamedAreas', 'NamedAreasType', 0, 1, {'minOccurs': '0', 'name': 'NamedAreas', 'type': 'NamedAreasType'}, None),
        MemberSpec_('NamedPlaceRelations', 'NamedPlaceRelationsType', 0, 1, {'minOccurs': '0', 'name': 'NamedPlaceRelations', 'type': 'NamedPlaceRelationsType'}, None),
        MemberSpec_('Details', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'Details', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Gathering-Details', 'type': 'StringL'}, None),
        MemberSpec_('GML', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'GML', 'type': 'xs:string'}, None),
        MemberSpec_('WFS', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'WFS', 'type': 'xs:string'}, None),
        MemberSpec_('WMSURL', 'xs:anyURI', 0, 1, {'minOccurs': '0', 'name': 'WMSURL', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/wmsURL', 'type': 'xs:anyURI'}, None),
        MemberSpec_('CoordinateSets', 'CoordinateSetsType', 0, 1, {'minOccurs': '0', 'name': 'CoordinateSets', 'type': 'CoordinateSetsType'}, None),
        MemberSpec_('Altitude', 'MeasurementOrFact', 0, 1, {'minOccurs': '0', 'name': 'Altitude', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Altitude', 'type': 'MeasurementOrFact'}, None),
        MemberSpec_('Depth', 'MeasurementOrFact', 0, 1, {'minOccurs': '0', 'name': 'Depth', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Depth', 'type': 'MeasurementOrFact'}, None),
        MemberSpec_('Height', 'MeasurementOrFact', 0, 1, {'minOccurs': '0', 'name': 'Height', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Height', 'type': 'MeasurementOrFact'}, None),
        MemberSpec_('Aspect', 'MeasurementOrFact', 0, 1, {'minOccurs': '0', 'name': 'Aspect', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Aspect', 'type': 'MeasurementOrFact'}, None),
        MemberSpec_('OtherMeasurementsOrFacts', 'OtherMeasurementsOrFactsType', 0, 1, {'minOccurs': '0', 'name': 'OtherMeasurementsOrFacts', 'type': 'OtherMeasurementsOrFactsType'}, None),
        MemberSpec_('MultimediaObjects', 'MultimediaObjectsType', 0, 1, {'minOccurs': '0', 'name': 'MultimediaObjects', 'type': 'MultimediaObjectsType'}, None),
        MemberSpec_('Stratigraphy', 'Stratigraphy', 0, 1, {'minOccurs': '0', 'name': 'Stratigraphy', 'type': 'Stratigraphy'}, None),
        MemberSpec_('Biotope', 'BiotopeType', 0, 1, {'minOccurs': '0', 'name': 'Biotope', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/Biotope', 'type': 'BiotopeType'}, None),
        MemberSpec_('Synecology', 'SynecologyType', 0, 1, {'minOccurs': '0', 'name': 'Synecology', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/Synecology', 'type': 'SynecologyType'}, None),
        MemberSpec_('Notes', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'Notes', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Gathering-Notes', 'type': 'StringL'}, None),
        MemberSpec_('FootprintWKT', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'FootprintWKT', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/footprintWKT', 'type': 'xs:string'}, None),
        MemberSpec_('FootprintSpatialFit', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'FootprintSpatialFit', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/footprintSpatialFit', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, ID=None, Date=None, GatheringAgents=None, GatheringAgentsText=None, Permits=None, Project=None, PlatformName=None, Method=None, ValidDistributionFlag=None, EstablishmentMeans=None, LocalityText=None, Country=None, NamedAreas=None, NamedPlaceRelations=None, Details=None, GML=None, WFS=None, WMSURL=None, CoordinateSets=None, Altitude=None, Depth=None, Height=None, Aspect=None, OtherMeasurementsOrFacts=None, MultimediaObjects=None, Stratigraphy=None, Biotope=None, Synecology=None, Notes=None, FootprintWKT=None, FootprintSpatialFit=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = ID
        self.validate_String(self.ID)
        self.ID_nsprefix_ = None
        self.Date = Date
        self.Date_nsprefix_ = None
        self.GatheringAgents = GatheringAgents
        self.GatheringAgents_nsprefix_ = None
        self.GatheringAgentsText = GatheringAgentsText
        self.GatheringAgentsText_nsprefix_ = None
        self.Permits = Permits
        self.Permits_nsprefix_ = None
        self.Project = Project
        self.Project_nsprefix_ = None
        self.PlatformName = PlatformName
        self.validate_String(self.PlatformName)
        self.PlatformName_nsprefix_ = None
        self.Method = Method
        self.Method_nsprefix_ = None
        self.ValidDistributionFlag = ValidDistributionFlag
        self.ValidDistributionFlag_nsprefix_ = None
        self.EstablishmentMeans = EstablishmentMeans
        self.EstablishmentMeans_nsprefix_ = None
        self.LocalityText = LocalityText
        self.LocalityText_nsprefix_ = None
        self.Country = Country
        self.Country_nsprefix_ = None
        self.NamedAreas = NamedAreas
        self.NamedAreas_nsprefix_ = None
        self.NamedPlaceRelations = NamedPlaceRelations
        self.NamedPlaceRelations_nsprefix_ = None
        self.Details = Details
        self.Details_nsprefix_ = None
        self.GML = GML
        self.GML_nsprefix_ = None
        self.WFS = WFS
        self.WFS_nsprefix_ = None
        self.WMSURL = WMSURL
        self.WMSURL_nsprefix_ = None
        self.CoordinateSets = CoordinateSets
        self.CoordinateSets_nsprefix_ = None
        self.Altitude = Altitude
        self.Altitude_nsprefix_ = None
        self.Depth = Depth
        self.Depth_nsprefix_ = None
        self.Height = Height
        self.Height_nsprefix_ = None
        self.Aspect = Aspect
        self.Aspect_nsprefix_ = None
        self.OtherMeasurementsOrFacts = OtherMeasurementsOrFacts
        self.OtherMeasurementsOrFacts_nsprefix_ = None
        self.MultimediaObjects = MultimediaObjects
        self.MultimediaObjects_nsprefix_ = None
        self.Stratigraphy = Stratigraphy
        self.Stratigraphy_nsprefix_ = None
        self.Biotope = Biotope
        self.Biotope_nsprefix_ = None
        self.Synecology = Synecology
        self.Synecology_nsprefix_ = None
        self.Notes = Notes
        self.Notes_nsprefix_ = None
        self.FootprintWKT = FootprintWKT
        self.FootprintWKT_nsprefix_ = None
        self.FootprintSpatialFit = FootprintSpatialFit
        self.FootprintSpatialFit_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Gathering)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Gathering.subclass:
            return Gathering.subclass(*args_, **kwargs_)
        else:
            return Gathering(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_Date(self):
        return self.Date
    def set_Date(self, Date):
        self.Date = Date
    def get_GatheringAgents(self):
        return self.GatheringAgents
    def set_GatheringAgents(self, GatheringAgents):
        self.GatheringAgents = GatheringAgents
    def get_GatheringAgentsText(self):
        return self.GatheringAgentsText
    def set_GatheringAgentsText(self, GatheringAgentsText):
        self.GatheringAgentsText = GatheringAgentsText
    def get_Permits(self):
        return self.Permits
    def set_Permits(self, Permits):
        self.Permits = Permits
    def get_Project(self):
        return self.Project
    def set_Project(self, Project):
        self.Project = Project
    def get_PlatformName(self):
        return self.PlatformName
    def set_PlatformName(self, PlatformName):
        self.PlatformName = PlatformName
    def get_Method(self):
        return self.Method
    def set_Method(self, Method):
        self.Method = Method
    def get_ValidDistributionFlag(self):
        return self.ValidDistributionFlag
    def set_ValidDistributionFlag(self, ValidDistributionFlag):
        self.ValidDistributionFlag = ValidDistributionFlag
    def get_EstablishmentMeans(self):
        return self.EstablishmentMeans
    def set_EstablishmentMeans(self, EstablishmentMeans):
        self.EstablishmentMeans = EstablishmentMeans
    def get_LocalityText(self):
        return self.LocalityText
    def set_LocalityText(self, LocalityText):
        self.LocalityText = LocalityText
    def get_Country(self):
        return self.Country
    def set_Country(self, Country):
        self.Country = Country
    def get_NamedAreas(self):
        return self.NamedAreas
    def set_NamedAreas(self, NamedAreas):
        self.NamedAreas = NamedAreas
    def get_NamedPlaceRelations(self):
        return self.NamedPlaceRelations
    def set_NamedPlaceRelations(self, NamedPlaceRelations):
        self.NamedPlaceRelations = NamedPlaceRelations
    def get_Details(self):
        return self.Details
    def set_Details(self, Details):
        self.Details = Details
    def get_GML(self):
        return self.GML
    def set_GML(self, GML):
        self.GML = GML
    def get_WFS(self):
        return self.WFS
    def set_WFS(self, WFS):
        self.WFS = WFS
    def get_WMSURL(self):
        return self.WMSURL
    def set_WMSURL(self, WMSURL):
        self.WMSURL = WMSURL
    def get_CoordinateSets(self):
        return self.CoordinateSets
    def set_CoordinateSets(self, CoordinateSets):
        self.CoordinateSets = CoordinateSets
    def get_Altitude(self):
        return self.Altitude
    def set_Altitude(self, Altitude):
        self.Altitude = Altitude
    def get_Depth(self):
        return self.Depth
    def set_Depth(self, Depth):
        self.Depth = Depth
    def get_Height(self):
        return self.Height
    def set_Height(self, Height):
        self.Height = Height
    def get_Aspect(self):
        return self.Aspect
    def set_Aspect(self, Aspect):
        self.Aspect = Aspect
    def get_OtherMeasurementsOrFacts(self):
        return self.OtherMeasurementsOrFacts
    def set_OtherMeasurementsOrFacts(self, OtherMeasurementsOrFacts):
        self.OtherMeasurementsOrFacts = OtherMeasurementsOrFacts
    def get_MultimediaObjects(self):
        return self.MultimediaObjects
    def set_MultimediaObjects(self, MultimediaObjects):
        self.MultimediaObjects = MultimediaObjects
    def get_Stratigraphy(self):
        return self.Stratigraphy
    def set_Stratigraphy(self, Stratigraphy):
        self.Stratigraphy = Stratigraphy
    def get_Biotope(self):
        return self.Biotope
    def set_Biotope(self, Biotope):
        self.Biotope = Biotope
    def get_Synecology(self):
        return self.Synecology
    def set_Synecology(self, Synecology):
        self.Synecology = Synecology
    def get_Notes(self):
        return self.Notes
    def set_Notes(self, Notes):
        self.Notes = Notes
    def get_FootprintWKT(self):
        return self.FootprintWKT
    def set_FootprintWKT(self, FootprintWKT):
        self.FootprintWKT = FootprintWKT
    def get_FootprintSpatialFit(self):
        return self.FootprintSpatialFit
    def set_FootprintSpatialFit(self, FootprintSpatialFit):
        self.FootprintSpatialFit = FootprintSpatialFit
    def validate_String(self, value):
        result = True
        # Validate type String, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on String' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.ID is not None or
            self.Date is not None or
            self.GatheringAgents is not None or
            self.GatheringAgentsText is not None or
            self.Permits is not None or
            self.Project is not None or
            self.PlatformName is not None or
            self.Method is not None or
            self.ValidDistributionFlag is not None or
            self.EstablishmentMeans is not None or
            self.LocalityText is not None or
            self.Country is not None or
            self.NamedAreas is not None or
            self.NamedPlaceRelations is not None or
            self.Details is not None or
            self.GML is not None or
            self.WFS is not None or
            self.WMSURL is not None or
            self.CoordinateSets is not None or
            self.Altitude is not None or
            self.Depth is not None or
            self.Height is not None or
            self.Aspect is not None or
            self.OtherMeasurementsOrFacts is not None or
            self.MultimediaObjects is not None or
            self.Stratigraphy is not None or
            self.Biotope is not None or
            self.Synecology is not None or
            self.Notes is not None or
            self.FootprintWKT is not None or
            self.FootprintSpatialFit is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='Gathering', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Gathering')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Gathering')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Gathering', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Gathering'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='Gathering', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ID), input_name='ID')), namespaceprefix_ , eol_))
        if self.Date is not None:
            namespaceprefix_ = self.Date_nsprefix_ + ':' if (UseCapturedNS_ and self.Date_nsprefix_) else ''
            self.Date.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Date', pretty_print=pretty_print)
        if self.GatheringAgents is not None:
            namespaceprefix_ = self.GatheringAgents_nsprefix_ + ':' if (UseCapturedNS_ and self.GatheringAgents_nsprefix_) else ''
            self.GatheringAgents.export(outfile, level, namespaceprefix_, namespacedef_='', name_='GatheringAgents', pretty_print=pretty_print)
        if self.GatheringAgentsText is not None:
            namespaceprefix_ = self.GatheringAgentsText_nsprefix_ + ':' if (UseCapturedNS_ and self.GatheringAgentsText_nsprefix_) else ''
            self.GatheringAgentsText.export(outfile, level, namespaceprefix_, namespacedef_='', name_='GatheringAgentsText', pretty_print=pretty_print)
        if self.Permits is not None:
            namespaceprefix_ = self.Permits_nsprefix_ + ':' if (UseCapturedNS_ and self.Permits_nsprefix_) else ''
            self.Permits.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Permits', pretty_print=pretty_print)
        if self.Project is not None:
            namespaceprefix_ = self.Project_nsprefix_ + ':' if (UseCapturedNS_ and self.Project_nsprefix_) else ''
            self.Project.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Project', pretty_print=pretty_print)
        if self.PlatformName is not None:
            namespaceprefix_ = self.PlatformName_nsprefix_ + ':' if (UseCapturedNS_ and self.PlatformName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPlatformName>%s</%sPlatformName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PlatformName), input_name='PlatformName')), namespaceprefix_ , eol_))
        if self.Method is not None:
            namespaceprefix_ = self.Method_nsprefix_ + ':' if (UseCapturedNS_ and self.Method_nsprefix_) else ''
            self.Method.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Method', pretty_print=pretty_print)
        if self.ValidDistributionFlag is not None:
            namespaceprefix_ = self.ValidDistributionFlag_nsprefix_ + ':' if (UseCapturedNS_ and self.ValidDistributionFlag_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sValidDistributionFlag>%s</%sValidDistributionFlag>%s' % (namespaceprefix_ , self.gds_format_boolean(self.ValidDistributionFlag, input_name='ValidDistributionFlag'), namespaceprefix_ , eol_))
        if self.EstablishmentMeans is not None:
            namespaceprefix_ = self.EstablishmentMeans_nsprefix_ + ':' if (UseCapturedNS_ and self.EstablishmentMeans_nsprefix_) else ''
            self.EstablishmentMeans.export(outfile, level, namespaceprefix_, namespacedef_='', name_='EstablishmentMeans', pretty_print=pretty_print)
        if self.LocalityText is not None:
            namespaceprefix_ = self.LocalityText_nsprefix_ + ':' if (UseCapturedNS_ and self.LocalityText_nsprefix_) else ''
            self.LocalityText.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LocalityText', pretty_print=pretty_print)
        if self.Country is not None:
            namespaceprefix_ = self.Country_nsprefix_ + ':' if (UseCapturedNS_ and self.Country_nsprefix_) else ''
            self.Country.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Country', pretty_print=pretty_print)
        if self.NamedAreas is not None:
            namespaceprefix_ = self.NamedAreas_nsprefix_ + ':' if (UseCapturedNS_ and self.NamedAreas_nsprefix_) else ''
            self.NamedAreas.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NamedAreas', pretty_print=pretty_print)
        if self.NamedPlaceRelations is not None:
            namespaceprefix_ = self.NamedPlaceRelations_nsprefix_ + ':' if (UseCapturedNS_ and self.NamedPlaceRelations_nsprefix_) else ''
            self.NamedPlaceRelations.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NamedPlaceRelations', pretty_print=pretty_print)
        if self.Details is not None:
            namespaceprefix_ = self.Details_nsprefix_ + ':' if (UseCapturedNS_ and self.Details_nsprefix_) else ''
            self.Details.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Details', pretty_print=pretty_print)
        if self.GML is not None:
            namespaceprefix_ = self.GML_nsprefix_ + ':' if (UseCapturedNS_ and self.GML_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGML>%s</%sGML>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.GML), input_name='GML')), namespaceprefix_ , eol_))
        if self.WFS is not None:
            namespaceprefix_ = self.WFS_nsprefix_ + ':' if (UseCapturedNS_ and self.WFS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sWFS>%s</%sWFS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.WFS), input_name='WFS')), namespaceprefix_ , eol_))
        if self.WMSURL is not None:
            namespaceprefix_ = self.WMSURL_nsprefix_ + ':' if (UseCapturedNS_ and self.WMSURL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sWMSURL>%s</%sWMSURL>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.WMSURL), input_name='WMSURL')), namespaceprefix_ , eol_))
        if self.CoordinateSets is not None:
            namespaceprefix_ = self.CoordinateSets_nsprefix_ + ':' if (UseCapturedNS_ and self.CoordinateSets_nsprefix_) else ''
            self.CoordinateSets.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CoordinateSets', pretty_print=pretty_print)
        if self.Altitude is not None:
            namespaceprefix_ = self.Altitude_nsprefix_ + ':' if (UseCapturedNS_ and self.Altitude_nsprefix_) else ''
            self.Altitude.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Altitude', pretty_print=pretty_print)
        if self.Depth is not None:
            namespaceprefix_ = self.Depth_nsprefix_ + ':' if (UseCapturedNS_ and self.Depth_nsprefix_) else ''
            self.Depth.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Depth', pretty_print=pretty_print)
        if self.Height is not None:
            namespaceprefix_ = self.Height_nsprefix_ + ':' if (UseCapturedNS_ and self.Height_nsprefix_) else ''
            self.Height.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Height', pretty_print=pretty_print)
        if self.Aspect is not None:
            namespaceprefix_ = self.Aspect_nsprefix_ + ':' if (UseCapturedNS_ and self.Aspect_nsprefix_) else ''
            self.Aspect.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Aspect', pretty_print=pretty_print)
        if self.OtherMeasurementsOrFacts is not None:
            namespaceprefix_ = self.OtherMeasurementsOrFacts_nsprefix_ + ':' if (UseCapturedNS_ and self.OtherMeasurementsOrFacts_nsprefix_) else ''
            self.OtherMeasurementsOrFacts.export(outfile, level, namespaceprefix_, namespacedef_='', name_='OtherMeasurementsOrFacts', pretty_print=pretty_print)
        if self.MultimediaObjects is not None:
            namespaceprefix_ = self.MultimediaObjects_nsprefix_ + ':' if (UseCapturedNS_ and self.MultimediaObjects_nsprefix_) else ''
            self.MultimediaObjects.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MultimediaObjects', pretty_print=pretty_print)
        if self.Stratigraphy is not None:
            namespaceprefix_ = self.Stratigraphy_nsprefix_ + ':' if (UseCapturedNS_ and self.Stratigraphy_nsprefix_) else ''
            self.Stratigraphy.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Stratigraphy', pretty_print=pretty_print)
        if self.Biotope is not None:
            namespaceprefix_ = self.Biotope_nsprefix_ + ':' if (UseCapturedNS_ and self.Biotope_nsprefix_) else ''
            self.Biotope.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Biotope', pretty_print=pretty_print)
        if self.Synecology is not None:
            namespaceprefix_ = self.Synecology_nsprefix_ + ':' if (UseCapturedNS_ and self.Synecology_nsprefix_) else ''
            self.Synecology.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Synecology', pretty_print=pretty_print)
        if self.Notes is not None:
            namespaceprefix_ = self.Notes_nsprefix_ + ':' if (UseCapturedNS_ and self.Notes_nsprefix_) else ''
            self.Notes.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Notes', pretty_print=pretty_print)
        if self.FootprintWKT is not None:
            namespaceprefix_ = self.FootprintWKT_nsprefix_ + ':' if (UseCapturedNS_ and self.FootprintWKT_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFootprintWKT>%s</%sFootprintWKT>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.FootprintWKT), input_name='FootprintWKT')), namespaceprefix_ , eol_))
        if self.FootprintSpatialFit is not None:
            namespaceprefix_ = self.FootprintSpatialFit_nsprefix_ + ':' if (UseCapturedNS_ and self.FootprintSpatialFit_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFootprintSpatialFit>%s</%sFootprintSpatialFit>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.FootprintSpatialFit), input_name='FootprintSpatialFit')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ID')
            value_ = self.gds_validate_string(value_, node, 'ID')
            self.ID = value_
            self.ID_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.ID)
        elif nodeName_ == 'Date':
            obj_ = DateTime.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Date = obj_
            obj_.original_tagname_ = 'Date'
        elif nodeName_ == 'GatheringAgents':
            obj_ = GatheringAgentsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.GatheringAgents = obj_
            obj_.original_tagname_ = 'GatheringAgents'
        elif nodeName_ == 'GatheringAgentsText':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.GatheringAgentsText = obj_
            obj_.original_tagname_ = 'GatheringAgentsText'
        elif nodeName_ == 'Permits':
            obj_ = PermitsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Permits = obj_
            obj_.original_tagname_ = 'Permits'
        elif nodeName_ == 'Project':
            obj_ = ProjectType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Project = obj_
            obj_.original_tagname_ = 'Project'
        elif nodeName_ == 'PlatformName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PlatformName')
            value_ = self.gds_validate_string(value_, node, 'PlatformName')
            self.PlatformName = value_
            self.PlatformName_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.PlatformName)
        elif nodeName_ == 'Method':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Method = obj_
            obj_.original_tagname_ = 'Method'
        elif nodeName_ == 'ValidDistributionFlag':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'ValidDistributionFlag')
            ival_ = self.gds_validate_boolean(ival_, node, 'ValidDistributionFlag')
            self.ValidDistributionFlag = ival_
            self.ValidDistributionFlag_nsprefix_ = child_.prefix
        elif nodeName_ == 'EstablishmentMeans':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EstablishmentMeans = obj_
            obj_.original_tagname_ = 'EstablishmentMeans'
        elif nodeName_ == 'LocalityText':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LocalityText = obj_
            obj_.original_tagname_ = 'LocalityText'
        elif nodeName_ == 'Country':
            obj_ = Country.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Country = obj_
            obj_.original_tagname_ = 'Country'
        elif nodeName_ == 'NamedAreas':
            obj_ = NamedAreasType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NamedAreas = obj_
            obj_.original_tagname_ = 'NamedAreas'
        elif nodeName_ == 'NamedPlaceRelations':
            obj_ = NamedPlaceRelationsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NamedPlaceRelations = obj_
            obj_.original_tagname_ = 'NamedPlaceRelations'
        elif nodeName_ == 'Details':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Details = obj_
            obj_.original_tagname_ = 'Details'
        elif nodeName_ == 'GML':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'GML')
            value_ = self.gds_validate_string(value_, node, 'GML')
            self.GML = value_
            self.GML_nsprefix_ = child_.prefix
        elif nodeName_ == 'WFS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'WFS')
            value_ = self.gds_validate_string(value_, node, 'WFS')
            self.WFS = value_
            self.WFS_nsprefix_ = child_.prefix
        elif nodeName_ == 'WMSURL':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'WMSURL')
            value_ = self.gds_validate_string(value_, node, 'WMSURL')
            self.WMSURL = value_
            self.WMSURL_nsprefix_ = child_.prefix
        elif nodeName_ == 'CoordinateSets':
            obj_ = CoordinateSetsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CoordinateSets = obj_
            obj_.original_tagname_ = 'CoordinateSets'
        elif nodeName_ == 'Altitude':
            obj_ = MeasurementOrFact.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Altitude = obj_
            obj_.original_tagname_ = 'Altitude'
        elif nodeName_ == 'Depth':
            obj_ = MeasurementOrFact.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Depth = obj_
            obj_.original_tagname_ = 'Depth'
        elif nodeName_ == 'Height':
            obj_ = MeasurementOrFact.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Height = obj_
            obj_.original_tagname_ = 'Height'
        elif nodeName_ == 'Aspect':
            obj_ = MeasurementOrFact.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Aspect = obj_
            obj_.original_tagname_ = 'Aspect'
        elif nodeName_ == 'OtherMeasurementsOrFacts':
            obj_ = OtherMeasurementsOrFactsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OtherMeasurementsOrFacts = obj_
            obj_.original_tagname_ = 'OtherMeasurementsOrFacts'
        elif nodeName_ == 'MultimediaObjects':
            obj_ = MultimediaObjectsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MultimediaObjects = obj_
            obj_.original_tagname_ = 'MultimediaObjects'
        elif nodeName_ == 'Stratigraphy':
            obj_ = Stratigraphy.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Stratigraphy = obj_
            obj_.original_tagname_ = 'Stratigraphy'
        elif nodeName_ == 'Biotope':
            obj_ = BiotopeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Biotope = obj_
            obj_.original_tagname_ = 'Biotope'
        elif nodeName_ == 'Synecology':
            obj_ = SynecologyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Synecology = obj_
            obj_.original_tagname_ = 'Synecology'
        elif nodeName_ == 'Notes':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Notes = obj_
            obj_.original_tagname_ = 'Notes'
        elif nodeName_ == 'FootprintWKT':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'FootprintWKT')
            value_ = self.gds_validate_string(value_, node, 'FootprintWKT')
            self.FootprintWKT = value_
            self.FootprintWKT_nsprefix_ = child_.prefix
        elif nodeName_ == 'FootprintSpatialFit':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'FootprintSpatialFit')
            value_ = self.gds_validate_string(value_, node, 'FootprintSpatialFit')
            self.FootprintSpatialFit = value_
            self.FootprintSpatialFit_nsprefix_ = child_.prefix
# end class Gathering


class Identification(GeneratedsSuper):
    """The application of a name (or concept), i.e. the data pertaining to an
    identification event and the result of the identification itself."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('Result', 'ResultType', 0, 0, {'name': 'Result', 'type': 'ResultType'}, None),
        MemberSpec_('PreferredFlag', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'PreferredFlag', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/preferred', 'type': 'xs:boolean'}, None),
        MemberSpec_('NegativeIdentificationFlag', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'NegativeIdentificationFlag', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/negativeIdentificationFlag', 'type': 'xs:boolean'}, None),
        MemberSpec_('StoredUnderFlag', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'StoredUnderFlag', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/storedUnderFlag', 'type': 'xs:boolean'}, None),
        MemberSpec_('ResultRole', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'ResultRole', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/resultRole', 'type': 'StringL'}, None),
        MemberSpec_('Identifiers', 'IdentifiersType', 0, 1, {'minOccurs': '0', 'name': 'Identifiers', 'type': 'IdentifiersType'}, None),
        MemberSpec_('IdentifierRole', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'IdentifierRole', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/IdentifierRole', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('IdentificationSource', 'Reference', 0, 1, {'minOccurs': '0', 'name': 'IdentificationSource', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/IdentificationSource', 'type': 'Reference'}, None),
        MemberSpec_('References', 'ReferencesType2', 0, 1, {'minOccurs': '0', 'name': 'References', 'type': 'ReferencesType2'}, None),
        MemberSpec_('Date', 'DateTime', 0, 1, {'minOccurs': '0', 'name': 'Date', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Identification-Date', 'type': 'DateTime'}, None),
        MemberSpec_('Method', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'Method', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Identification-Method', 'type': 'StringL'}, None),
        MemberSpec_('Notes', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'Notes', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Identification-Notes', 'type': 'StringL'}, None),
        MemberSpec_('VerificationLevel', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'VerificationLevel', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/verificationLevel', 'type': 'xs:normalizedString'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, Result=None, PreferredFlag=None, NegativeIdentificationFlag=None, StoredUnderFlag=None, ResultRole=None, Identifiers=None, IdentifierRole=None, IdentificationSource=None, References=None, Date=None, Method=None, Notes=None, VerificationLevel=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Result = Result
        self.Result_nsprefix_ = None
        self.PreferredFlag = PreferredFlag
        self.PreferredFlag_nsprefix_ = None
        self.NegativeIdentificationFlag = NegativeIdentificationFlag
        self.NegativeIdentificationFlag_nsprefix_ = None
        self.StoredUnderFlag = StoredUnderFlag
        self.StoredUnderFlag_nsprefix_ = None
        self.ResultRole = ResultRole
        self.ResultRole_nsprefix_ = None
        self.Identifiers = Identifiers
        self.Identifiers_nsprefix_ = None
        self.IdentifierRole = IdentifierRole
        self.validate_String(self.IdentifierRole)
        self.IdentifierRole_nsprefix_ = None
        self.IdentificationSource = IdentificationSource
        self.IdentificationSource_nsprefix_ = None
        self.References = References
        self.References_nsprefix_ = None
        self.Date = Date
        self.Date_nsprefix_ = None
        self.Method = Method
        self.Method_nsprefix_ = None
        self.Notes = Notes
        self.Notes_nsprefix_ = None
        self.VerificationLevel = VerificationLevel
        self.validate_String(self.VerificationLevel)
        self.VerificationLevel_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Identification)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Identification.subclass:
            return Identification.subclass(*args_, **kwargs_)
        else:
            return Identification(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Result(self):
        return self.Result
    def set_Result(self, Result):
        self.Result = Result
    def get_PreferredFlag(self):
        return self.PreferredFlag
    def set_PreferredFlag(self, PreferredFlag):
        self.PreferredFlag = PreferredFlag
    def get_NegativeIdentificationFlag(self):
        return self.NegativeIdentificationFlag
    def set_NegativeIdentificationFlag(self, NegativeIdentificationFlag):
        self.NegativeIdentificationFlag = NegativeIdentificationFlag
    def get_StoredUnderFlag(self):
        return self.StoredUnderFlag
    def set_StoredUnderFlag(self, StoredUnderFlag):
        self.StoredUnderFlag = StoredUnderFlag
    def get_ResultRole(self):
        return self.ResultRole
    def set_ResultRole(self, ResultRole):
        self.ResultRole = ResultRole
    def get_Identifiers(self):
        return self.Identifiers
    def set_Identifiers(self, Identifiers):
        self.Identifiers = Identifiers
    def get_IdentifierRole(self):
        return self.IdentifierRole
    def set_IdentifierRole(self, IdentifierRole):
        self.IdentifierRole = IdentifierRole
    def get_IdentificationSource(self):
        return self.IdentificationSource
    def set_IdentificationSource(self, IdentificationSource):
        self.IdentificationSource = IdentificationSource
    def get_References(self):
        return self.References
    def set_References(self, References):
        self.References = References
    def get_Date(self):
        return self.Date
    def set_Date(self, Date):
        self.Date = Date
    def get_Method(self):
        return self.Method
    def set_Method(self, Method):
        self.Method = Method
    def get_Notes(self):
        return self.Notes
    def set_Notes(self, Notes):
        self.Notes = Notes
    def get_VerificationLevel(self):
        return self.VerificationLevel
    def set_VerificationLevel(self, VerificationLevel):
        self.VerificationLevel = VerificationLevel
    def validate_String(self, value):
        result = True
        # Validate type String, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on String' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.Result is not None or
            self.PreferredFlag is not None or
            self.NegativeIdentificationFlag is not None or
            self.StoredUnderFlag is not None or
            self.ResultRole is not None or
            self.Identifiers is not None or
            self.IdentifierRole is not None or
            self.IdentificationSource is not None or
            self.References is not None or
            self.Date is not None or
            self.Method is not None or
            self.Notes is not None or
            self.VerificationLevel is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='Identification', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Identification')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Identification')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Identification', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Identification'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='Identification', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Result is not None:
            namespaceprefix_ = self.Result_nsprefix_ + ':' if (UseCapturedNS_ and self.Result_nsprefix_) else ''
            self.Result.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Result', pretty_print=pretty_print)
        if self.PreferredFlag is not None:
            namespaceprefix_ = self.PreferredFlag_nsprefix_ + ':' if (UseCapturedNS_ and self.PreferredFlag_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPreferredFlag>%s</%sPreferredFlag>%s' % (namespaceprefix_ , self.gds_format_boolean(self.PreferredFlag, input_name='PreferredFlag'), namespaceprefix_ , eol_))
        if self.NegativeIdentificationFlag is not None:
            namespaceprefix_ = self.NegativeIdentificationFlag_nsprefix_ + ':' if (UseCapturedNS_ and self.NegativeIdentificationFlag_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNegativeIdentificationFlag>%s</%sNegativeIdentificationFlag>%s' % (namespaceprefix_ , self.gds_format_boolean(self.NegativeIdentificationFlag, input_name='NegativeIdentificationFlag'), namespaceprefix_ , eol_))
        if self.StoredUnderFlag is not None:
            namespaceprefix_ = self.StoredUnderFlag_nsprefix_ + ':' if (UseCapturedNS_ and self.StoredUnderFlag_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStoredUnderFlag>%s</%sStoredUnderFlag>%s' % (namespaceprefix_ , self.gds_format_boolean(self.StoredUnderFlag, input_name='StoredUnderFlag'), namespaceprefix_ , eol_))
        if self.ResultRole is not None:
            namespaceprefix_ = self.ResultRole_nsprefix_ + ':' if (UseCapturedNS_ and self.ResultRole_nsprefix_) else ''
            self.ResultRole.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ResultRole', pretty_print=pretty_print)
        if self.Identifiers is not None:
            namespaceprefix_ = self.Identifiers_nsprefix_ + ':' if (UseCapturedNS_ and self.Identifiers_nsprefix_) else ''
            self.Identifiers.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Identifiers', pretty_print=pretty_print)
        if self.IdentifierRole is not None:
            namespaceprefix_ = self.IdentifierRole_nsprefix_ + ':' if (UseCapturedNS_ and self.IdentifierRole_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIdentifierRole>%s</%sIdentifierRole>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.IdentifierRole), input_name='IdentifierRole')), namespaceprefix_ , eol_))
        if self.IdentificationSource is not None:
            namespaceprefix_ = self.IdentificationSource_nsprefix_ + ':' if (UseCapturedNS_ and self.IdentificationSource_nsprefix_) else ''
            self.IdentificationSource.export(outfile, level, namespaceprefix_, namespacedef_='', name_='IdentificationSource', pretty_print=pretty_print)
        if self.References is not None:
            namespaceprefix_ = self.References_nsprefix_ + ':' if (UseCapturedNS_ and self.References_nsprefix_) else ''
            self.References.export(outfile, level, namespaceprefix_, namespacedef_='', name_='References', pretty_print=pretty_print)
        if self.Date is not None:
            namespaceprefix_ = self.Date_nsprefix_ + ':' if (UseCapturedNS_ and self.Date_nsprefix_) else ''
            self.Date.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Date', pretty_print=pretty_print)
        if self.Method is not None:
            namespaceprefix_ = self.Method_nsprefix_ + ':' if (UseCapturedNS_ and self.Method_nsprefix_) else ''
            self.Method.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Method', pretty_print=pretty_print)
        if self.Notes is not None:
            namespaceprefix_ = self.Notes_nsprefix_ + ':' if (UseCapturedNS_ and self.Notes_nsprefix_) else ''
            self.Notes.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Notes', pretty_print=pretty_print)
        if self.VerificationLevel is not None:
            namespaceprefix_ = self.VerificationLevel_nsprefix_ + ':' if (UseCapturedNS_ and self.VerificationLevel_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVerificationLevel>%s</%sVerificationLevel>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.VerificationLevel), input_name='VerificationLevel')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Result':
            obj_ = ResultType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Result = obj_
            obj_.original_tagname_ = 'Result'
        elif nodeName_ == 'PreferredFlag':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'PreferredFlag')
            ival_ = self.gds_validate_boolean(ival_, node, 'PreferredFlag')
            self.PreferredFlag = ival_
            self.PreferredFlag_nsprefix_ = child_.prefix
        elif nodeName_ == 'NegativeIdentificationFlag':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'NegativeIdentificationFlag')
            ival_ = self.gds_validate_boolean(ival_, node, 'NegativeIdentificationFlag')
            self.NegativeIdentificationFlag = ival_
            self.NegativeIdentificationFlag_nsprefix_ = child_.prefix
        elif nodeName_ == 'StoredUnderFlag':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'StoredUnderFlag')
            ival_ = self.gds_validate_boolean(ival_, node, 'StoredUnderFlag')
            self.StoredUnderFlag = ival_
            self.StoredUnderFlag_nsprefix_ = child_.prefix
        elif nodeName_ == 'ResultRole':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ResultRole = obj_
            obj_.original_tagname_ = 'ResultRole'
        elif nodeName_ == 'Identifiers':
            obj_ = IdentifiersType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Identifiers = obj_
            obj_.original_tagname_ = 'Identifiers'
        elif nodeName_ == 'IdentifierRole':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'IdentifierRole')
            value_ = self.gds_validate_string(value_, node, 'IdentifierRole')
            self.IdentifierRole = value_
            self.IdentifierRole_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.IdentifierRole)
        elif nodeName_ == 'IdentificationSource':
            obj_ = Reference.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IdentificationSource = obj_
            obj_.original_tagname_ = 'IdentificationSource'
        elif nodeName_ == 'References':
            obj_ = ReferencesType2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.References = obj_
            obj_.original_tagname_ = 'References'
        elif nodeName_ == 'Date':
            obj_ = DateTime.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Date = obj_
            obj_.original_tagname_ = 'Date'
        elif nodeName_ == 'Method':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Method = obj_
            obj_.original_tagname_ = 'Method'
        elif nodeName_ == 'Notes':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Notes = obj_
            obj_.original_tagname_ = 'Notes'
        elif nodeName_ == 'VerificationLevel':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'VerificationLevel')
            value_ = self.gds_validate_string(value_, node, 'VerificationLevel')
            self.VerificationLevel = value_
            self.VerificationLevel_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.VerificationLevel)
# end class Identification


class NamedArea(GeneratedsSuper):
    """An atomized place name (an administrative or geoecological area) with
    possibility for hierarchical structuring."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('AreaClass', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'AreaClass', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/areaClass', 'type': 'StringL'}, None),
        MemberSpec_('Name', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'Name', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/NamedArea-Name', 'type': 'StringL'}, None),
        MemberSpec_('CodeStandard', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'CodeStandard', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/codeStandard', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('Code', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'Code', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/code', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('Reference', 'Reference', 0, 1, {'minOccurs': '0', 'name': 'Reference', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/NamedArea-Reference', 'type': 'Reference'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, AreaClass=None, Name=None, CodeStandard=None, Code=None, Reference=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.AreaClass = AreaClass
        self.AreaClass_nsprefix_ = None
        self.Name = Name
        self.Name_nsprefix_ = None
        self.CodeStandard = CodeStandard
        self.validate_String(self.CodeStandard)
        self.CodeStandard_nsprefix_ = None
        self.Code = Code
        self.validate_String(self.Code)
        self.Code_nsprefix_ = None
        self.Reference = Reference
        self.Reference_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NamedArea)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NamedArea.subclass:
            return NamedArea.subclass(*args_, **kwargs_)
        else:
            return NamedArea(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_AreaClass(self):
        return self.AreaClass
    def set_AreaClass(self, AreaClass):
        self.AreaClass = AreaClass
    def get_Name(self):
        return self.Name
    def set_Name(self, Name):
        self.Name = Name
    def get_CodeStandard(self):
        return self.CodeStandard
    def set_CodeStandard(self, CodeStandard):
        self.CodeStandard = CodeStandard
    def get_Code(self):
        return self.Code
    def set_Code(self, Code):
        self.Code = Code
    def get_Reference(self):
        return self.Reference
    def set_Reference(self, Reference):
        self.Reference = Reference
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_String(self, value):
        result = True
        # Validate type String, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on String' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.AreaClass is not None or
            self.Name is not None or
            self.CodeStandard is not None or
            self.Code is not None or
            self.Reference is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='NamedArea', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NamedArea')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NamedArea')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NamedArea', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NamedArea'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='NamedArea', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AreaClass is not None:
            namespaceprefix_ = self.AreaClass_nsprefix_ + ':' if (UseCapturedNS_ and self.AreaClass_nsprefix_) else ''
            self.AreaClass.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AreaClass', pretty_print=pretty_print)
        if self.Name is not None:
            namespaceprefix_ = self.Name_nsprefix_ + ':' if (UseCapturedNS_ and self.Name_nsprefix_) else ''
            self.Name.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Name', pretty_print=pretty_print)
        if self.CodeStandard is not None:
            namespaceprefix_ = self.CodeStandard_nsprefix_ + ':' if (UseCapturedNS_ and self.CodeStandard_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCodeStandard>%s</%sCodeStandard>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CodeStandard), input_name='CodeStandard')), namespaceprefix_ , eol_))
        if self.Code is not None:
            namespaceprefix_ = self.Code_nsprefix_ + ':' if (UseCapturedNS_ and self.Code_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCode>%s</%sCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Code), input_name='Code')), namespaceprefix_ , eol_))
        if self.Reference is not None:
            namespaceprefix_ = self.Reference_nsprefix_ + ':' if (UseCapturedNS_ and self.Reference_nsprefix_) else ''
            self.Reference.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Reference', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'AreaClass':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AreaClass = obj_
            obj_.original_tagname_ = 'AreaClass'
        elif nodeName_ == 'Name':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Name = obj_
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'CodeStandard':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CodeStandard')
            value_ = self.gds_validate_string(value_, node, 'CodeStandard')
            self.CodeStandard = value_
            self.CodeStandard_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.CodeStandard)
        elif nodeName_ == 'Code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Code')
            value_ = self.gds_validate_string(value_, node, 'Code')
            self.Code = value_
            self.Code_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.Code)
        elif nodeName_ == 'Reference':
            obj_ = Reference.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Reference = obj_
            obj_.original_tagname_ = 'Reference'
# end class NamedArea


class Unit(GeneratedsSuper):
    """Elements for all unit-level dataPhysical state-specific subtypes of the
    unit recordCollection type and/or taxonomic domain-specific schema
    extensions (subtypes of the unit record)."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('GUID', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'GUID', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Unit-GUID', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('SourceInstitutionID', ['InstitutionCode', 'xs:string'], 0, 0, {'name': 'SourceInstitutionID', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Unit-SourceInstitutionID', 'type': 'xs:string'}, None),
        MemberSpec_('SourceID', ['String', 'xs:normalizedString'], 0, 0, {'name': 'SourceID', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Unit-SourceID', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('ID', ['String', 'xs:normalizedString'], 0, 0, {'name': 'ID', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Unit-ID', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('NumericID', 'xs:int', 0, 1, {'minOccurs': '0', 'name': 'NumericID', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/numericUnitID', 'type': 'xs:int'}, None),
        MemberSpec_('LastEditor', 'Contact', 0, 1, {'minOccurs': '0', 'name': 'LastEditor', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/LastEditor', 'type': 'Contact'}, None),
        MemberSpec_('DateModified', ['DateTimeISO', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'DateModified', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Unit-DateModified', 'type': 'xs:string'}, None),
        MemberSpec_('Owner', 'Contact', 0, 1, {'minOccurs': '0', 'name': 'Owner', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Unit-Owner', 'type': 'Contact'}, None),
        MemberSpec_('LegalStatements', 'LegalStatements', 0, 1, {'minOccurs': '0', 'name': 'LegalStatements', 'type': 'LegalStatements'}, None),
        MemberSpec_('ContentContacts', 'ContentContactsType3', 0, 1, {'minOccurs': '0', 'name': 'ContentContacts', 'type': 'ContentContactsType3'}, None),
        MemberSpec_('InformationWithheld', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'InformationWithheld', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Unit-InformationWithheld', 'type': 'StringL'}, None),
        MemberSpec_('SourceReference', 'Reference', 0, 1, {'minOccurs': '0', 'name': 'SourceReference', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Unit-SourceReference', 'type': 'Reference'}, None),
        MemberSpec_('UnitReferences', 'UnitReferencesType', 0, 1, {'minOccurs': '0', 'name': 'UnitReferences', 'type': 'UnitReferencesType'}, None),
        MemberSpec_('Identifications', 'IdentificationsType', 0, 1, {'minOccurs': '0', 'name': 'Identifications', 'type': 'IdentificationsType'}, None),
        MemberSpec_('IdentificationHistory', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'IdentificationHistory', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/identificationHistory', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('RecordBasis', ['RecordBasisEnum', 'xs:Name'], 0, 1, {'minOccurs': '0', 'name': 'RecordBasis', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/RecordBasis', 'type': 'xs:Name'}, None),
        MemberSpec_('KindOfUnit', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'KindOfUnit', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Unit-KindOfUnit', 'type': 'StringL'}, None),
        MemberSpec_('SpecimenUnit', 'SpecimenUnitType', 0, 1, {'minOccurs': '0', 'name': 'SpecimenUnit', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/SpecimenUnit', 'type': 'SpecimenUnitType'}, 1),
        MemberSpec_('ObservationUnit', 'ObservationUnitType', 0, 1, {'minOccurs': '0', 'name': 'ObservationUnit', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/ObservationUnit', 'type': 'ObservationUnitType'}, 1),
        MemberSpec_('CultureCollectionUnit', 'CultureCollectionUnit', 0, 1, {'minOccurs': '0', 'name': 'CultureCollectionUnit', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/CultureCollectionUnit', 'type': 'CultureCollectionUnit'}, None),
        MemberSpec_('MycologicalUnit', 'MycologicalUnit', 0, 1, {'minOccurs': '0', 'name': 'MycologicalUnit', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/MycologicalUnit', 'type': 'MycologicalUnit'}, None),
        MemberSpec_('HerbariumUnit', 'HerbariumUnit', 0, 1, {'minOccurs': '0', 'name': 'HerbariumUnit', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/HerbariumUnit', 'type': 'HerbariumUnit'}, None),
        MemberSpec_('BotanicalGardenUnit', 'BotanicalGardenUnit', 0, 1, {'minOccurs': '0', 'name': 'BotanicalGardenUnit', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/BotanicalGardenUnit', 'type': 'BotanicalGardenUnit'}, None),
        MemberSpec_('PlantGeneticResourcesUnit', 'PGRUnit', 0, 1, {'minOccurs': '0', 'name': 'PlantGeneticResourcesUnit', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/PlantGeneticResourcesUnit', 'type': 'PGRUnit'}, None),
        MemberSpec_('ZoologicalUnit', 'ZoologicalUnit', 0, 1, {'minOccurs': '0', 'name': 'ZoologicalUnit', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/ZoologicalUnit', 'type': 'ZoologicalUnit'}, None),
        MemberSpec_('PaleontologicalUnit', 'PaleontologicalUnit', 0, 1, {'minOccurs': '0', 'name': 'PaleontologicalUnit', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/PaleontologicalUnit', 'type': 'PaleontologicalUnit'}, None),
        MemberSpec_('MultimediaObjects', 'MultimediaObjectsType5', 0, 1, {'minOccurs': '0', 'name': 'MultimediaObjects', 'type': 'MultimediaObjectsType5'}, None),
        MemberSpec_('Associations', 'AssociationsType', 0, 1, {'minOccurs': '0', 'name': 'Associations', 'type': 'AssociationsType'}, None),
        MemberSpec_('Assemblages', 'AssemblagesType', 0, 1, {'minOccurs': '0', 'name': 'Assemblages', 'type': 'AssemblagesType'}, None),
        MemberSpec_('NamedCollectionsOrSurveys', 'NamedCollectionsOrSurveysType', 0, 1, {'minOccurs': '0', 'name': 'NamedCollectionsOrSurveys', 'type': 'NamedCollectionsOrSurveysType'}, None),
        MemberSpec_('Gathering', 'Gathering', 0, 1, {'minOccurs': '0', 'name': 'Gathering', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/Gathering', 'type': 'Gathering'}, None),
        MemberSpec_('FieldNumbers', 'FieldNumbersType', 0, 1, {'minOccurs': '0', 'name': 'FieldNumbers', 'type': 'FieldNumbersType'}, None),
        MemberSpec_('FieldNotes', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'FieldNotes', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/fieldNotes', 'type': 'StringL'}, None),
        MemberSpec_('FieldNotesReferences', 'FieldNotesReferencesType', 0, 1, {'minOccurs': '0', 'name': 'FieldNotesReferences', 'type': 'FieldNotesReferencesType'}, None),
        MemberSpec_('MeasurementsOrFacts', 'MeasurementsOrFactsType8', 0, 1, {'minOccurs': '0', 'name': 'MeasurementsOrFacts', 'type': 'MeasurementsOrFactsType8'}, None),
        MemberSpec_('Sex', ['SexCodeEnum', 'xs:Name'], 0, 1, {'minOccurs': '0', 'name': 'Sex', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/Sex', 'type': 'xs:Name'}, None),
        MemberSpec_('Age', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'Age', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/age', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('Sequences', 'SequencesType', 0, 1, {'minOccurs': '0', 'name': 'Sequences', 'type': 'SequencesType'}, None),
        MemberSpec_('Notes', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'Notes', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Unit-Notes', 'type': 'StringL'}, None),
        MemberSpec_('WebsiteURL', 'xs:anyURI', 0, 1, {'minOccurs': '0', 'name': 'WebsiteURL', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Unit-WebsiteURL', 'type': 'xs:anyURI'}, None),
        MemberSpec_('Annotations', 'AnnotationsType', 0, 1, {'minOccurs': '0', 'name': 'Annotations', 'type': 'AnnotationsType'}, None),
        MemberSpec_('UnitExtensions', 'UnitExtensionsType', 0, 1, {'minOccurs': '0', 'name': 'UnitExtensions', 'type': 'UnitExtensionsType'}, None),
        MemberSpec_('ResourceURIs', 'ResourceURIsType9', 0, 1, {'minOccurs': '0', 'name': 'ResourceURIs', 'type': 'ResourceURIsType9'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, GUID=None, SourceInstitutionID=None, SourceID=None, ID=None, NumericID=None, LastEditor=None, DateModified=None, Owner=None, LegalStatements=None, ContentContacts=None, InformationWithheld=None, SourceReference=None, UnitReferences=None, Identifications=None, IdentificationHistory=None, RecordBasis=None, KindOfUnit=None, SpecimenUnit=None, ObservationUnit=None, CultureCollectionUnit=None, MycologicalUnit=None, HerbariumUnit=None, BotanicalGardenUnit=None, PlantGeneticResourcesUnit=None, ZoologicalUnit=None, PaleontologicalUnit=None, MultimediaObjects=None, Associations=None, Assemblages=None, NamedCollectionsOrSurveys=None, Gathering=None, FieldNumbers=None, FieldNotes=None, FieldNotesReferences=None, MeasurementsOrFacts=None, Sex=None, Age=None, Sequences=None, Notes=None, WebsiteURL=None, Annotations=None, UnitExtensions=None, ResourceURIs=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.GUID = GUID
        self.validate_String(self.GUID)
        self.GUID_nsprefix_ = None
        self.SourceInstitutionID = SourceInstitutionID
        self.validate_InstitutionCode(self.SourceInstitutionID)
        self.SourceInstitutionID_nsprefix_ = None
        self.SourceID = SourceID
        self.validate_String(self.SourceID)
        self.SourceID_nsprefix_ = None
        self.ID = ID
        self.validate_String(self.ID)
        self.ID_nsprefix_ = None
        self.NumericID = NumericID
        self.NumericID_nsprefix_ = None
        self.LastEditor = LastEditor
        self.LastEditor_nsprefix_ = None
        self.DateModified = DateModified
        self.validate_DateTimeISO(self.DateModified)
        self.DateModified_nsprefix_ = None
        self.Owner = Owner
        self.Owner_nsprefix_ = None
        self.LegalStatements = LegalStatements
        self.LegalStatements_nsprefix_ = None
        self.ContentContacts = ContentContacts
        self.ContentContacts_nsprefix_ = None
        self.InformationWithheld = InformationWithheld
        self.InformationWithheld_nsprefix_ = None
        self.SourceReference = SourceReference
        self.SourceReference_nsprefix_ = None
        self.UnitReferences = UnitReferences
        self.UnitReferences_nsprefix_ = None
        self.Identifications = Identifications
        self.Identifications_nsprefix_ = None
        self.IdentificationHistory = IdentificationHistory
        self.validate_String(self.IdentificationHistory)
        self.IdentificationHistory_nsprefix_ = None
        self.RecordBasis = RecordBasis
        self.validate_RecordBasisEnum(self.RecordBasis)
        self.RecordBasis_nsprefix_ = None
        self.KindOfUnit = KindOfUnit
        self.KindOfUnit_nsprefix_ = None
        self.SpecimenUnit = SpecimenUnit
        self.SpecimenUnit_nsprefix_ = None
        self.ObservationUnit = ObservationUnit
        self.ObservationUnit_nsprefix_ = None
        self.CultureCollectionUnit = CultureCollectionUnit
        self.CultureCollectionUnit_nsprefix_ = None
        self.MycologicalUnit = MycologicalUnit
        self.MycologicalUnit_nsprefix_ = None
        self.HerbariumUnit = HerbariumUnit
        self.HerbariumUnit_nsprefix_ = None
        self.BotanicalGardenUnit = BotanicalGardenUnit
        self.BotanicalGardenUnit_nsprefix_ = None
        self.PlantGeneticResourcesUnit = PlantGeneticResourcesUnit
        self.PlantGeneticResourcesUnit_nsprefix_ = None
        self.ZoologicalUnit = ZoologicalUnit
        self.ZoologicalUnit_nsprefix_ = None
        self.PaleontologicalUnit = PaleontologicalUnit
        self.PaleontologicalUnit_nsprefix_ = None
        self.MultimediaObjects = MultimediaObjects
        self.MultimediaObjects_nsprefix_ = None
        self.Associations = Associations
        self.Associations_nsprefix_ = None
        self.Assemblages = Assemblages
        self.Assemblages_nsprefix_ = None
        self.NamedCollectionsOrSurveys = NamedCollectionsOrSurveys
        self.NamedCollectionsOrSurveys_nsprefix_ = None
        self.Gathering = Gathering
        self.Gathering_nsprefix_ = None
        self.FieldNumbers = FieldNumbers
        self.FieldNumbers_nsprefix_ = None
        self.FieldNotes = FieldNotes
        self.FieldNotes_nsprefix_ = None
        self.FieldNotesReferences = FieldNotesReferences
        self.FieldNotesReferences_nsprefix_ = None
        self.MeasurementsOrFacts = MeasurementsOrFacts
        self.MeasurementsOrFacts_nsprefix_ = None
        self.Sex = Sex
        self.validate_SexCodeEnum(self.Sex)
        self.Sex_nsprefix_ = None
        self.Age = Age
        self.validate_String(self.Age)
        self.Age_nsprefix_ = None
        self.Sequences = Sequences
        self.Sequences_nsprefix_ = None
        self.Notes = Notes
        self.Notes_nsprefix_ = None
        self.WebsiteURL = WebsiteURL
        self.WebsiteURL_nsprefix_ = None
        self.Annotations = Annotations
        self.Annotations_nsprefix_ = None
        self.UnitExtensions = UnitExtensions
        self.UnitExtensions_nsprefix_ = None
        self.ResourceURIs = ResourceURIs
        self.ResourceURIs_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Unit)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Unit.subclass:
            return Unit.subclass(*args_, **kwargs_)
        else:
            return Unit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_GUID(self):
        return self.GUID
    def set_GUID(self, GUID):
        self.GUID = GUID
    def get_SourceInstitutionID(self):
        return self.SourceInstitutionID
    def set_SourceInstitutionID(self, SourceInstitutionID):
        self.SourceInstitutionID = SourceInstitutionID
    def get_SourceID(self):
        return self.SourceID
    def set_SourceID(self, SourceID):
        self.SourceID = SourceID
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_NumericID(self):
        return self.NumericID
    def set_NumericID(self, NumericID):
        self.NumericID = NumericID
    def get_LastEditor(self):
        return self.LastEditor
    def set_LastEditor(self, LastEditor):
        self.LastEditor = LastEditor
    def get_DateModified(self):
        return self.DateModified
    def set_DateModified(self, DateModified):
        self.DateModified = DateModified
    def get_Owner(self):
        return self.Owner
    def set_Owner(self, Owner):
        self.Owner = Owner
    def get_LegalStatements(self):
        return self.LegalStatements
    def set_LegalStatements(self, LegalStatements):
        self.LegalStatements = LegalStatements
    def get_ContentContacts(self):
        return self.ContentContacts
    def set_ContentContacts(self, ContentContacts):
        self.ContentContacts = ContentContacts
    def get_InformationWithheld(self):
        return self.InformationWithheld
    def set_InformationWithheld(self, InformationWithheld):
        self.InformationWithheld = InformationWithheld
    def get_SourceReference(self):
        return self.SourceReference
    def set_SourceReference(self, SourceReference):
        self.SourceReference = SourceReference
    def get_UnitReferences(self):
        return self.UnitReferences
    def set_UnitReferences(self, UnitReferences):
        self.UnitReferences = UnitReferences
    def get_Identifications(self):
        return self.Identifications
    def set_Identifications(self, Identifications):
        self.Identifications = Identifications
    def get_IdentificationHistory(self):
        return self.IdentificationHistory
    def set_IdentificationHistory(self, IdentificationHistory):
        self.IdentificationHistory = IdentificationHistory
    def get_RecordBasis(self):
        return self.RecordBasis
    def set_RecordBasis(self, RecordBasis):
        self.RecordBasis = RecordBasis
    def get_KindOfUnit(self):
        return self.KindOfUnit
    def set_KindOfUnit(self, KindOfUnit):
        self.KindOfUnit = KindOfUnit
    def get_SpecimenUnit(self):
        return self.SpecimenUnit
    def set_SpecimenUnit(self, SpecimenUnit):
        self.SpecimenUnit = SpecimenUnit
    def get_ObservationUnit(self):
        return self.ObservationUnit
    def set_ObservationUnit(self, ObservationUnit):
        self.ObservationUnit = ObservationUnit
    def get_CultureCollectionUnit(self):
        return self.CultureCollectionUnit
    def set_CultureCollectionUnit(self, CultureCollectionUnit):
        self.CultureCollectionUnit = CultureCollectionUnit
    def get_MycologicalUnit(self):
        return self.MycologicalUnit
    def set_MycologicalUnit(self, MycologicalUnit):
        self.MycologicalUnit = MycologicalUnit
    def get_HerbariumUnit(self):
        return self.HerbariumUnit
    def set_HerbariumUnit(self, HerbariumUnit):
        self.HerbariumUnit = HerbariumUnit
    def get_BotanicalGardenUnit(self):
        return self.BotanicalGardenUnit
    def set_BotanicalGardenUnit(self, BotanicalGardenUnit):
        self.BotanicalGardenUnit = BotanicalGardenUnit
    def get_PlantGeneticResourcesUnit(self):
        return self.PlantGeneticResourcesUnit
    def set_PlantGeneticResourcesUnit(self, PlantGeneticResourcesUnit):
        self.PlantGeneticResourcesUnit = PlantGeneticResourcesUnit
    def get_ZoologicalUnit(self):
        return self.ZoologicalUnit
    def set_ZoologicalUnit(self, ZoologicalUnit):
        self.ZoologicalUnit = ZoologicalUnit
    def get_PaleontologicalUnit(self):
        return self.PaleontologicalUnit
    def set_PaleontologicalUnit(self, PaleontologicalUnit):
        self.PaleontologicalUnit = PaleontologicalUnit
    def get_MultimediaObjects(self):
        return self.MultimediaObjects
    def set_MultimediaObjects(self, MultimediaObjects):
        self.MultimediaObjects = MultimediaObjects
    def get_Associations(self):
        return self.Associations
    def set_Associations(self, Associations):
        self.Associations = Associations
    def get_Assemblages(self):
        return self.Assemblages
    def set_Assemblages(self, Assemblages):
        self.Assemblages = Assemblages
    def get_NamedCollectionsOrSurveys(self):
        return self.NamedCollectionsOrSurveys
    def set_NamedCollectionsOrSurveys(self, NamedCollectionsOrSurveys):
        self.NamedCollectionsOrSurveys = NamedCollectionsOrSurveys
    def get_Gathering(self):
        return self.Gathering
    def set_Gathering(self, Gathering):
        self.Gathering = Gathering
    def get_FieldNumbers(self):
        return self.FieldNumbers
    def set_FieldNumbers(self, FieldNumbers):
        self.FieldNumbers = FieldNumbers
    def get_FieldNotes(self):
        return self.FieldNotes
    def set_FieldNotes(self, FieldNotes):
        self.FieldNotes = FieldNotes
    def get_FieldNotesReferences(self):
        return self.FieldNotesReferences
    def set_FieldNotesReferences(self, FieldNotesReferences):
        self.FieldNotesReferences = FieldNotesReferences
    def get_MeasurementsOrFacts(self):
        return self.MeasurementsOrFacts
    def set_MeasurementsOrFacts(self, MeasurementsOrFacts):
        self.MeasurementsOrFacts = MeasurementsOrFacts
    def get_Sex(self):
        return self.Sex
    def set_Sex(self, Sex):
        self.Sex = Sex
    def get_Age(self):
        return self.Age
    def set_Age(self, Age):
        self.Age = Age
    def get_Sequences(self):
        return self.Sequences
    def set_Sequences(self, Sequences):
        self.Sequences = Sequences
    def get_Notes(self):
        return self.Notes
    def set_Notes(self, Notes):
        self.Notes = Notes
    def get_WebsiteURL(self):
        return self.WebsiteURL
    def set_WebsiteURL(self, WebsiteURL):
        self.WebsiteURL = WebsiteURL
    def get_Annotations(self):
        return self.Annotations
    def set_Annotations(self, Annotations):
        self.Annotations = Annotations
    def get_UnitExtensions(self):
        return self.UnitExtensions
    def set_UnitExtensions(self, UnitExtensions):
        self.UnitExtensions = UnitExtensions
    def get_ResourceURIs(self):
        return self.ResourceURIs
    def set_ResourceURIs(self, ResourceURIs):
        self.ResourceURIs = ResourceURIs
    def validate_String(self, value):
        result = True
        # Validate type String, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on String' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_InstitutionCode(self, value):
        result = True
        # Validate type InstitutionCode, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_DateTimeISO(self, value):
        result = True
        # Validate type DateTimeISO, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_DateTimeISO_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_DateTimeISO_patterns_, ))
                result = False
        return result
    validate_DateTimeISO_patterns_ = [['^(((1(5(8[3-9]|9\\d)|[6789]\\d\\d))|(20\\d\\d))(-((0[1-9]|1[012])(-(0[1-9]|1\\d|2[0-8])(T(0\\d|1\\d|2[0-3])(:[0-5]\\d(:[0-5]\\d(.\\d+)?)?)?(Z|[+\\-](0\\d|1[12])(:[0-5]\\d)?)?)?)?|(0[13-9]|1[012])-(29|30)(T(0\\d|1\\d|2[0-3])(:[0-5]\\d(:[0-5]\\d(.\\d+)?)?)?(Z|[+\\-](0\\d|1[12])(:[0-5]\\d)?)?)?|(0[13578]|1[02])-31(T(0\\d|1\\d|2[0-3])(:[0-5]\\d(:[0-5]\\d(.\\d+)?)?)?(Z|[+\\-](0\\d|1[12])(:[0-5]\\d)?)?)?))?|((15(8[48]|9[26]))|(1[6-9](0[48]|[2468][048]|[13579][26])|20(0[48]|[2468][048]|[13579][26]))|((16|20)00))-02-29(T(\\d|1\\d|2[0-3])(:[0-5]\\d(:[0-5]\\d(.\\d+)?)?)?(Z|[+\\-](0\\d|1[12])(:[0-5]\\d)?)?)?)$']]
    def validate_RecordBasisEnum(self, value):
        result = True
        # Validate type RecordBasisEnum, a restriction on xs:Name.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['PreservedSpecimen', 'LivingSpecimen', 'FossilSpecimen', 'MineralSpecimen', 'OtherSpecimen', 'MaterialSample', 'HumanObservation', 'MachineObservation', 'DrawingOrPhotograph', 'MultimediaObject', 'AbsenceObservation']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on RecordBasisEnum' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_SexCodeEnum(self, value):
        result = True
        # Validate type SexCodeEnum, a restriction on xs:Name.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['M', 'F', 'U', 'N', 'X']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SexCodeEnum' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.GUID is not None or
            self.SourceInstitutionID is not None or
            self.SourceID is not None or
            self.ID is not None or
            self.NumericID is not None or
            self.LastEditor is not None or
            self.DateModified is not None or
            self.Owner is not None or
            self.LegalStatements is not None or
            self.ContentContacts is not None or
            self.InformationWithheld is not None or
            self.SourceReference is not None or
            self.UnitReferences is not None or
            self.Identifications is not None or
            self.IdentificationHistory is not None or
            self.RecordBasis is not None or
            self.KindOfUnit is not None or
            self.SpecimenUnit is not None or
            self.ObservationUnit is not None or
            self.CultureCollectionUnit is not None or
            self.MycologicalUnit is not None or
            self.HerbariumUnit is not None or
            self.BotanicalGardenUnit is not None or
            self.PlantGeneticResourcesUnit is not None or
            self.ZoologicalUnit is not None or
            self.PaleontologicalUnit is not None or
            self.MultimediaObjects is not None or
            self.Associations is not None or
            self.Assemblages is not None or
            self.NamedCollectionsOrSurveys is not None or
            self.Gathering is not None or
            self.FieldNumbers is not None or
            self.FieldNotes is not None or
            self.FieldNotesReferences is not None or
            self.MeasurementsOrFacts is not None or
            self.Sex is not None or
            self.Age is not None or
            self.Sequences is not None or
            self.Notes is not None or
            self.WebsiteURL is not None or
            self.Annotations is not None or
            self.UnitExtensions is not None or
            self.ResourceURIs is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='Unit', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Unit')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Unit')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Unit', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Unit'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='Unit', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.GUID is not None:
            namespaceprefix_ = self.GUID_nsprefix_ + ':' if (UseCapturedNS_ and self.GUID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGUID>%s</%sGUID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.GUID), input_name='GUID')), namespaceprefix_ , eol_))
        if self.SourceInstitutionID is not None:
            namespaceprefix_ = self.SourceInstitutionID_nsprefix_ + ':' if (UseCapturedNS_ and self.SourceInstitutionID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSourceInstitutionID>%s</%sSourceInstitutionID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SourceInstitutionID), input_name='SourceInstitutionID')), namespaceprefix_ , eol_))
        if self.SourceID is not None:
            namespaceprefix_ = self.SourceID_nsprefix_ + ':' if (UseCapturedNS_ and self.SourceID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSourceID>%s</%sSourceID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SourceID), input_name='SourceID')), namespaceprefix_ , eol_))
        if self.ID is not None:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ID), input_name='ID')), namespaceprefix_ , eol_))
        if self.NumericID is not None:
            namespaceprefix_ = self.NumericID_nsprefix_ + ':' if (UseCapturedNS_ and self.NumericID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNumericID>%s</%sNumericID>%s' % (namespaceprefix_ , self.gds_format_integer(self.NumericID, input_name='NumericID'), namespaceprefix_ , eol_))
        if self.LastEditor is not None:
            namespaceprefix_ = self.LastEditor_nsprefix_ + ':' if (UseCapturedNS_ and self.LastEditor_nsprefix_) else ''
            self.LastEditor.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LastEditor', pretty_print=pretty_print)
        if self.DateModified is not None:
            namespaceprefix_ = self.DateModified_nsprefix_ + ':' if (UseCapturedNS_ and self.DateModified_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDateModified>%s</%sDateModified>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DateModified), input_name='DateModified')), namespaceprefix_ , eol_))
        if self.Owner is not None:
            namespaceprefix_ = self.Owner_nsprefix_ + ':' if (UseCapturedNS_ and self.Owner_nsprefix_) else ''
            self.Owner.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Owner', pretty_print=pretty_print)
        if self.LegalStatements is not None:
            namespaceprefix_ = self.LegalStatements_nsprefix_ + ':' if (UseCapturedNS_ and self.LegalStatements_nsprefix_) else ''
            self.LegalStatements.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LegalStatements', pretty_print=pretty_print)
        if self.ContentContacts is not None:
            namespaceprefix_ = self.ContentContacts_nsprefix_ + ':' if (UseCapturedNS_ and self.ContentContacts_nsprefix_) else ''
            self.ContentContacts.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ContentContacts', pretty_print=pretty_print)
        if self.InformationWithheld is not None:
            namespaceprefix_ = self.InformationWithheld_nsprefix_ + ':' if (UseCapturedNS_ and self.InformationWithheld_nsprefix_) else ''
            self.InformationWithheld.export(outfile, level, namespaceprefix_, namespacedef_='', name_='InformationWithheld', pretty_print=pretty_print)
        if self.SourceReference is not None:
            namespaceprefix_ = self.SourceReference_nsprefix_ + ':' if (UseCapturedNS_ and self.SourceReference_nsprefix_) else ''
            self.SourceReference.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SourceReference', pretty_print=pretty_print)
        if self.UnitReferences is not None:
            namespaceprefix_ = self.UnitReferences_nsprefix_ + ':' if (UseCapturedNS_ and self.UnitReferences_nsprefix_) else ''
            self.UnitReferences.export(outfile, level, namespaceprefix_, namespacedef_='', name_='UnitReferences', pretty_print=pretty_print)
        if self.Identifications is not None:
            namespaceprefix_ = self.Identifications_nsprefix_ + ':' if (UseCapturedNS_ and self.Identifications_nsprefix_) else ''
            self.Identifications.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Identifications', pretty_print=pretty_print)
        if self.IdentificationHistory is not None:
            namespaceprefix_ = self.IdentificationHistory_nsprefix_ + ':' if (UseCapturedNS_ and self.IdentificationHistory_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIdentificationHistory>%s</%sIdentificationHistory>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.IdentificationHistory), input_name='IdentificationHistory')), namespaceprefix_ , eol_))
        if self.RecordBasis is not None:
            namespaceprefix_ = self.RecordBasis_nsprefix_ + ':' if (UseCapturedNS_ and self.RecordBasis_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRecordBasis>%s</%sRecordBasis>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.RecordBasis), input_name='RecordBasis')), namespaceprefix_ , eol_))
        if self.KindOfUnit is not None:
            namespaceprefix_ = self.KindOfUnit_nsprefix_ + ':' if (UseCapturedNS_ and self.KindOfUnit_nsprefix_) else ''
            self.KindOfUnit.export(outfile, level, namespaceprefix_, namespacedef_='', name_='KindOfUnit', pretty_print=pretty_print)
        if self.SpecimenUnit is not None:
            namespaceprefix_ = self.SpecimenUnit_nsprefix_ + ':' if (UseCapturedNS_ and self.SpecimenUnit_nsprefix_) else ''
            self.SpecimenUnit.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SpecimenUnit', pretty_print=pretty_print)
        if self.ObservationUnit is not None:
            namespaceprefix_ = self.ObservationUnit_nsprefix_ + ':' if (UseCapturedNS_ and self.ObservationUnit_nsprefix_) else ''
            self.ObservationUnit.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ObservationUnit', pretty_print=pretty_print)
        if self.CultureCollectionUnit is not None:
            namespaceprefix_ = self.CultureCollectionUnit_nsprefix_ + ':' if (UseCapturedNS_ and self.CultureCollectionUnit_nsprefix_) else ''
            self.CultureCollectionUnit.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CultureCollectionUnit', pretty_print=pretty_print)
        if self.MycologicalUnit is not None:
            namespaceprefix_ = self.MycologicalUnit_nsprefix_ + ':' if (UseCapturedNS_ and self.MycologicalUnit_nsprefix_) else ''
            self.MycologicalUnit.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MycologicalUnit', pretty_print=pretty_print)
        if self.HerbariumUnit is not None:
            namespaceprefix_ = self.HerbariumUnit_nsprefix_ + ':' if (UseCapturedNS_ and self.HerbariumUnit_nsprefix_) else ''
            self.HerbariumUnit.export(outfile, level, namespaceprefix_, namespacedef_='', name_='HerbariumUnit', pretty_print=pretty_print)
        if self.BotanicalGardenUnit is not None:
            namespaceprefix_ = self.BotanicalGardenUnit_nsprefix_ + ':' if (UseCapturedNS_ and self.BotanicalGardenUnit_nsprefix_) else ''
            self.BotanicalGardenUnit.export(outfile, level, namespaceprefix_, namespacedef_='', name_='BotanicalGardenUnit', pretty_print=pretty_print)
        if self.PlantGeneticResourcesUnit is not None:
            namespaceprefix_ = self.PlantGeneticResourcesUnit_nsprefix_ + ':' if (UseCapturedNS_ and self.PlantGeneticResourcesUnit_nsprefix_) else ''
            self.PlantGeneticResourcesUnit.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PlantGeneticResourcesUnit', pretty_print=pretty_print)
        if self.ZoologicalUnit is not None:
            namespaceprefix_ = self.ZoologicalUnit_nsprefix_ + ':' if (UseCapturedNS_ and self.ZoologicalUnit_nsprefix_) else ''
            self.ZoologicalUnit.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ZoologicalUnit', pretty_print=pretty_print)
        if self.PaleontologicalUnit is not None:
            namespaceprefix_ = self.PaleontologicalUnit_nsprefix_ + ':' if (UseCapturedNS_ and self.PaleontologicalUnit_nsprefix_) else ''
            self.PaleontologicalUnit.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PaleontologicalUnit', pretty_print=pretty_print)
        if self.MultimediaObjects is not None:
            namespaceprefix_ = self.MultimediaObjects_nsprefix_ + ':' if (UseCapturedNS_ and self.MultimediaObjects_nsprefix_) else ''
            self.MultimediaObjects.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MultimediaObjects', pretty_print=pretty_print)
        if self.Associations is not None:
            namespaceprefix_ = self.Associations_nsprefix_ + ':' if (UseCapturedNS_ and self.Associations_nsprefix_) else ''
            self.Associations.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Associations', pretty_print=pretty_print)
        if self.Assemblages is not None:
            namespaceprefix_ = self.Assemblages_nsprefix_ + ':' if (UseCapturedNS_ and self.Assemblages_nsprefix_) else ''
            self.Assemblages.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Assemblages', pretty_print=pretty_print)
        if self.NamedCollectionsOrSurveys is not None:
            namespaceprefix_ = self.NamedCollectionsOrSurveys_nsprefix_ + ':' if (UseCapturedNS_ and self.NamedCollectionsOrSurveys_nsprefix_) else ''
            self.NamedCollectionsOrSurveys.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NamedCollectionsOrSurveys', pretty_print=pretty_print)
        if self.Gathering is not None:
            namespaceprefix_ = self.Gathering_nsprefix_ + ':' if (UseCapturedNS_ and self.Gathering_nsprefix_) else ''
            self.Gathering.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Gathering', pretty_print=pretty_print)
        if self.FieldNumbers is not None:
            namespaceprefix_ = self.FieldNumbers_nsprefix_ + ':' if (UseCapturedNS_ and self.FieldNumbers_nsprefix_) else ''
            self.FieldNumbers.export(outfile, level, namespaceprefix_, namespacedef_='', name_='FieldNumbers', pretty_print=pretty_print)
        if self.FieldNotes is not None:
            namespaceprefix_ = self.FieldNotes_nsprefix_ + ':' if (UseCapturedNS_ and self.FieldNotes_nsprefix_) else ''
            self.FieldNotes.export(outfile, level, namespaceprefix_, namespacedef_='', name_='FieldNotes', pretty_print=pretty_print)
        if self.FieldNotesReferences is not None:
            namespaceprefix_ = self.FieldNotesReferences_nsprefix_ + ':' if (UseCapturedNS_ and self.FieldNotesReferences_nsprefix_) else ''
            self.FieldNotesReferences.export(outfile, level, namespaceprefix_, namespacedef_='', name_='FieldNotesReferences', pretty_print=pretty_print)
        if self.MeasurementsOrFacts is not None:
            namespaceprefix_ = self.MeasurementsOrFacts_nsprefix_ + ':' if (UseCapturedNS_ and self.MeasurementsOrFacts_nsprefix_) else ''
            self.MeasurementsOrFacts.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MeasurementsOrFacts', pretty_print=pretty_print)
        if self.Sex is not None:
            namespaceprefix_ = self.Sex_nsprefix_ + ':' if (UseCapturedNS_ and self.Sex_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSex>%s</%sSex>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Sex), input_name='Sex')), namespaceprefix_ , eol_))
        if self.Age is not None:
            namespaceprefix_ = self.Age_nsprefix_ + ':' if (UseCapturedNS_ and self.Age_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAge>%s</%sAge>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Age), input_name='Age')), namespaceprefix_ , eol_))
        if self.Sequences is not None:
            namespaceprefix_ = self.Sequences_nsprefix_ + ':' if (UseCapturedNS_ and self.Sequences_nsprefix_) else ''
            self.Sequences.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Sequences', pretty_print=pretty_print)
        if self.Notes is not None:
            namespaceprefix_ = self.Notes_nsprefix_ + ':' if (UseCapturedNS_ and self.Notes_nsprefix_) else ''
            self.Notes.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Notes', pretty_print=pretty_print)
        if self.WebsiteURL is not None:
            namespaceprefix_ = self.WebsiteURL_nsprefix_ + ':' if (UseCapturedNS_ and self.WebsiteURL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sWebsiteURL>%s</%sWebsiteURL>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.WebsiteURL), input_name='WebsiteURL')), namespaceprefix_ , eol_))
        if self.Annotations is not None:
            namespaceprefix_ = self.Annotations_nsprefix_ + ':' if (UseCapturedNS_ and self.Annotations_nsprefix_) else ''
            self.Annotations.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Annotations', pretty_print=pretty_print)
        if self.UnitExtensions is not None:
            namespaceprefix_ = self.UnitExtensions_nsprefix_ + ':' if (UseCapturedNS_ and self.UnitExtensions_nsprefix_) else ''
            self.UnitExtensions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='UnitExtensions', pretty_print=pretty_print)
        if self.ResourceURIs is not None:
            namespaceprefix_ = self.ResourceURIs_nsprefix_ + ':' if (UseCapturedNS_ and self.ResourceURIs_nsprefix_) else ''
            self.ResourceURIs.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ResourceURIs', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'GUID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'GUID')
            value_ = self.gds_validate_string(value_, node, 'GUID')
            self.GUID = value_
            self.GUID_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.GUID)
        elif nodeName_ == 'SourceInstitutionID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SourceInstitutionID')
            value_ = self.gds_validate_string(value_, node, 'SourceInstitutionID')
            self.SourceInstitutionID = value_
            self.SourceInstitutionID_nsprefix_ = child_.prefix
            # validate type InstitutionCode
            self.validate_InstitutionCode(self.SourceInstitutionID)
        elif nodeName_ == 'SourceID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SourceID')
            value_ = self.gds_validate_string(value_, node, 'SourceID')
            self.SourceID = value_
            self.SourceID_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.SourceID)
        elif nodeName_ == 'ID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ID')
            value_ = self.gds_validate_string(value_, node, 'ID')
            self.ID = value_
            self.ID_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.ID)
        elif nodeName_ == 'NumericID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'NumericID')
            ival_ = self.gds_validate_integer(ival_, node, 'NumericID')
            self.NumericID = ival_
            self.NumericID_nsprefix_ = child_.prefix
        elif nodeName_ == 'LastEditor':
            class_obj_ = self.get_class_obj_(child_, Contact)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LastEditor = obj_
            obj_.original_tagname_ = 'LastEditor'
        elif nodeName_ == 'DateModified':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DateModified')
            value_ = self.gds_validate_string(value_, node, 'DateModified')
            self.DateModified = value_
            self.DateModified_nsprefix_ = child_.prefix
            # validate type DateTimeISO
            self.validate_DateTimeISO(self.DateModified)
        elif nodeName_ == 'Owner':
            class_obj_ = self.get_class_obj_(child_, Contact)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Owner = obj_
            obj_.original_tagname_ = 'Owner'
        elif nodeName_ == 'LegalStatements':
            obj_ = LegalStatements.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LegalStatements = obj_
            obj_.original_tagname_ = 'LegalStatements'
        elif nodeName_ == 'ContentContacts':
            obj_ = ContentContactsType3.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ContentContacts = obj_
            obj_.original_tagname_ = 'ContentContacts'
        elif nodeName_ == 'InformationWithheld':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.InformationWithheld = obj_
            obj_.original_tagname_ = 'InformationWithheld'
        elif nodeName_ == 'SourceReference':
            obj_ = Reference.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SourceReference = obj_
            obj_.original_tagname_ = 'SourceReference'
        elif nodeName_ == 'UnitReferences':
            obj_ = UnitReferencesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.UnitReferences = obj_
            obj_.original_tagname_ = 'UnitReferences'
        elif nodeName_ == 'Identifications':
            obj_ = IdentificationsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Identifications = obj_
            obj_.original_tagname_ = 'Identifications'
        elif nodeName_ == 'IdentificationHistory':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'IdentificationHistory')
            value_ = self.gds_validate_string(value_, node, 'IdentificationHistory')
            self.IdentificationHistory = value_
            self.IdentificationHistory_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.IdentificationHistory)
        elif nodeName_ == 'RecordBasis':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'RecordBasis')
            value_ = self.gds_validate_string(value_, node, 'RecordBasis')
            self.RecordBasis = value_
            self.RecordBasis_nsprefix_ = child_.prefix
            # validate type RecordBasisEnum
            self.validate_RecordBasisEnum(self.RecordBasis)
        elif nodeName_ == 'KindOfUnit':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.KindOfUnit = obj_
            obj_.original_tagname_ = 'KindOfUnit'
        elif nodeName_ == 'SpecimenUnit':
            obj_ = SpecimenUnitType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SpecimenUnit = obj_
            obj_.original_tagname_ = 'SpecimenUnit'
        elif nodeName_ == 'ObservationUnit':
            obj_ = ObservationUnitType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ObservationUnit = obj_
            obj_.original_tagname_ = 'ObservationUnit'
        elif nodeName_ == 'CultureCollectionUnit':
            obj_ = CultureCollectionUnit.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CultureCollectionUnit = obj_
            obj_.original_tagname_ = 'CultureCollectionUnit'
        elif nodeName_ == 'MycologicalUnit':
            obj_ = MycologicalUnit.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MycologicalUnit = obj_
            obj_.original_tagname_ = 'MycologicalUnit'
        elif nodeName_ == 'HerbariumUnit':
            obj_ = HerbariumUnit.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.HerbariumUnit = obj_
            obj_.original_tagname_ = 'HerbariumUnit'
        elif nodeName_ == 'BotanicalGardenUnit':
            obj_ = BotanicalGardenUnit.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BotanicalGardenUnit = obj_
            obj_.original_tagname_ = 'BotanicalGardenUnit'
        elif nodeName_ == 'PlantGeneticResourcesUnit':
            obj_ = PGRUnit.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PlantGeneticResourcesUnit = obj_
            obj_.original_tagname_ = 'PlantGeneticResourcesUnit'
        elif nodeName_ == 'ZoologicalUnit':
            obj_ = ZoologicalUnit.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ZoologicalUnit = obj_
            obj_.original_tagname_ = 'ZoologicalUnit'
        elif nodeName_ == 'PaleontologicalUnit':
            obj_ = PaleontologicalUnit.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PaleontologicalUnit = obj_
            obj_.original_tagname_ = 'PaleontologicalUnit'
        elif nodeName_ == 'MultimediaObjects':
            obj_ = MultimediaObjectsType5.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MultimediaObjects = obj_
            obj_.original_tagname_ = 'MultimediaObjects'
        elif nodeName_ == 'Associations':
            obj_ = AssociationsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Associations = obj_
            obj_.original_tagname_ = 'Associations'
        elif nodeName_ == 'Assemblages':
            obj_ = AssemblagesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Assemblages = obj_
            obj_.original_tagname_ = 'Assemblages'
        elif nodeName_ == 'NamedCollectionsOrSurveys':
            obj_ = NamedCollectionsOrSurveysType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NamedCollectionsOrSurveys = obj_
            obj_.original_tagname_ = 'NamedCollectionsOrSurveys'
        elif nodeName_ == 'Gathering':
            obj_ = Gathering.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Gathering = obj_
            obj_.original_tagname_ = 'Gathering'
        elif nodeName_ == 'FieldNumbers':
            obj_ = FieldNumbersType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.FieldNumbers = obj_
            obj_.original_tagname_ = 'FieldNumbers'
        elif nodeName_ == 'FieldNotes':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.FieldNotes = obj_
            obj_.original_tagname_ = 'FieldNotes'
        elif nodeName_ == 'FieldNotesReferences':
            obj_ = FieldNotesReferencesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.FieldNotesReferences = obj_
            obj_.original_tagname_ = 'FieldNotesReferences'
        elif nodeName_ == 'MeasurementsOrFacts':
            obj_ = MeasurementsOrFactsType8.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MeasurementsOrFacts = obj_
            obj_.original_tagname_ = 'MeasurementsOrFacts'
        elif nodeName_ == 'Sex':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Sex')
            value_ = self.gds_validate_string(value_, node, 'Sex')
            self.Sex = value_
            self.Sex_nsprefix_ = child_.prefix
            # validate type SexCodeEnum
            self.validate_SexCodeEnum(self.Sex)
        elif nodeName_ == 'Age':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Age')
            value_ = self.gds_validate_string(value_, node, 'Age')
            self.Age = value_
            self.Age_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.Age)
        elif nodeName_ == 'Sequences':
            obj_ = SequencesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Sequences = obj_
            obj_.original_tagname_ = 'Sequences'
        elif nodeName_ == 'Notes':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Notes = obj_
            obj_.original_tagname_ = 'Notes'
        elif nodeName_ == 'WebsiteURL':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'WebsiteURL')
            value_ = self.gds_validate_string(value_, node, 'WebsiteURL')
            self.WebsiteURL = value_
            self.WebsiteURL_nsprefix_ = child_.prefix
        elif nodeName_ == 'Annotations':
            obj_ = AnnotationsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Annotations = obj_
            obj_.original_tagname_ = 'Annotations'
        elif nodeName_ == 'UnitExtensions':
            obj_ = UnitExtensionsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.UnitExtensions = obj_
            obj_.original_tagname_ = 'UnitExtensions'
        elif nodeName_ == 'ResourceURIs':
            obj_ = ResourceURIsType9.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ResourceURIs = obj_
            obj_.original_tagname_ = 'ResourceURIs'
# end class Unit


class Sequence(GeneratedsSuper):
    """A first proposal for this type of data. Note that this is used in the
    context of a collection unit and thus automatically refers to that
    unit. If your unit is a DNA Sample than please use the GGBN extension.
    This container here is meant to be used e.g. to provide Sequence
    information related to a specimen only without any further details."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('SequenceDatabase', 'StringL', 0, 0, {'name': 'SequenceDatabase', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/sequenceDatabase', 'type': 'StringL'}, None),
        MemberSpec_('ID', ['String', 'xs:normalizedString'], 0, 0, {'name': 'ID', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Sequence-ID', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('Method', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'Method', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Sequence-Method', 'type': 'StringL'}, None),
        MemberSpec_('SequencedPart', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'SequencedPart', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/sequencedPart', 'type': 'StringL'}, None),
        MemberSpec_('Reference', 'Reference', 0, 1, {'minOccurs': '0', 'name': 'Reference', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Sequence-Reference', 'type': 'Reference'}, None),
        MemberSpec_('SequencingAgent', 'Contact', 0, 1, {'minOccurs': '0', 'name': 'SequencingAgent', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/SequencingAgent', 'type': 'Contact'}, None),
        MemberSpec_('SequenceLength', 'xs:integer', 0, 1, {'minOccurs': '0', 'name': 'SequenceLength', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/sequenceLength', 'type': 'xs:integer'}, None),
        MemberSpec_('DirectAccessURL', 'xs:anyURI', 0, 1, {'minOccurs': '0', 'name': 'DirectAccessURL', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Sequence-DirectAccessURL', 'type': 'xs:anyURI'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, SequenceDatabase=None, ID=None, Method=None, SequencedPart=None, Reference=None, SequencingAgent=None, SequenceLength=None, DirectAccessURL=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.SequenceDatabase = SequenceDatabase
        self.SequenceDatabase_nsprefix_ = None
        self.ID = ID
        self.validate_String(self.ID)
        self.ID_nsprefix_ = None
        self.Method = Method
        self.Method_nsprefix_ = None
        self.SequencedPart = SequencedPart
        self.SequencedPart_nsprefix_ = None
        self.Reference = Reference
        self.Reference_nsprefix_ = None
        self.SequencingAgent = SequencingAgent
        self.SequencingAgent_nsprefix_ = None
        self.SequenceLength = SequenceLength
        self.SequenceLength_nsprefix_ = None
        self.DirectAccessURL = DirectAccessURL
        self.DirectAccessURL_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Sequence)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Sequence.subclass:
            return Sequence.subclass(*args_, **kwargs_)
        else:
            return Sequence(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_SequenceDatabase(self):
        return self.SequenceDatabase
    def set_SequenceDatabase(self, SequenceDatabase):
        self.SequenceDatabase = SequenceDatabase
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_Method(self):
        return self.Method
    def set_Method(self, Method):
        self.Method = Method
    def get_SequencedPart(self):
        return self.SequencedPart
    def set_SequencedPart(self, SequencedPart):
        self.SequencedPart = SequencedPart
    def get_Reference(self):
        return self.Reference
    def set_Reference(self, Reference):
        self.Reference = Reference
    def get_SequencingAgent(self):
        return self.SequencingAgent
    def set_SequencingAgent(self, SequencingAgent):
        self.SequencingAgent = SequencingAgent
    def get_SequenceLength(self):
        return self.SequenceLength
    def set_SequenceLength(self, SequenceLength):
        self.SequenceLength = SequenceLength
    def get_DirectAccessURL(self):
        return self.DirectAccessURL
    def set_DirectAccessURL(self, DirectAccessURL):
        self.DirectAccessURL = DirectAccessURL
    def validate_String(self, value):
        result = True
        # Validate type String, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on String' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.SequenceDatabase is not None or
            self.ID is not None or
            self.Method is not None or
            self.SequencedPart is not None or
            self.Reference is not None or
            self.SequencingAgent is not None or
            self.SequenceLength is not None or
            self.DirectAccessURL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='Sequence', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Sequence')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Sequence')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Sequence', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Sequence'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='Sequence', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SequenceDatabase is not None:
            namespaceprefix_ = self.SequenceDatabase_nsprefix_ + ':' if (UseCapturedNS_ and self.SequenceDatabase_nsprefix_) else ''
            self.SequenceDatabase.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SequenceDatabase', pretty_print=pretty_print)
        if self.ID is not None:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ID), input_name='ID')), namespaceprefix_ , eol_))
        if self.Method is not None:
            namespaceprefix_ = self.Method_nsprefix_ + ':' if (UseCapturedNS_ and self.Method_nsprefix_) else ''
            self.Method.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Method', pretty_print=pretty_print)
        if self.SequencedPart is not None:
            namespaceprefix_ = self.SequencedPart_nsprefix_ + ':' if (UseCapturedNS_ and self.SequencedPart_nsprefix_) else ''
            self.SequencedPart.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SequencedPart', pretty_print=pretty_print)
        if self.Reference is not None:
            namespaceprefix_ = self.Reference_nsprefix_ + ':' if (UseCapturedNS_ and self.Reference_nsprefix_) else ''
            self.Reference.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Reference', pretty_print=pretty_print)
        if self.SequencingAgent is not None:
            namespaceprefix_ = self.SequencingAgent_nsprefix_ + ':' if (UseCapturedNS_ and self.SequencingAgent_nsprefix_) else ''
            self.SequencingAgent.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SequencingAgent', pretty_print=pretty_print)
        if self.SequenceLength is not None:
            namespaceprefix_ = self.SequenceLength_nsprefix_ + ':' if (UseCapturedNS_ and self.SequenceLength_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSequenceLength>%s</%sSequenceLength>%s' % (namespaceprefix_ , self.gds_format_integer(self.SequenceLength, input_name='SequenceLength'), namespaceprefix_ , eol_))
        if self.DirectAccessURL is not None:
            namespaceprefix_ = self.DirectAccessURL_nsprefix_ + ':' if (UseCapturedNS_ and self.DirectAccessURL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDirectAccessURL>%s</%sDirectAccessURL>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DirectAccessURL), input_name='DirectAccessURL')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'SequenceDatabase':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SequenceDatabase = obj_
            obj_.original_tagname_ = 'SequenceDatabase'
        elif nodeName_ == 'ID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ID')
            value_ = self.gds_validate_string(value_, node, 'ID')
            self.ID = value_
            self.ID_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.ID)
        elif nodeName_ == 'Method':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Method = obj_
            obj_.original_tagname_ = 'Method'
        elif nodeName_ == 'SequencedPart':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SequencedPart = obj_
            obj_.original_tagname_ = 'SequencedPart'
        elif nodeName_ == 'Reference':
            obj_ = Reference.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Reference = obj_
            obj_.original_tagname_ = 'Reference'
        elif nodeName_ == 'SequencingAgent':
            class_obj_ = self.get_class_obj_(child_, Contact)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SequencingAgent = obj_
            obj_.original_tagname_ = 'SequencingAgent'
        elif nodeName_ == 'SequenceLength' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'SequenceLength')
            ival_ = self.gds_validate_integer(ival_, node, 'SequenceLength')
            self.SequenceLength = ival_
            self.SequenceLength_nsprefix_ = child_.prefix
        elif nodeName_ == 'DirectAccessURL':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DirectAccessURL')
            value_ = self.gds_validate_string(value_, node, 'DirectAccessURL')
            self.DirectAccessURL = value_
            self.DirectAccessURL_nsprefix_ = child_.prefix
# end class Sequence


class StringL(GeneratedsSuper):
    """String (i. e. xs:string with minimum length=1) extended with language
    attribute"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('language', 'xs:language', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', ['String', 'xs:normalizedString'], 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, language=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StringL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StringL.subclass:
            return StringL.subclass(*args_, **kwargs_)
        else:
            return StringL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='StringL', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StringL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StringL')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StringL', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StringL'):
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='StringL', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class StringL


class StringL255(GeneratedsSuper):
    """String255 (i.e. xs:string with length 1-255), extended with language
    attribute"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('language', 'xs:language', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', ['String', 'xs:normalizedString'], 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, language=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StringL255)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StringL255.subclass:
            return StringL255.subclass(*args_, **kwargs_)
        else:
            return StringL255(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='StringL255', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StringL255')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StringL255')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StringL255', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StringL255'):
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='StringL255', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class StringL255


class StringP(GeneratedsSuper):
    """String (i. e. xs:string with minimum length=1) extended with preferred
    attribute"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('preferred', 'xs:boolean', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', ['String', 'xs:normalizedString'], 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, preferred=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.preferred = _cast(bool, preferred)
        self.preferred_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StringP)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StringP.subclass:
            return StringP.subclass(*args_, **kwargs_)
        else:
            return StringP(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_preferred(self):
        return self.preferred
    def set_preferred(self, preferred):
        self.preferred = preferred
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='StringP', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StringP')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StringP')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StringP', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StringP'):
        if self.preferred is not None and 'preferred' not in already_processed:
            already_processed.add('preferred')
            outfile.write(' preferred="%s"' % self.gds_format_boolean(self.preferred, input_name='preferred'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='StringP', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('preferred', node)
        if value is not None and 'preferred' not in already_processed:
            already_processed.add('preferred')
            if value in ('true', '1'):
                self.preferred = True
            elif value in ('false', '0'):
                self.preferred = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class StringP


class StringP255(GeneratedsSuper):
    """String255 (i.e. xs:string with length 1-255), extended with preferred
    attribute"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('preferred', 'xs:boolean', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', ['String255', 'xs:normalizedString'], 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, preferred=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.preferred = _cast(bool, preferred)
        self.preferred_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StringP255)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StringP255.subclass:
            return StringP255.subclass(*args_, **kwargs_)
        else:
            return StringP255(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_preferred(self):
        return self.preferred
    def set_preferred(self, preferred):
        self.preferred = preferred
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='StringP255', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StringP255')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StringP255')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StringP255', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StringP255'):
        if self.preferred is not None and 'preferred' not in already_processed:
            already_processed.add('preferred')
            outfile.write(' preferred="%s"' % self.gds_format_boolean(self.preferred, input_name='preferred'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='StringP255', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('preferred', node)
        if value is not None and 'preferred' not in already_processed:
            already_processed.add('preferred')
            if value in ('true', '1'):
                self.preferred = True
            elif value in ('false', '0'):
                self.preferred = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class StringP255


class StringLP(GeneratedsSuper):
    """String (i. e. xs:string with minimum length=1) extended with language
    and preferred attribute"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('language', 'xs:language', 0, 1, {'use': 'optional'}),
        MemberSpec_('preferred', 'xs:boolean', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', ['String', 'xs:normalizedString'], 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, language=None, preferred=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.preferred = _cast(bool, preferred)
        self.preferred_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StringLP)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StringLP.subclass:
            return StringLP.subclass(*args_, **kwargs_)
        else:
            return StringLP(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_preferred(self):
        return self.preferred
    def set_preferred(self, preferred):
        self.preferred = preferred
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='StringLP', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StringLP')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StringLP')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StringLP', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StringLP'):
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.preferred is not None and 'preferred' not in already_processed:
            already_processed.add('preferred')
            outfile.write(' preferred="%s"' % self.gds_format_boolean(self.preferred, input_name='preferred'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='StringLP', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('preferred', node)
        if value is not None and 'preferred' not in already_processed:
            already_processed.add('preferred')
            if value in ('true', '1'):
                self.preferred = True
            elif value in ('false', '0'):
                self.preferred = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class StringLP


class StringLP255(GeneratedsSuper):
    """String255 (i.e. xs:string with length 1-255), extended with language and
    preferred attribute"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('language', 'xs:language', 0, 1, {'use': 'optional'}),
        MemberSpec_('preferred', 'xs:boolean', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', ['String255', 'xs:normalizedString'], 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, language=None, preferred=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.preferred = _cast(bool, preferred)
        self.preferred_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StringLP255)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StringLP255.subclass:
            return StringLP255.subclass(*args_, **kwargs_)
        else:
            return StringLP255(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_preferred(self):
        return self.preferred
    def set_preferred(self, preferred):
        self.preferred = preferred
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='StringLP255', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StringLP255')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StringLP255')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StringLP255', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StringLP255'):
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.preferred is not None and 'preferred' not in already_processed:
            already_processed.add('preferred')
            outfile.write(' preferred="%s"' % self.gds_format_boolean(self.preferred, input_name='preferred'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='StringLP255', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('preferred', node)
        if value is not None and 'preferred' not in already_processed:
            already_processed.add('preferred')
            if value in ('true', '1'):
                self.preferred = True
            elif value in ('false', '0'):
                self.preferred = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class StringLP255


class anyUriP(GeneratedsSuper):
    """xs:anyURI extended with Preferred attribute"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('preferred', 'xs:boolean', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:anyURI', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, preferred=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.preferred = _cast(bool, preferred)
        self.preferred_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, anyUriP)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if anyUriP.subclass:
            return anyUriP.subclass(*args_, **kwargs_)
        else:
            return anyUriP(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_preferred(self):
        return self.preferred
    def set_preferred(self, preferred):
        self.preferred = preferred
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='anyUriP', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('anyUriP')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='anyUriP')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='anyUriP', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='anyUriP'):
        if self.preferred is not None and 'preferred' not in already_processed:
            already_processed.add('preferred')
            outfile.write(' preferred="%s"' % self.gds_format_boolean(self.preferred, input_name='preferred'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='anyUriP', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('preferred', node)
        if value is not None and 'preferred' not in already_processed:
            already_processed.add('preferred')
            if value in ('true', '1'):
                self.preferred = True
            elif value in ('false', '0'):
                self.preferred = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class anyUriP


class DateTime(GeneratedsSuper):
    """Temporal aspects of an event or activity."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('DateText', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'DateText', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/DateTime-DateText', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('TimeZone', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'TimeZone', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/timeZone', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('ISODateTimeBegin', ['DateTimeISO', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'ISODateTimeBegin', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/timeSpanBegin', 'type': 'xs:string'}, None),
        MemberSpec_('TimeOfDayBegin', 'xs:time', 0, 1, {'minOccurs': '0', 'name': 'TimeOfDayBegin', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/timeOfDayBegin', 'type': 'xs:time'}, None),
        MemberSpec_('ISODateTimeEnd', ['DateTimeISO', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'ISODateTimeEnd', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/timeSpanEnd', 'type': 'xs:string'}, None),
        MemberSpec_('TimeOfDayEnd', 'xs:time', 0, 1, {'minOccurs': '0', 'name': 'TimeOfDayEnd', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/timeOfDayEnd', 'type': 'xs:time'}, None),
        MemberSpec_('PeriodExplicit', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'PeriodExplicit', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/periodExplicit', 'type': 'xs:boolean'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, DateText=None, TimeZone=None, ISODateTimeBegin=None, TimeOfDayBegin=None, ISODateTimeEnd=None, TimeOfDayEnd=None, PeriodExplicit=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.DateText = DateText
        self.validate_String(self.DateText)
        self.DateText_nsprefix_ = None
        self.TimeZone = TimeZone
        self.validate_String(self.TimeZone)
        self.TimeZone_nsprefix_ = None
        self.ISODateTimeBegin = ISODateTimeBegin
        self.validate_DateTimeISO(self.ISODateTimeBegin)
        self.ISODateTimeBegin_nsprefix_ = None
        if isinstance(TimeOfDayBegin, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(TimeOfDayBegin, '%H:%M:%S').time()
        else:
            initvalue_ = TimeOfDayBegin
        self.TimeOfDayBegin = initvalue_
        self.TimeOfDayBegin_nsprefix_ = None
        self.ISODateTimeEnd = ISODateTimeEnd
        self.validate_DateTimeISO(self.ISODateTimeEnd)
        self.ISODateTimeEnd_nsprefix_ = None
        if isinstance(TimeOfDayEnd, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(TimeOfDayEnd, '%H:%M:%S').time()
        else:
            initvalue_ = TimeOfDayEnd
        self.TimeOfDayEnd = initvalue_
        self.TimeOfDayEnd_nsprefix_ = None
        self.PeriodExplicit = PeriodExplicit
        self.PeriodExplicit_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DateTime)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DateTime.subclass:
            return DateTime.subclass(*args_, **kwargs_)
        else:
            return DateTime(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DateText(self):
        return self.DateText
    def set_DateText(self, DateText):
        self.DateText = DateText
    def get_TimeZone(self):
        return self.TimeZone
    def set_TimeZone(self, TimeZone):
        self.TimeZone = TimeZone
    def get_ISODateTimeBegin(self):
        return self.ISODateTimeBegin
    def set_ISODateTimeBegin(self, ISODateTimeBegin):
        self.ISODateTimeBegin = ISODateTimeBegin
    def get_TimeOfDayBegin(self):
        return self.TimeOfDayBegin
    def set_TimeOfDayBegin(self, TimeOfDayBegin):
        self.TimeOfDayBegin = TimeOfDayBegin
    def get_ISODateTimeEnd(self):
        return self.ISODateTimeEnd
    def set_ISODateTimeEnd(self, ISODateTimeEnd):
        self.ISODateTimeEnd = ISODateTimeEnd
    def get_TimeOfDayEnd(self):
        return self.TimeOfDayEnd
    def set_TimeOfDayEnd(self, TimeOfDayEnd):
        self.TimeOfDayEnd = TimeOfDayEnd
    def get_PeriodExplicit(self):
        return self.PeriodExplicit
    def set_PeriodExplicit(self, PeriodExplicit):
        self.PeriodExplicit = PeriodExplicit
    def validate_String(self, value):
        result = True
        # Validate type String, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on String' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_DateTimeISO(self, value):
        result = True
        # Validate type DateTimeISO, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_DateTimeISO_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_DateTimeISO_patterns_, ))
                result = False
        return result
    validate_DateTimeISO_patterns_ = [['^(((1(5(8[3-9]|9\\d)|[6789]\\d\\d))|(20\\d\\d))(-((0[1-9]|1[012])(-(0[1-9]|1\\d|2[0-8])(T(0\\d|1\\d|2[0-3])(:[0-5]\\d(:[0-5]\\d(.\\d+)?)?)?(Z|[+\\-](0\\d|1[12])(:[0-5]\\d)?)?)?)?|(0[13-9]|1[012])-(29|30)(T(0\\d|1\\d|2[0-3])(:[0-5]\\d(:[0-5]\\d(.\\d+)?)?)?(Z|[+\\-](0\\d|1[12])(:[0-5]\\d)?)?)?|(0[13578]|1[02])-31(T(0\\d|1\\d|2[0-3])(:[0-5]\\d(:[0-5]\\d(.\\d+)?)?)?(Z|[+\\-](0\\d|1[12])(:[0-5]\\d)?)?)?))?|((15(8[48]|9[26]))|(1[6-9](0[48]|[2468][048]|[13579][26])|20(0[48]|[2468][048]|[13579][26]))|((16|20)00))-02-29(T(\\d|1\\d|2[0-3])(:[0-5]\\d(:[0-5]\\d(.\\d+)?)?)?(Z|[+\\-](0\\d|1[12])(:[0-5]\\d)?)?)?)$']]
    def hasContent_(self):
        if (
            self.DateText is not None or
            self.TimeZone is not None or
            self.ISODateTimeBegin is not None or
            self.TimeOfDayBegin is not None or
            self.ISODateTimeEnd is not None or
            self.TimeOfDayEnd is not None or
            self.PeriodExplicit is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='DateTime', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DateTime')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DateTime')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DateTime', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DateTime'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='DateTime', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DateText is not None:
            namespaceprefix_ = self.DateText_nsprefix_ + ':' if (UseCapturedNS_ and self.DateText_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDateText>%s</%sDateText>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DateText), input_name='DateText')), namespaceprefix_ , eol_))
        if self.TimeZone is not None:
            namespaceprefix_ = self.TimeZone_nsprefix_ + ':' if (UseCapturedNS_ and self.TimeZone_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTimeZone>%s</%sTimeZone>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TimeZone), input_name='TimeZone')), namespaceprefix_ , eol_))
        if self.ISODateTimeBegin is not None:
            namespaceprefix_ = self.ISODateTimeBegin_nsprefix_ + ':' if (UseCapturedNS_ and self.ISODateTimeBegin_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sISODateTimeBegin>%s</%sISODateTimeBegin>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ISODateTimeBegin), input_name='ISODateTimeBegin')), namespaceprefix_ , eol_))
        if self.TimeOfDayBegin is not None:
            namespaceprefix_ = self.TimeOfDayBegin_nsprefix_ + ':' if (UseCapturedNS_ and self.TimeOfDayBegin_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTimeOfDayBegin>%s</%sTimeOfDayBegin>%s' % (namespaceprefix_ , self.gds_format_time(self.TimeOfDayBegin, input_name='TimeOfDayBegin'), namespaceprefix_ , eol_))
        if self.ISODateTimeEnd is not None:
            namespaceprefix_ = self.ISODateTimeEnd_nsprefix_ + ':' if (UseCapturedNS_ and self.ISODateTimeEnd_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sISODateTimeEnd>%s</%sISODateTimeEnd>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ISODateTimeEnd), input_name='ISODateTimeEnd')), namespaceprefix_ , eol_))
        if self.TimeOfDayEnd is not None:
            namespaceprefix_ = self.TimeOfDayEnd_nsprefix_ + ':' if (UseCapturedNS_ and self.TimeOfDayEnd_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTimeOfDayEnd>%s</%sTimeOfDayEnd>%s' % (namespaceprefix_ , self.gds_format_time(self.TimeOfDayEnd, input_name='TimeOfDayEnd'), namespaceprefix_ , eol_))
        if self.PeriodExplicit is not None:
            namespaceprefix_ = self.PeriodExplicit_nsprefix_ + ':' if (UseCapturedNS_ and self.PeriodExplicit_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPeriodExplicit>%s</%sPeriodExplicit>%s' % (namespaceprefix_ , self.gds_format_boolean(self.PeriodExplicit, input_name='PeriodExplicit'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DateText':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DateText')
            value_ = self.gds_validate_string(value_, node, 'DateText')
            self.DateText = value_
            self.DateText_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.DateText)
        elif nodeName_ == 'TimeZone':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TimeZone')
            value_ = self.gds_validate_string(value_, node, 'TimeZone')
            self.TimeZone = value_
            self.TimeZone_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.TimeZone)
        elif nodeName_ == 'ISODateTimeBegin':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ISODateTimeBegin')
            value_ = self.gds_validate_string(value_, node, 'ISODateTimeBegin')
            self.ISODateTimeBegin = value_
            self.ISODateTimeBegin_nsprefix_ = child_.prefix
            # validate type DateTimeISO
            self.validate_DateTimeISO(self.ISODateTimeBegin)
        elif nodeName_ == 'TimeOfDayBegin':
            sval_ = child_.text
            dval_ = self.gds_parse_time(sval_)
            self.TimeOfDayBegin = dval_
            self.TimeOfDayBegin_nsprefix_ = child_.prefix
        elif nodeName_ == 'ISODateTimeEnd':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ISODateTimeEnd')
            value_ = self.gds_validate_string(value_, node, 'ISODateTimeEnd')
            self.ISODateTimeEnd = value_
            self.ISODateTimeEnd_nsprefix_ = child_.prefix
            # validate type DateTimeISO
            self.validate_DateTimeISO(self.ISODateTimeEnd)
        elif nodeName_ == 'TimeOfDayEnd':
            sval_ = child_.text
            dval_ = self.gds_parse_time(sval_)
            self.TimeOfDayEnd = dval_
            self.TimeOfDayEnd_nsprefix_ = child_.prefix
        elif nodeName_ == 'PeriodExplicit':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'PeriodExplicit')
            ival_ = self.gds_validate_boolean(ival_, node, 'PeriodExplicit')
            self.PeriodExplicit = ival_
            self.PeriodExplicit_nsprefix_ = child_.prefix
# end class DateTime


class Temperature(GeneratedsSuper):
    """Preferably a number, e.g. "-80", "room temperature". Use the attribute
    "scale" to denote the used temperature scale."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('scale', 'xs:NMTOKEN', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, scale=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.scale = _cast(None, scale)
        self.scale_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Temperature)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Temperature.subclass:
            return Temperature.subclass(*args_, **kwargs_)
        else:
            return Temperature(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_scale(self):
        return self.scale
    def set_scale(self, scale):
        self.scale = scale
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Temperature', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Temperature')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Temperature')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Temperature', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Temperature'):
        if self.scale is not None and 'scale' not in already_processed:
            already_processed.add('scale')
            outfile.write(' scale=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.scale), input_name='scale')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Temperature', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('scale', node)
        if value is not None and 'scale' not in already_processed:
            already_processed.add('scale')
            self.scale = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Temperature


class LegalStatement(GeneratedsSuper):
    """Text, optional Details (both free-form text) and optional website URL
    and resource URI."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('language', 'xs:language', 0, 0, {'use': 'required'}),
        MemberSpec_('Text', ['String', 'xs:normalizedString'], 0, 0, {'name': 'Text', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/LegalStatement-Text', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('Details', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'Details', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/LegalStatement-Details', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('WebsiteURL', 'xs:anyURI', 0, 1, {'minOccurs': '0', 'name': 'WebsiteURL', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/LegalStatement-WebsiteURL', 'type': 'xs:anyURI'}, None),
        MemberSpec_('ResourceURI', 'xs:anyURI', 0, 1, {'minOccurs': '0', 'name': 'ResourceURI', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/LegalStatement-ResourceURI', 'type': 'xs:anyURI'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, language=None, Text=None, Details=None, WebsiteURL=None, ResourceURI=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.Text = Text
        self.validate_String(self.Text)
        self.Text_nsprefix_ = None
        self.Details = Details
        self.validate_String(self.Details)
        self.Details_nsprefix_ = None
        self.WebsiteURL = WebsiteURL
        self.WebsiteURL_nsprefix_ = None
        self.ResourceURI = ResourceURI
        self.ResourceURI_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LegalStatement)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LegalStatement.subclass:
            return LegalStatement.subclass(*args_, **kwargs_)
        else:
            return LegalStatement(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Text(self):
        return self.Text
    def set_Text(self, Text):
        self.Text = Text
    def get_Details(self):
        return self.Details
    def set_Details(self, Details):
        self.Details = Details
    def get_WebsiteURL(self):
        return self.WebsiteURL
    def set_WebsiteURL(self, WebsiteURL):
        self.WebsiteURL = WebsiteURL
    def get_ResourceURI(self):
        return self.ResourceURI
    def set_ResourceURI(self, ResourceURI):
        self.ResourceURI = ResourceURI
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def validate_String(self, value):
        result = True
        # Validate type String, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on String' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.Text is not None or
            self.Details is not None or
            self.WebsiteURL is not None or
            self.ResourceURI is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='LegalStatement', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LegalStatement')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LegalStatement')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LegalStatement', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LegalStatement'):
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='LegalStatement', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Text is not None:
            namespaceprefix_ = self.Text_nsprefix_ + ':' if (UseCapturedNS_ and self.Text_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sText>%s</%sText>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Text), input_name='Text')), namespaceprefix_ , eol_))
        if self.Details is not None:
            namespaceprefix_ = self.Details_nsprefix_ + ':' if (UseCapturedNS_ and self.Details_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDetails>%s</%sDetails>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Details), input_name='Details')), namespaceprefix_ , eol_))
        if self.WebsiteURL is not None:
            namespaceprefix_ = self.WebsiteURL_nsprefix_ + ':' if (UseCapturedNS_ and self.WebsiteURL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sWebsiteURL>%s</%sWebsiteURL>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.WebsiteURL), input_name='WebsiteURL')), namespaceprefix_ , eol_))
        if self.ResourceURI is not None:
            namespaceprefix_ = self.ResourceURI_nsprefix_ + ':' if (UseCapturedNS_ and self.ResourceURI_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sResourceURI>%s</%sResourceURI>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ResourceURI), input_name='ResourceURI')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Text':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Text')
            value_ = self.gds_validate_string(value_, node, 'Text')
            self.Text = value_
            self.Text_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.Text)
        elif nodeName_ == 'Details':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Details')
            value_ = self.gds_validate_string(value_, node, 'Details')
            self.Details = value_
            self.Details_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.Details)
        elif nodeName_ == 'WebsiteURL':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'WebsiteURL')
            value_ = self.gds_validate_string(value_, node, 'WebsiteURL')
            self.WebsiteURL = value_
            self.WebsiteURL_nsprefix_ = child_.prefix
        elif nodeName_ == 'ResourceURI':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ResourceURI')
            value_ = self.gds_validate_string(value_, node, 'ResourceURI')
            self.ResourceURI = value_
            self.ResourceURI_nsprefix_ = child_.prefix
# end class LegalStatement


class LegalStatements(GeneratedsSuper):
    """A sequence of statements related to Intellectual Property Rights, credit
    and acknowledgement."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('Licenses', 'LicensesType', 0, 1, {'minOccurs': '0', 'name': 'Licenses', 'type': 'LicensesType'}, None),
        MemberSpec_('Acknowledgements', 'AcknowledgementsType', 0, 1, {'minOccurs': '0', 'name': 'Acknowledgements', 'type': 'AcknowledgementsType'}, None),
        MemberSpec_('SuggestedCitations', 'SuggestedCitationsType', 0, 1, {'minOccurs': '0', 'name': 'SuggestedCitations', 'type': 'SuggestedCitationsType'}, None),
        MemberSpec_('OtherLegalStatements', 'OtherLegalStatementsType', 0, 1, {'minOccurs': '0', 'name': 'OtherLegalStatements', 'type': 'OtherLegalStatementsType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, Licenses=None, Acknowledgements=None, SuggestedCitations=None, OtherLegalStatements=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Licenses = Licenses
        self.Licenses_nsprefix_ = None
        self.Acknowledgements = Acknowledgements
        self.Acknowledgements_nsprefix_ = None
        self.SuggestedCitations = SuggestedCitations
        self.SuggestedCitations_nsprefix_ = None
        self.OtherLegalStatements = OtherLegalStatements
        self.OtherLegalStatements_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LegalStatements)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LegalStatements.subclass:
            return LegalStatements.subclass(*args_, **kwargs_)
        else:
            return LegalStatements(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Licenses(self):
        return self.Licenses
    def set_Licenses(self, Licenses):
        self.Licenses = Licenses
    def get_Acknowledgements(self):
        return self.Acknowledgements
    def set_Acknowledgements(self, Acknowledgements):
        self.Acknowledgements = Acknowledgements
    def get_SuggestedCitations(self):
        return self.SuggestedCitations
    def set_SuggestedCitations(self, SuggestedCitations):
        self.SuggestedCitations = SuggestedCitations
    def get_OtherLegalStatements(self):
        return self.OtherLegalStatements
    def set_OtherLegalStatements(self, OtherLegalStatements):
        self.OtherLegalStatements = OtherLegalStatements
    def hasContent_(self):
        if (
            self.Licenses is not None or
            self.Acknowledgements is not None or
            self.SuggestedCitations is not None or
            self.OtherLegalStatements is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='LegalStatements', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LegalStatements')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LegalStatements')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LegalStatements', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LegalStatements'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='LegalStatements', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Licenses is not None:
            namespaceprefix_ = self.Licenses_nsprefix_ + ':' if (UseCapturedNS_ and self.Licenses_nsprefix_) else ''
            self.Licenses.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Licenses', pretty_print=pretty_print)
        if self.Acknowledgements is not None:
            namespaceprefix_ = self.Acknowledgements_nsprefix_ + ':' if (UseCapturedNS_ and self.Acknowledgements_nsprefix_) else ''
            self.Acknowledgements.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Acknowledgements', pretty_print=pretty_print)
        if self.SuggestedCitations is not None:
            namespaceprefix_ = self.SuggestedCitations_nsprefix_ + ':' if (UseCapturedNS_ and self.SuggestedCitations_nsprefix_) else ''
            self.SuggestedCitations.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SuggestedCitations', pretty_print=pretty_print)
        if self.OtherLegalStatements is not None:
            namespaceprefix_ = self.OtherLegalStatements_nsprefix_ + ':' if (UseCapturedNS_ and self.OtherLegalStatements_nsprefix_) else ''
            self.OtherLegalStatements.export(outfile, level, namespaceprefix_, namespacedef_='', name_='OtherLegalStatements', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Licenses':
            obj_ = LicensesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Licenses = obj_
            obj_.original_tagname_ = 'Licenses'
        elif nodeName_ == 'Acknowledgements':
            obj_ = AcknowledgementsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Acknowledgements = obj_
            obj_.original_tagname_ = 'Acknowledgements'
        elif nodeName_ == 'SuggestedCitations':
            obj_ = SuggestedCitationsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SuggestedCitations = obj_
            obj_.original_tagname_ = 'SuggestedCitations'
        elif nodeName_ == 'OtherLegalStatements':
            obj_ = OtherLegalStatementsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OtherLegalStatements = obj_
            obj_.original_tagname_ = 'OtherLegalStatements'
# end class LegalStatements


class MultimediaObject(GeneratedsSuper):
    """Elements to describe digital images, sound or video recordings, etc."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('ID', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'ID', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/MultimediaObject-ID', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('Type', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'Type', 'sawsdl:modelReference': 'http://purl.org/dc/elements/1.1/type', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('Title', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'Title', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/MultimediaObject-Title', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('IDofContainingCollection', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'IDofContainingCollection', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/IDofContainingCollection', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('Source', 'Reference', 0, 1, {'minOccurs': '0', 'name': 'Source', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/MultimediaObject-Source', 'type': 'Reference'}, None),
        MemberSpec_('Provider', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'Provider', 'sawsdl:modelReference': 'http://rs.tdwg.org/ac/terms/provider', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('FileURL', 'xs:anyURI', 0, 0, {'name': 'FileURL', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/fileURL', 'type': 'xs:anyURI'}, None),
        MemberSpec_('ProductURL', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'ProductURL', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/productURL', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('Context', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'Context', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/multimediaContext', 'type': 'StringL'}, None),
        MemberSpec_('Tags', 'TagsType', 0, 1, {'minOccurs': '0', 'name': 'Tags', 'type': 'TagsType'}, None),
        MemberSpec_('Ratings', 'RatingsType', 0, 1, {'minOccurs': '0', 'name': 'Ratings', 'type': 'RatingsType'}, None),
        MemberSpec_('FileFormat', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'FileFormat', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/fileFormat', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('FileFormatVersion', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'FileFormatVersion', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/FileFormatVersion', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('FileSize', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'FileSize', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/fileSize', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('PhysicalFormat', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'PhysicalFormat', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/physicalFormat', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('PhysicalObjectID', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'PhysicalObjectID', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/physicalObjectID', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('DateCreated', ['DateTimeISO', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'DateCreated', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/MultimediaObject-DateCreated', 'type': 'xs:string'}, None),
        MemberSpec_('Creators', 'CreatorsType', 0, 1, {'minOccurs': '0', 'name': 'Creators', 'type': 'CreatorsType'}, None),
        MemberSpec_('Modified', ['DateTimeISO', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'Modified', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/MultimediaObject-DateModified', 'type': 'xs:string'}, None),
        MemberSpec_('LegalStatements', 'LegalStatements', 0, 1, {'minOccurs': '0', 'name': 'LegalStatements', 'type': 'LegalStatements'}, None),
        MemberSpec_('Notes', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'Notes', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/MultimediaObject-Notes', 'type': 'StringL'}, None),
        MemberSpec_('Sex', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'Sex', 'sawsdl:modelReference': 'http://rs.tdwg.org/dwc/terms/sex', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('LifeStage', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'LifeStage', 'sawsdl:modelReference': 'http://rs.tdwg.org/dwc/terms/lifeStage', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('SubjectPart', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'SubjectPart', 'sawsdl:modelReference': 'http://rs.tdwg.org/ac/terms/subjectPart', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('SubjectOrientation', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'SubjectOrientation', 'sawsdl:modelReference': 'http://rs.tdwg.org/ac/terms/subjectOrientation', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('SubjectDistance', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'SubjectDistance', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/subjectDistance', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('TaxaInBackground', 'TaxaInBackgroundType', 0, 1, {'minOccurs': '0', 'name': 'TaxaInBackground', 'type': 'TaxaInBackgroundType'}, None),
        MemberSpec_('RecordingEnvironment', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'RecordingEnvironment', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/recordingEnvironment', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('Temperature', 'Temperature', 0, 1, {'minOccurs': '0', 'name': 'Temperature', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/MultimediaObject-Temperature', 'type': 'Temperature'}, None),
        MemberSpec_('LightCondition', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'LightCondition', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/lightCondition', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('PlaybackUsed', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'PlaybackUsed', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/playbackUsed', 'type': 'xs:boolean'}, None),
        MemberSpec_('CaptureEquipment', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'CaptureEquipment', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/captureEquipment', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('Counter', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'Counter', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/counter', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('FilterUsedForRecording', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'FilterUsedForRecording', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/filterUsedForRecording', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('MakerNote', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'MakerNote', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/makerNote', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('Audio', 'AudioType', 0, 1, {'minOccurs': '0', 'name': 'Audio', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/AudioObject', 'type': 'AudioType'}, None),
        MemberSpec_('Video', 'VideoType', 0, 1, {'minOccurs': '0', 'name': 'Video', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/VideoObject', 'type': 'VideoType'}, None),
        MemberSpec_('Image', 'ImageType', 0, 1, {'minOccurs': '0', 'name': 'Image', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/ImageObject', 'type': 'ImageType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, ID=None, Type=None, Title=None, IDofContainingCollection=None, Source=None, Provider=None, FileURL=None, ProductURL=None, Context=None, Tags=None, Ratings=None, FileFormat=None, FileFormatVersion=None, FileSize=None, PhysicalFormat=None, PhysicalObjectID=None, DateCreated=None, Creators=None, Modified=None, LegalStatements=None, Notes=None, Sex=None, LifeStage=None, SubjectPart=None, SubjectOrientation=None, SubjectDistance=None, TaxaInBackground=None, RecordingEnvironment=None, Temperature=None, LightCondition=None, PlaybackUsed=None, CaptureEquipment=None, Counter=None, FilterUsedForRecording=None, MakerNote=None, Audio=None, Video=None, Image=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = ID
        self.validate_String(self.ID)
        self.ID_nsprefix_ = None
        self.Type = Type
        self.validate_String(self.Type)
        self.Type_nsprefix_ = None
        self.Title = Title
        self.validate_String(self.Title)
        self.Title_nsprefix_ = None
        self.IDofContainingCollection = IDofContainingCollection
        self.validate_String(self.IDofContainingCollection)
        self.IDofContainingCollection_nsprefix_ = None
        self.Source = Source
        self.Source_nsprefix_ = None
        self.Provider = Provider
        self.validate_String(self.Provider)
        self.Provider_nsprefix_ = None
        self.FileURL = FileURL
        self.FileURL_nsprefix_ = None
        self.ProductURL = ProductURL
        self.validate_String(self.ProductURL)
        self.ProductURL_nsprefix_ = None
        self.Context = Context
        self.Context_nsprefix_ = None
        self.Tags = Tags
        self.Tags_nsprefix_ = None
        self.Ratings = Ratings
        self.Ratings_nsprefix_ = None
        self.FileFormat = FileFormat
        self.validate_String(self.FileFormat)
        self.FileFormat_nsprefix_ = None
        self.FileFormatVersion = FileFormatVersion
        self.validate_String(self.FileFormatVersion)
        self.FileFormatVersion_nsprefix_ = None
        self.FileSize = FileSize
        self.validate_String(self.FileSize)
        self.FileSize_nsprefix_ = None
        self.PhysicalFormat = PhysicalFormat
        self.validate_String(self.PhysicalFormat)
        self.PhysicalFormat_nsprefix_ = None
        self.PhysicalObjectID = PhysicalObjectID
        self.validate_String(self.PhysicalObjectID)
        self.PhysicalObjectID_nsprefix_ = None
        self.DateCreated = DateCreated
        self.validate_DateTimeISO(self.DateCreated)
        self.DateCreated_nsprefix_ = None
        self.Creators = Creators
        self.Creators_nsprefix_ = None
        self.Modified = Modified
        self.validate_DateTimeISO(self.Modified)
        self.Modified_nsprefix_ = None
        self.LegalStatements = LegalStatements
        self.LegalStatements_nsprefix_ = None
        self.Notes = Notes
        self.Notes_nsprefix_ = None
        self.Sex = Sex
        self.validate_String(self.Sex)
        self.Sex_nsprefix_ = None
        self.LifeStage = LifeStage
        self.validate_String(self.LifeStage)
        self.LifeStage_nsprefix_ = None
        self.SubjectPart = SubjectPart
        self.validate_String(self.SubjectPart)
        self.SubjectPart_nsprefix_ = None
        self.SubjectOrientation = SubjectOrientation
        self.validate_String(self.SubjectOrientation)
        self.SubjectOrientation_nsprefix_ = None
        self.SubjectDistance = SubjectDistance
        self.validate_String(self.SubjectDistance)
        self.SubjectDistance_nsprefix_ = None
        self.TaxaInBackground = TaxaInBackground
        self.TaxaInBackground_nsprefix_ = None
        self.RecordingEnvironment = RecordingEnvironment
        self.validate_String(self.RecordingEnvironment)
        self.RecordingEnvironment_nsprefix_ = None
        self.Temperature = Temperature
        self.Temperature_nsprefix_ = None
        self.LightCondition = LightCondition
        self.validate_String(self.LightCondition)
        self.LightCondition_nsprefix_ = None
        self.PlaybackUsed = PlaybackUsed
        self.PlaybackUsed_nsprefix_ = None
        self.CaptureEquipment = CaptureEquipment
        self.validate_String(self.CaptureEquipment)
        self.CaptureEquipment_nsprefix_ = None
        self.Counter = Counter
        self.validate_String(self.Counter)
        self.Counter_nsprefix_ = None
        self.FilterUsedForRecording = FilterUsedForRecording
        self.validate_String(self.FilterUsedForRecording)
        self.FilterUsedForRecording_nsprefix_ = None
        self.MakerNote = MakerNote
        self.validate_String(self.MakerNote)
        self.MakerNote_nsprefix_ = None
        self.Audio = Audio
        self.Audio_nsprefix_ = None
        self.Video = Video
        self.Video_nsprefix_ = None
        self.Image = Image
        self.Image_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MultimediaObject)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MultimediaObject.subclass:
            return MultimediaObject.subclass(*args_, **kwargs_)
        else:
            return MultimediaObject(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_Type(self):
        return self.Type
    def set_Type(self, Type):
        self.Type = Type
    def get_Title(self):
        return self.Title
    def set_Title(self, Title):
        self.Title = Title
    def get_IDofContainingCollection(self):
        return self.IDofContainingCollection
    def set_IDofContainingCollection(self, IDofContainingCollection):
        self.IDofContainingCollection = IDofContainingCollection
    def get_Source(self):
        return self.Source
    def set_Source(self, Source):
        self.Source = Source
    def get_Provider(self):
        return self.Provider
    def set_Provider(self, Provider):
        self.Provider = Provider
    def get_FileURL(self):
        return self.FileURL
    def set_FileURL(self, FileURL):
        self.FileURL = FileURL
    def get_ProductURL(self):
        return self.ProductURL
    def set_ProductURL(self, ProductURL):
        self.ProductURL = ProductURL
    def get_Context(self):
        return self.Context
    def set_Context(self, Context):
        self.Context = Context
    def get_Tags(self):
        return self.Tags
    def set_Tags(self, Tags):
        self.Tags = Tags
    def get_Ratings(self):
        return self.Ratings
    def set_Ratings(self, Ratings):
        self.Ratings = Ratings
    def get_FileFormat(self):
        return self.FileFormat
    def set_FileFormat(self, FileFormat):
        self.FileFormat = FileFormat
    def get_FileFormatVersion(self):
        return self.FileFormatVersion
    def set_FileFormatVersion(self, FileFormatVersion):
        self.FileFormatVersion = FileFormatVersion
    def get_FileSize(self):
        return self.FileSize
    def set_FileSize(self, FileSize):
        self.FileSize = FileSize
    def get_PhysicalFormat(self):
        return self.PhysicalFormat
    def set_PhysicalFormat(self, PhysicalFormat):
        self.PhysicalFormat = PhysicalFormat
    def get_PhysicalObjectID(self):
        return self.PhysicalObjectID
    def set_PhysicalObjectID(self, PhysicalObjectID):
        self.PhysicalObjectID = PhysicalObjectID
    def get_DateCreated(self):
        return self.DateCreated
    def set_DateCreated(self, DateCreated):
        self.DateCreated = DateCreated
    def get_Creators(self):
        return self.Creators
    def set_Creators(self, Creators):
        self.Creators = Creators
    def get_Modified(self):
        return self.Modified
    def set_Modified(self, Modified):
        self.Modified = Modified
    def get_LegalStatements(self):
        return self.LegalStatements
    def set_LegalStatements(self, LegalStatements):
        self.LegalStatements = LegalStatements
    def get_Notes(self):
        return self.Notes
    def set_Notes(self, Notes):
        self.Notes = Notes
    def get_Sex(self):
        return self.Sex
    def set_Sex(self, Sex):
        self.Sex = Sex
    def get_LifeStage(self):
        return self.LifeStage
    def set_LifeStage(self, LifeStage):
        self.LifeStage = LifeStage
    def get_SubjectPart(self):
        return self.SubjectPart
    def set_SubjectPart(self, SubjectPart):
        self.SubjectPart = SubjectPart
    def get_SubjectOrientation(self):
        return self.SubjectOrientation
    def set_SubjectOrientation(self, SubjectOrientation):
        self.SubjectOrientation = SubjectOrientation
    def get_SubjectDistance(self):
        return self.SubjectDistance
    def set_SubjectDistance(self, SubjectDistance):
        self.SubjectDistance = SubjectDistance
    def get_TaxaInBackground(self):
        return self.TaxaInBackground
    def set_TaxaInBackground(self, TaxaInBackground):
        self.TaxaInBackground = TaxaInBackground
    def get_RecordingEnvironment(self):
        return self.RecordingEnvironment
    def set_RecordingEnvironment(self, RecordingEnvironment):
        self.RecordingEnvironment = RecordingEnvironment
    def get_Temperature(self):
        return self.Temperature
    def set_Temperature(self, Temperature):
        self.Temperature = Temperature
    def get_LightCondition(self):
        return self.LightCondition
    def set_LightCondition(self, LightCondition):
        self.LightCondition = LightCondition
    def get_PlaybackUsed(self):
        return self.PlaybackUsed
    def set_PlaybackUsed(self, PlaybackUsed):
        self.PlaybackUsed = PlaybackUsed
    def get_CaptureEquipment(self):
        return self.CaptureEquipment
    def set_CaptureEquipment(self, CaptureEquipment):
        self.CaptureEquipment = CaptureEquipment
    def get_Counter(self):
        return self.Counter
    def set_Counter(self, Counter):
        self.Counter = Counter
    def get_FilterUsedForRecording(self):
        return self.FilterUsedForRecording
    def set_FilterUsedForRecording(self, FilterUsedForRecording):
        self.FilterUsedForRecording = FilterUsedForRecording
    def get_MakerNote(self):
        return self.MakerNote
    def set_MakerNote(self, MakerNote):
        self.MakerNote = MakerNote
    def get_Audio(self):
        return self.Audio
    def set_Audio(self, Audio):
        self.Audio = Audio
    def get_Video(self):
        return self.Video
    def set_Video(self, Video):
        self.Video = Video
    def get_Image(self):
        return self.Image
    def set_Image(self, Image):
        self.Image = Image
    def validate_String(self, value):
        result = True
        # Validate type String, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on String' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_DateTimeISO(self, value):
        result = True
        # Validate type DateTimeISO, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_DateTimeISO_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_DateTimeISO_patterns_, ))
                result = False
        return result
    validate_DateTimeISO_patterns_ = [['^(((1(5(8[3-9]|9\\d)|[6789]\\d\\d))|(20\\d\\d))(-((0[1-9]|1[012])(-(0[1-9]|1\\d|2[0-8])(T(0\\d|1\\d|2[0-3])(:[0-5]\\d(:[0-5]\\d(.\\d+)?)?)?(Z|[+\\-](0\\d|1[12])(:[0-5]\\d)?)?)?)?|(0[13-9]|1[012])-(29|30)(T(0\\d|1\\d|2[0-3])(:[0-5]\\d(:[0-5]\\d(.\\d+)?)?)?(Z|[+\\-](0\\d|1[12])(:[0-5]\\d)?)?)?|(0[13578]|1[02])-31(T(0\\d|1\\d|2[0-3])(:[0-5]\\d(:[0-5]\\d(.\\d+)?)?)?(Z|[+\\-](0\\d|1[12])(:[0-5]\\d)?)?)?))?|((15(8[48]|9[26]))|(1[6-9](0[48]|[2468][048]|[13579][26])|20(0[48]|[2468][048]|[13579][26]))|((16|20)00))-02-29(T(\\d|1\\d|2[0-3])(:[0-5]\\d(:[0-5]\\d(.\\d+)?)?)?(Z|[+\\-](0\\d|1[12])(:[0-5]\\d)?)?)?)$']]
    def hasContent_(self):
        if (
            self.ID is not None or
            self.Type is not None or
            self.Title is not None or
            self.IDofContainingCollection is not None or
            self.Source is not None or
            self.Provider is not None or
            self.FileURL is not None or
            self.ProductURL is not None or
            self.Context is not None or
            self.Tags is not None or
            self.Ratings is not None or
            self.FileFormat is not None or
            self.FileFormatVersion is not None or
            self.FileSize is not None or
            self.PhysicalFormat is not None or
            self.PhysicalObjectID is not None or
            self.DateCreated is not None or
            self.Creators is not None or
            self.Modified is not None or
            self.LegalStatements is not None or
            self.Notes is not None or
            self.Sex is not None or
            self.LifeStage is not None or
            self.SubjectPart is not None or
            self.SubjectOrientation is not None or
            self.SubjectDistance is not None or
            self.TaxaInBackground is not None or
            self.RecordingEnvironment is not None or
            self.Temperature is not None or
            self.LightCondition is not None or
            self.PlaybackUsed is not None or
            self.CaptureEquipment is not None or
            self.Counter is not None or
            self.FilterUsedForRecording is not None or
            self.MakerNote is not None or
            self.Audio is not None or
            self.Video is not None or
            self.Image is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='MultimediaObject', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MultimediaObject')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MultimediaObject')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MultimediaObject', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MultimediaObject'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='MultimediaObject', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ID), input_name='ID')), namespaceprefix_ , eol_))
        if self.Type is not None:
            namespaceprefix_ = self.Type_nsprefix_ + ':' if (UseCapturedNS_ and self.Type_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sType>%s</%sType>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Type), input_name='Type')), namespaceprefix_ , eol_))
        if self.Title is not None:
            namespaceprefix_ = self.Title_nsprefix_ + ':' if (UseCapturedNS_ and self.Title_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTitle>%s</%sTitle>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Title), input_name='Title')), namespaceprefix_ , eol_))
        if self.IDofContainingCollection is not None:
            namespaceprefix_ = self.IDofContainingCollection_nsprefix_ + ':' if (UseCapturedNS_ and self.IDofContainingCollection_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIDofContainingCollection>%s</%sIDofContainingCollection>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.IDofContainingCollection), input_name='IDofContainingCollection')), namespaceprefix_ , eol_))
        if self.Source is not None:
            namespaceprefix_ = self.Source_nsprefix_ + ':' if (UseCapturedNS_ and self.Source_nsprefix_) else ''
            self.Source.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Source', pretty_print=pretty_print)
        if self.Provider is not None:
            namespaceprefix_ = self.Provider_nsprefix_ + ':' if (UseCapturedNS_ and self.Provider_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sProvider>%s</%sProvider>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Provider), input_name='Provider')), namespaceprefix_ , eol_))
        if self.FileURL is not None:
            namespaceprefix_ = self.FileURL_nsprefix_ + ':' if (UseCapturedNS_ and self.FileURL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFileURL>%s</%sFileURL>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.FileURL), input_name='FileURL')), namespaceprefix_ , eol_))
        if self.ProductURL is not None:
            namespaceprefix_ = self.ProductURL_nsprefix_ + ':' if (UseCapturedNS_ and self.ProductURL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sProductURL>%s</%sProductURL>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ProductURL), input_name='ProductURL')), namespaceprefix_ , eol_))
        if self.Context is not None:
            namespaceprefix_ = self.Context_nsprefix_ + ':' if (UseCapturedNS_ and self.Context_nsprefix_) else ''
            self.Context.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Context', pretty_print=pretty_print)
        if self.Tags is not None:
            namespaceprefix_ = self.Tags_nsprefix_ + ':' if (UseCapturedNS_ and self.Tags_nsprefix_) else ''
            self.Tags.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Tags', pretty_print=pretty_print)
        if self.Ratings is not None:
            namespaceprefix_ = self.Ratings_nsprefix_ + ':' if (UseCapturedNS_ and self.Ratings_nsprefix_) else ''
            self.Ratings.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Ratings', pretty_print=pretty_print)
        if self.FileFormat is not None:
            namespaceprefix_ = self.FileFormat_nsprefix_ + ':' if (UseCapturedNS_ and self.FileFormat_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFileFormat>%s</%sFileFormat>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.FileFormat), input_name='FileFormat')), namespaceprefix_ , eol_))
        if self.FileFormatVersion is not None:
            namespaceprefix_ = self.FileFormatVersion_nsprefix_ + ':' if (UseCapturedNS_ and self.FileFormatVersion_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFileFormatVersion>%s</%sFileFormatVersion>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.FileFormatVersion), input_name='FileFormatVersion')), namespaceprefix_ , eol_))
        if self.FileSize is not None:
            namespaceprefix_ = self.FileSize_nsprefix_ + ':' if (UseCapturedNS_ and self.FileSize_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFileSize>%s</%sFileSize>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.FileSize), input_name='FileSize')), namespaceprefix_ , eol_))
        if self.PhysicalFormat is not None:
            namespaceprefix_ = self.PhysicalFormat_nsprefix_ + ':' if (UseCapturedNS_ and self.PhysicalFormat_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPhysicalFormat>%s</%sPhysicalFormat>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PhysicalFormat), input_name='PhysicalFormat')), namespaceprefix_ , eol_))
        if self.PhysicalObjectID is not None:
            namespaceprefix_ = self.PhysicalObjectID_nsprefix_ + ':' if (UseCapturedNS_ and self.PhysicalObjectID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPhysicalObjectID>%s</%sPhysicalObjectID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PhysicalObjectID), input_name='PhysicalObjectID')), namespaceprefix_ , eol_))
        if self.DateCreated is not None:
            namespaceprefix_ = self.DateCreated_nsprefix_ + ':' if (UseCapturedNS_ and self.DateCreated_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDateCreated>%s</%sDateCreated>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DateCreated), input_name='DateCreated')), namespaceprefix_ , eol_))
        if self.Creators is not None:
            namespaceprefix_ = self.Creators_nsprefix_ + ':' if (UseCapturedNS_ and self.Creators_nsprefix_) else ''
            self.Creators.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Creators', pretty_print=pretty_print)
        if self.Modified is not None:
            namespaceprefix_ = self.Modified_nsprefix_ + ':' if (UseCapturedNS_ and self.Modified_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sModified>%s</%sModified>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Modified), input_name='Modified')), namespaceprefix_ , eol_))
        if self.LegalStatements is not None:
            namespaceprefix_ = self.LegalStatements_nsprefix_ + ':' if (UseCapturedNS_ and self.LegalStatements_nsprefix_) else ''
            self.LegalStatements.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LegalStatements', pretty_print=pretty_print)
        if self.Notes is not None:
            namespaceprefix_ = self.Notes_nsprefix_ + ':' if (UseCapturedNS_ and self.Notes_nsprefix_) else ''
            self.Notes.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Notes', pretty_print=pretty_print)
        if self.Sex is not None:
            namespaceprefix_ = self.Sex_nsprefix_ + ':' if (UseCapturedNS_ and self.Sex_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSex>%s</%sSex>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Sex), input_name='Sex')), namespaceprefix_ , eol_))
        if self.LifeStage is not None:
            namespaceprefix_ = self.LifeStage_nsprefix_ + ':' if (UseCapturedNS_ and self.LifeStage_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLifeStage>%s</%sLifeStage>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.LifeStage), input_name='LifeStage')), namespaceprefix_ , eol_))
        if self.SubjectPart is not None:
            namespaceprefix_ = self.SubjectPart_nsprefix_ + ':' if (UseCapturedNS_ and self.SubjectPart_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSubjectPart>%s</%sSubjectPart>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SubjectPart), input_name='SubjectPart')), namespaceprefix_ , eol_))
        if self.SubjectOrientation is not None:
            namespaceprefix_ = self.SubjectOrientation_nsprefix_ + ':' if (UseCapturedNS_ and self.SubjectOrientation_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSubjectOrientation>%s</%sSubjectOrientation>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SubjectOrientation), input_name='SubjectOrientation')), namespaceprefix_ , eol_))
        if self.SubjectDistance is not None:
            namespaceprefix_ = self.SubjectDistance_nsprefix_ + ':' if (UseCapturedNS_ and self.SubjectDistance_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSubjectDistance>%s</%sSubjectDistance>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SubjectDistance), input_name='SubjectDistance')), namespaceprefix_ , eol_))
        if self.TaxaInBackground is not None:
            namespaceprefix_ = self.TaxaInBackground_nsprefix_ + ':' if (UseCapturedNS_ and self.TaxaInBackground_nsprefix_) else ''
            self.TaxaInBackground.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TaxaInBackground', pretty_print=pretty_print)
        if self.RecordingEnvironment is not None:
            namespaceprefix_ = self.RecordingEnvironment_nsprefix_ + ':' if (UseCapturedNS_ and self.RecordingEnvironment_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRecordingEnvironment>%s</%sRecordingEnvironment>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.RecordingEnvironment), input_name='RecordingEnvironment')), namespaceprefix_ , eol_))
        if self.Temperature is not None:
            namespaceprefix_ = self.Temperature_nsprefix_ + ':' if (UseCapturedNS_ and self.Temperature_nsprefix_) else ''
            self.Temperature.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Temperature', pretty_print=pretty_print)
        if self.LightCondition is not None:
            namespaceprefix_ = self.LightCondition_nsprefix_ + ':' if (UseCapturedNS_ and self.LightCondition_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLightCondition>%s</%sLightCondition>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.LightCondition), input_name='LightCondition')), namespaceprefix_ , eol_))
        if self.PlaybackUsed is not None:
            namespaceprefix_ = self.PlaybackUsed_nsprefix_ + ':' if (UseCapturedNS_ and self.PlaybackUsed_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPlaybackUsed>%s</%sPlaybackUsed>%s' % (namespaceprefix_ , self.gds_format_boolean(self.PlaybackUsed, input_name='PlaybackUsed'), namespaceprefix_ , eol_))
        if self.CaptureEquipment is not None:
            namespaceprefix_ = self.CaptureEquipment_nsprefix_ + ':' if (UseCapturedNS_ and self.CaptureEquipment_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCaptureEquipment>%s</%sCaptureEquipment>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CaptureEquipment), input_name='CaptureEquipment')), namespaceprefix_ , eol_))
        if self.Counter is not None:
            namespaceprefix_ = self.Counter_nsprefix_ + ':' if (UseCapturedNS_ and self.Counter_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCounter>%s</%sCounter>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Counter), input_name='Counter')), namespaceprefix_ , eol_))
        if self.FilterUsedForRecording is not None:
            namespaceprefix_ = self.FilterUsedForRecording_nsprefix_ + ':' if (UseCapturedNS_ and self.FilterUsedForRecording_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFilterUsedForRecording>%s</%sFilterUsedForRecording>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.FilterUsedForRecording), input_name='FilterUsedForRecording')), namespaceprefix_ , eol_))
        if self.MakerNote is not None:
            namespaceprefix_ = self.MakerNote_nsprefix_ + ':' if (UseCapturedNS_ and self.MakerNote_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMakerNote>%s</%sMakerNote>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.MakerNote), input_name='MakerNote')), namespaceprefix_ , eol_))
        if self.Audio is not None:
            namespaceprefix_ = self.Audio_nsprefix_ + ':' if (UseCapturedNS_ and self.Audio_nsprefix_) else ''
            self.Audio.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Audio', pretty_print=pretty_print)
        if self.Video is not None:
            namespaceprefix_ = self.Video_nsprefix_ + ':' if (UseCapturedNS_ and self.Video_nsprefix_) else ''
            self.Video.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Video', pretty_print=pretty_print)
        if self.Image is not None:
            namespaceprefix_ = self.Image_nsprefix_ + ':' if (UseCapturedNS_ and self.Image_nsprefix_) else ''
            self.Image.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Image', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ID')
            value_ = self.gds_validate_string(value_, node, 'ID')
            self.ID = value_
            self.ID_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.ID)
        elif nodeName_ == 'Type':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Type')
            value_ = self.gds_validate_string(value_, node, 'Type')
            self.Type = value_
            self.Type_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.Type)
        elif nodeName_ == 'Title':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Title')
            value_ = self.gds_validate_string(value_, node, 'Title')
            self.Title = value_
            self.Title_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.Title)
        elif nodeName_ == 'IDofContainingCollection':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'IDofContainingCollection')
            value_ = self.gds_validate_string(value_, node, 'IDofContainingCollection')
            self.IDofContainingCollection = value_
            self.IDofContainingCollection_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.IDofContainingCollection)
        elif nodeName_ == 'Source':
            obj_ = Reference.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Source = obj_
            obj_.original_tagname_ = 'Source'
        elif nodeName_ == 'Provider':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Provider')
            value_ = self.gds_validate_string(value_, node, 'Provider')
            self.Provider = value_
            self.Provider_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.Provider)
        elif nodeName_ == 'FileURL':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'FileURL')
            value_ = self.gds_validate_string(value_, node, 'FileURL')
            self.FileURL = value_
            self.FileURL_nsprefix_ = child_.prefix
        elif nodeName_ == 'ProductURL':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ProductURL')
            value_ = self.gds_validate_string(value_, node, 'ProductURL')
            self.ProductURL = value_
            self.ProductURL_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.ProductURL)
        elif nodeName_ == 'Context':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Context = obj_
            obj_.original_tagname_ = 'Context'
        elif nodeName_ == 'Tags':
            obj_ = TagsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Tags = obj_
            obj_.original_tagname_ = 'Tags'
        elif nodeName_ == 'Ratings':
            obj_ = RatingsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Ratings = obj_
            obj_.original_tagname_ = 'Ratings'
        elif nodeName_ == 'FileFormat':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'FileFormat')
            value_ = self.gds_validate_string(value_, node, 'FileFormat')
            self.FileFormat = value_
            self.FileFormat_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.FileFormat)
        elif nodeName_ == 'FileFormatVersion':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'FileFormatVersion')
            value_ = self.gds_validate_string(value_, node, 'FileFormatVersion')
            self.FileFormatVersion = value_
            self.FileFormatVersion_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.FileFormatVersion)
        elif nodeName_ == 'FileSize':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'FileSize')
            value_ = self.gds_validate_string(value_, node, 'FileSize')
            self.FileSize = value_
            self.FileSize_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.FileSize)
        elif nodeName_ == 'PhysicalFormat':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PhysicalFormat')
            value_ = self.gds_validate_string(value_, node, 'PhysicalFormat')
            self.PhysicalFormat = value_
            self.PhysicalFormat_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.PhysicalFormat)
        elif nodeName_ == 'PhysicalObjectID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PhysicalObjectID')
            value_ = self.gds_validate_string(value_, node, 'PhysicalObjectID')
            self.PhysicalObjectID = value_
            self.PhysicalObjectID_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.PhysicalObjectID)
        elif nodeName_ == 'DateCreated':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DateCreated')
            value_ = self.gds_validate_string(value_, node, 'DateCreated')
            self.DateCreated = value_
            self.DateCreated_nsprefix_ = child_.prefix
            # validate type DateTimeISO
            self.validate_DateTimeISO(self.DateCreated)
        elif nodeName_ == 'Creators':
            obj_ = CreatorsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Creators = obj_
            obj_.original_tagname_ = 'Creators'
        elif nodeName_ == 'Modified':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Modified')
            value_ = self.gds_validate_string(value_, node, 'Modified')
            self.Modified = value_
            self.Modified_nsprefix_ = child_.prefix
            # validate type DateTimeISO
            self.validate_DateTimeISO(self.Modified)
        elif nodeName_ == 'LegalStatements':
            obj_ = LegalStatements.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LegalStatements = obj_
            obj_.original_tagname_ = 'LegalStatements'
        elif nodeName_ == 'Notes':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Notes = obj_
            obj_.original_tagname_ = 'Notes'
        elif nodeName_ == 'Sex':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Sex')
            value_ = self.gds_validate_string(value_, node, 'Sex')
            self.Sex = value_
            self.Sex_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.Sex)
        elif nodeName_ == 'LifeStage':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'LifeStage')
            value_ = self.gds_validate_string(value_, node, 'LifeStage')
            self.LifeStage = value_
            self.LifeStage_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.LifeStage)
        elif nodeName_ == 'SubjectPart':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SubjectPart')
            value_ = self.gds_validate_string(value_, node, 'SubjectPart')
            self.SubjectPart = value_
            self.SubjectPart_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.SubjectPart)
        elif nodeName_ == 'SubjectOrientation':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SubjectOrientation')
            value_ = self.gds_validate_string(value_, node, 'SubjectOrientation')
            self.SubjectOrientation = value_
            self.SubjectOrientation_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.SubjectOrientation)
        elif nodeName_ == 'SubjectDistance':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SubjectDistance')
            value_ = self.gds_validate_string(value_, node, 'SubjectDistance')
            self.SubjectDistance = value_
            self.SubjectDistance_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.SubjectDistance)
        elif nodeName_ == 'TaxaInBackground':
            obj_ = TaxaInBackgroundType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TaxaInBackground = obj_
            obj_.original_tagname_ = 'TaxaInBackground'
        elif nodeName_ == 'RecordingEnvironment':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'RecordingEnvironment')
            value_ = self.gds_validate_string(value_, node, 'RecordingEnvironment')
            self.RecordingEnvironment = value_
            self.RecordingEnvironment_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.RecordingEnvironment)
        elif nodeName_ == 'Temperature':
            obj_ = Temperature.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Temperature = obj_
            obj_.original_tagname_ = 'Temperature'
        elif nodeName_ == 'LightCondition':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'LightCondition')
            value_ = self.gds_validate_string(value_, node, 'LightCondition')
            self.LightCondition = value_
            self.LightCondition_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.LightCondition)
        elif nodeName_ == 'PlaybackUsed':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'PlaybackUsed')
            ival_ = self.gds_validate_boolean(ival_, node, 'PlaybackUsed')
            self.PlaybackUsed = ival_
            self.PlaybackUsed_nsprefix_ = child_.prefix
        elif nodeName_ == 'CaptureEquipment':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CaptureEquipment')
            value_ = self.gds_validate_string(value_, node, 'CaptureEquipment')
            self.CaptureEquipment = value_
            self.CaptureEquipment_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.CaptureEquipment)
        elif nodeName_ == 'Counter':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Counter')
            value_ = self.gds_validate_string(value_, node, 'Counter')
            self.Counter = value_
            self.Counter_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.Counter)
        elif nodeName_ == 'FilterUsedForRecording':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'FilterUsedForRecording')
            value_ = self.gds_validate_string(value_, node, 'FilterUsedForRecording')
            self.FilterUsedForRecording = value_
            self.FilterUsedForRecording_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.FilterUsedForRecording)
        elif nodeName_ == 'MakerNote':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'MakerNote')
            value_ = self.gds_validate_string(value_, node, 'MakerNote')
            self.MakerNote = value_
            self.MakerNote_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.MakerNote)
        elif nodeName_ == 'Audio':
            obj_ = AudioType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Audio = obj_
            obj_.original_tagname_ = 'Audio'
        elif nodeName_ == 'Video':
            obj_ = VideoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Video = obj_
            obj_.original_tagname_ = 'Video'
        elif nodeName_ == 'Image':
            obj_ = ImageType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Image = obj_
            obj_.original_tagname_ = 'Image'
# end class MultimediaObject


class imageSize(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('Width', 'xs:positiveInteger', 0, 0, {'name': 'Width', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/width', 'type': 'xs:positiveInteger'}, None),
        MemberSpec_('Height', 'xs:positiveInteger', 0, 0, {'name': 'Height', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/height', 'type': 'xs:positiveInteger'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, Width=None, Height=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Width = Width
        self.Width_nsprefix_ = None
        self.Height = Height
        self.Height_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, imageSize)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if imageSize.subclass:
            return imageSize.subclass(*args_, **kwargs_)
        else:
            return imageSize(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Width(self):
        return self.Width
    def set_Width(self, Width):
        self.Width = Width
    def get_Height(self):
        return self.Height
    def set_Height(self, Height):
        self.Height = Height
    def hasContent_(self):
        if (
            self.Width is not None or
            self.Height is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='imageSize', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('imageSize')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='imageSize')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='imageSize', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='imageSize'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='imageSize', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Width is not None:
            namespaceprefix_ = self.Width_nsprefix_ + ':' if (UseCapturedNS_ and self.Width_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sWidth>%s</%sWidth>%s' % (namespaceprefix_ , self.gds_format_integer(self.Width, input_name='Width'), namespaceprefix_ , eol_))
        if self.Height is not None:
            namespaceprefix_ = self.Height_nsprefix_ + ':' if (UseCapturedNS_ and self.Height_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sHeight>%s</%sHeight>%s' % (namespaceprefix_ , self.gds_format_integer(self.Height, input_name='Height'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Width' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'Width')
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'Width')
            self.Width = ival_
            self.Width_nsprefix_ = child_.prefix
        elif nodeName_ == 'Height' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'Height')
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'Height')
            self.Height = ival_
            self.Height_nsprefix_ = child_.prefix
# end class imageSize


class Reference(GeneratedsSuper):
    """Published reference."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('GUID', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'GUID', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Reference-GUID', 'type': 'xs:string'}, None),
        MemberSpec_('Text', ['String', 'xs:normalizedString'], 0, 0, {'name': 'Text', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Reference-Text', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('Details', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'Details', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Reference-Details', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('WebsiteURL', 'xs:anyURI', 0, 1, {'minOccurs': '0', 'name': 'WebsiteURL', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Reference-WebsiteURL', 'type': 'xs:anyURI'}, None),
        MemberSpec_('ResourceURIs', 'ResourceURIsType10', 0, 1, {'minOccurs': '0', 'name': 'ResourceURIs', 'type': 'ResourceURIsType10'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, GUID=None, Text=None, Details=None, WebsiteURL=None, ResourceURIs=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.GUID = GUID
        self.GUID_nsprefix_ = None
        self.Text = Text
        self.validate_String(self.Text)
        self.Text_nsprefix_ = None
        self.Details = Details
        self.validate_String(self.Details)
        self.Details_nsprefix_ = None
        self.WebsiteURL = WebsiteURL
        self.WebsiteURL_nsprefix_ = None
        self.ResourceURIs = ResourceURIs
        self.ResourceURIs_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Reference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Reference.subclass:
            return Reference.subclass(*args_, **kwargs_)
        else:
            return Reference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_GUID(self):
        return self.GUID
    def set_GUID(self, GUID):
        self.GUID = GUID
    def get_Text(self):
        return self.Text
    def set_Text(self, Text):
        self.Text = Text
    def get_Details(self):
        return self.Details
    def set_Details(self, Details):
        self.Details = Details
    def get_WebsiteURL(self):
        return self.WebsiteURL
    def set_WebsiteURL(self, WebsiteURL):
        self.WebsiteURL = WebsiteURL
    def get_ResourceURIs(self):
        return self.ResourceURIs
    def set_ResourceURIs(self, ResourceURIs):
        self.ResourceURIs = ResourceURIs
    def validate_String(self, value):
        result = True
        # Validate type String, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on String' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.GUID is not None or
            self.Text is not None or
            self.Details is not None or
            self.WebsiteURL is not None or
            self.ResourceURIs is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='Reference', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Reference')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Reference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Reference', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Reference'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='Reference', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.GUID is not None:
            namespaceprefix_ = self.GUID_nsprefix_ + ':' if (UseCapturedNS_ and self.GUID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGUID>%s</%sGUID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.GUID), input_name='GUID')), namespaceprefix_ , eol_))
        if self.Text is not None:
            namespaceprefix_ = self.Text_nsprefix_ + ':' if (UseCapturedNS_ and self.Text_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sText>%s</%sText>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Text), input_name='Text')), namespaceprefix_ , eol_))
        if self.Details is not None:
            namespaceprefix_ = self.Details_nsprefix_ + ':' if (UseCapturedNS_ and self.Details_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDetails>%s</%sDetails>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Details), input_name='Details')), namespaceprefix_ , eol_))
        if self.WebsiteURL is not None:
            namespaceprefix_ = self.WebsiteURL_nsprefix_ + ':' if (UseCapturedNS_ and self.WebsiteURL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sWebsiteURL>%s</%sWebsiteURL>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.WebsiteURL), input_name='WebsiteURL')), namespaceprefix_ , eol_))
        if self.ResourceURIs is not None:
            namespaceprefix_ = self.ResourceURIs_nsprefix_ + ':' if (UseCapturedNS_ and self.ResourceURIs_nsprefix_) else ''
            self.ResourceURIs.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ResourceURIs', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'GUID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'GUID')
            value_ = self.gds_validate_string(value_, node, 'GUID')
            self.GUID = value_
            self.GUID_nsprefix_ = child_.prefix
        elif nodeName_ == 'Text':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Text')
            value_ = self.gds_validate_string(value_, node, 'Text')
            self.Text = value_
            self.Text_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.Text)
        elif nodeName_ == 'Details':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Details')
            value_ = self.gds_validate_string(value_, node, 'Details')
            self.Details = value_
            self.Details_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.Details)
        elif nodeName_ == 'WebsiteURL':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'WebsiteURL')
            value_ = self.gds_validate_string(value_, node, 'WebsiteURL')
            self.WebsiteURL = value_
            self.WebsiteURL_nsprefix_ = child_.prefix
        elif nodeName_ == 'ResourceURIs':
            obj_ = ResourceURIsType10.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ResourceURIs = obj_
            obj_.original_tagname_ = 'ResourceURIs'
# end class Reference


class Contact(GeneratedsSuper):
    """Contact details."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('UnformattedValue', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'UnformattedValue', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Contact-UnformattedValue', 'type': 'StringL'}, None),
        MemberSpec_('Organization', 'Organization', 0, 1, {'minOccurs': '0', 'name': 'Organization', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/Organization', 'type': 'Organization'}, None),
        MemberSpec_('Person', 'PersonName', 0, 1, {'minOccurs': '0', 'name': 'Person', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/Person', 'type': 'PersonName'}, None),
        MemberSpec_('Roles', 'RolesType', 0, 1, {'minOccurs': '0', 'name': 'Roles', 'type': 'RolesType'}, None),
        MemberSpec_('Addresses', 'AddressesType', 0, 1, {'minOccurs': '0', 'name': 'Addresses', 'type': 'AddressesType'}, None),
        MemberSpec_('TelephoneNumbers', 'TelephoneNumbersType', 0, 1, {'minOccurs': '0', 'name': 'TelephoneNumbers', 'type': 'TelephoneNumbersType'}, None),
        MemberSpec_('EmailAddresses', 'EmailAddressesType', 0, 1, {'minOccurs': '0', 'name': 'EmailAddresses', 'type': 'EmailAddressesType'}, None),
        MemberSpec_('WebsiteURL', 'xs:anyURI', 0, 1, {'minOccurs': '0', 'name': 'WebsiteURL', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Contact-WebsiteURL', 'type': 'xs:anyURI'}, None),
        MemberSpec_('ResourceURIs', 'ResourceURIsType11', 0, 1, {'minOccurs': '0', 'name': 'ResourceURIs', 'type': 'ResourceURIsType11'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, UnformattedValue=None, Organization=None, Person=None, Roles=None, Addresses=None, TelephoneNumbers=None, EmailAddresses=None, WebsiteURL=None, ResourceURIs=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.UnformattedValue = UnformattedValue
        self.UnformattedValue_nsprefix_ = None
        self.Organization = Organization
        self.Organization_nsprefix_ = None
        self.Person = Person
        self.Person_nsprefix_ = None
        self.Roles = Roles
        self.Roles_nsprefix_ = None
        self.Addresses = Addresses
        self.Addresses_nsprefix_ = None
        self.TelephoneNumbers = TelephoneNumbers
        self.TelephoneNumbers_nsprefix_ = None
        self.EmailAddresses = EmailAddresses
        self.EmailAddresses_nsprefix_ = None
        self.WebsiteURL = WebsiteURL
        self.WebsiteURL_nsprefix_ = None
        self.ResourceURIs = ResourceURIs
        self.ResourceURIs_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Contact)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Contact.subclass:
            return Contact.subclass(*args_, **kwargs_)
        else:
            return Contact(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_UnformattedValue(self):
        return self.UnformattedValue
    def set_UnformattedValue(self, UnformattedValue):
        self.UnformattedValue = UnformattedValue
    def get_Organization(self):
        return self.Organization
    def set_Organization(self, Organization):
        self.Organization = Organization
    def get_Person(self):
        return self.Person
    def set_Person(self, Person):
        self.Person = Person
    def get_Roles(self):
        return self.Roles
    def set_Roles(self, Roles):
        self.Roles = Roles
    def get_Addresses(self):
        return self.Addresses
    def set_Addresses(self, Addresses):
        self.Addresses = Addresses
    def get_TelephoneNumbers(self):
        return self.TelephoneNumbers
    def set_TelephoneNumbers(self, TelephoneNumbers):
        self.TelephoneNumbers = TelephoneNumbers
    def get_EmailAddresses(self):
        return self.EmailAddresses
    def set_EmailAddresses(self, EmailAddresses):
        self.EmailAddresses = EmailAddresses
    def get_WebsiteURL(self):
        return self.WebsiteURL
    def set_WebsiteURL(self, WebsiteURL):
        self.WebsiteURL = WebsiteURL
    def get_ResourceURIs(self):
        return self.ResourceURIs
    def set_ResourceURIs(self, ResourceURIs):
        self.ResourceURIs = ResourceURIs
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.UnformattedValue is not None or
            self.Organization is not None or
            self.Person is not None or
            self.Roles is not None or
            self.Addresses is not None or
            self.TelephoneNumbers is not None or
            self.EmailAddresses is not None or
            self.WebsiteURL is not None or
            self.ResourceURIs is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='Contact', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Contact')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Contact')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Contact', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Contact'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='Contact', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.UnformattedValue is not None:
            namespaceprefix_ = self.UnformattedValue_nsprefix_ + ':' if (UseCapturedNS_ and self.UnformattedValue_nsprefix_) else ''
            self.UnformattedValue.export(outfile, level, namespaceprefix_, namespacedef_='', name_='UnformattedValue', pretty_print=pretty_print)
        if self.Organization is not None:
            namespaceprefix_ = self.Organization_nsprefix_ + ':' if (UseCapturedNS_ and self.Organization_nsprefix_) else ''
            self.Organization.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Organization', pretty_print=pretty_print)
        if self.Person is not None:
            namespaceprefix_ = self.Person_nsprefix_ + ':' if (UseCapturedNS_ and self.Person_nsprefix_) else ''
            self.Person.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Person', pretty_print=pretty_print)
        if self.Roles is not None:
            namespaceprefix_ = self.Roles_nsprefix_ + ':' if (UseCapturedNS_ and self.Roles_nsprefix_) else ''
            self.Roles.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Roles', pretty_print=pretty_print)
        if self.Addresses is not None:
            namespaceprefix_ = self.Addresses_nsprefix_ + ':' if (UseCapturedNS_ and self.Addresses_nsprefix_) else ''
            self.Addresses.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Addresses', pretty_print=pretty_print)
        if self.TelephoneNumbers is not None:
            namespaceprefix_ = self.TelephoneNumbers_nsprefix_ + ':' if (UseCapturedNS_ and self.TelephoneNumbers_nsprefix_) else ''
            self.TelephoneNumbers.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TelephoneNumbers', pretty_print=pretty_print)
        if self.EmailAddresses is not None:
            namespaceprefix_ = self.EmailAddresses_nsprefix_ + ':' if (UseCapturedNS_ and self.EmailAddresses_nsprefix_) else ''
            self.EmailAddresses.export(outfile, level, namespaceprefix_, namespacedef_='', name_='EmailAddresses', pretty_print=pretty_print)
        if self.WebsiteURL is not None:
            namespaceprefix_ = self.WebsiteURL_nsprefix_ + ':' if (UseCapturedNS_ and self.WebsiteURL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sWebsiteURL>%s</%sWebsiteURL>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.WebsiteURL), input_name='WebsiteURL')), namespaceprefix_ , eol_))
        if self.ResourceURIs is not None:
            namespaceprefix_ = self.ResourceURIs_nsprefix_ + ':' if (UseCapturedNS_ and self.ResourceURIs_nsprefix_) else ''
            self.ResourceURIs.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ResourceURIs', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'UnformattedValue':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.UnformattedValue = obj_
            obj_.original_tagname_ = 'UnformattedValue'
        elif nodeName_ == 'Organization':
            obj_ = Organization.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Organization = obj_
            obj_.original_tagname_ = 'Organization'
        elif nodeName_ == 'Person':
            obj_ = PersonName.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Person = obj_
            obj_.original_tagname_ = 'Person'
        elif nodeName_ == 'Roles':
            obj_ = RolesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Roles = obj_
            obj_.original_tagname_ = 'Roles'
        elif nodeName_ == 'Addresses':
            obj_ = AddressesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Addresses = obj_
            obj_.original_tagname_ = 'Addresses'
        elif nodeName_ == 'TelephoneNumbers':
            obj_ = TelephoneNumbersType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TelephoneNumbers = obj_
            obj_.original_tagname_ = 'TelephoneNumbers'
        elif nodeName_ == 'EmailAddresses':
            obj_ = EmailAddressesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EmailAddresses = obj_
            obj_.original_tagname_ = 'EmailAddresses'
        elif nodeName_ == 'WebsiteURL':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'WebsiteURL')
            value_ = self.gds_validate_string(value_, node, 'WebsiteURL')
            self.WebsiteURL = value_
            self.WebsiteURL_nsprefix_ = child_.prefix
        elif nodeName_ == 'ResourceURIs':
            obj_ = ResourceURIsType11.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ResourceURIs = obj_
            obj_.original_tagname_ = 'ResourceURIs'
# end class Contact


class Organization(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('GUID', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'GUID', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Organization-GUID', 'type': 'xs:string'}, None),
        MemberSpec_('Name', 'Label', 0, 0, {'name': 'Name', 'type': 'Label'}, None),
        MemberSpec_('LogoURL', 'xs:anyURI', 0, 1, {'minOccurs': '0', 'name': 'LogoURL', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Organization-LogoURL', 'type': 'xs:anyURI'}, None),
        MemberSpec_('Divisions', 'DivisionsType', 0, 1, {'minOccurs': '0', 'name': 'Divisions', 'type': 'DivisionsType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, GUID=None, Name=None, LogoURL=None, Divisions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.GUID = GUID
        self.GUID_nsprefix_ = None
        self.Name = Name
        self.Name_nsprefix_ = None
        self.LogoURL = LogoURL
        self.LogoURL_nsprefix_ = None
        self.Divisions = Divisions
        self.Divisions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Organization)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Organization.subclass:
            return Organization.subclass(*args_, **kwargs_)
        else:
            return Organization(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_GUID(self):
        return self.GUID
    def set_GUID(self, GUID):
        self.GUID = GUID
    def get_Name(self):
        return self.Name
    def set_Name(self, Name):
        self.Name = Name
    def get_LogoURL(self):
        return self.LogoURL
    def set_LogoURL(self, LogoURL):
        self.LogoURL = LogoURL
    def get_Divisions(self):
        return self.Divisions
    def set_Divisions(self, Divisions):
        self.Divisions = Divisions
    def hasContent_(self):
        if (
            self.GUID is not None or
            self.Name is not None or
            self.LogoURL is not None or
            self.Divisions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='Organization', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Organization')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Organization')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Organization', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Organization'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='Organization', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.GUID is not None:
            namespaceprefix_ = self.GUID_nsprefix_ + ':' if (UseCapturedNS_ and self.GUID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGUID>%s</%sGUID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.GUID), input_name='GUID')), namespaceprefix_ , eol_))
        if self.Name is not None:
            namespaceprefix_ = self.Name_nsprefix_ + ':' if (UseCapturedNS_ and self.Name_nsprefix_) else ''
            self.Name.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Name', pretty_print=pretty_print)
        if self.LogoURL is not None:
            namespaceprefix_ = self.LogoURL_nsprefix_ + ':' if (UseCapturedNS_ and self.LogoURL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLogoURL>%s</%sLogoURL>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.LogoURL), input_name='LogoURL')), namespaceprefix_ , eol_))
        if self.Divisions is not None:
            namespaceprefix_ = self.Divisions_nsprefix_ + ':' if (UseCapturedNS_ and self.Divisions_nsprefix_) else ''
            self.Divisions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Divisions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'GUID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'GUID')
            value_ = self.gds_validate_string(value_, node, 'GUID')
            self.GUID = value_
            self.GUID_nsprefix_ = child_.prefix
        elif nodeName_ == 'Name':
            obj_ = Label.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Name = obj_
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'LogoURL':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'LogoURL')
            value_ = self.gds_validate_string(value_, node, 'LogoURL')
            self.LogoURL = value_
            self.LogoURL_nsprefix_ = child_.prefix
        elif nodeName_ == 'Divisions':
            obj_ = DivisionsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Divisions = obj_
            obj_.original_tagname_ = 'Divisions'
# end class Organization


class Label(GeneratedsSuper):
    """Collection of language-specific label representations"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('Representation', 'RepresentationType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'Representation', 'type': 'RepresentationType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, Representation=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Representation is None:
            self.Representation = []
        else:
            self.Representation = Representation
        self.Representation_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Label)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Label.subclass:
            return Label.subclass(*args_, **kwargs_)
        else:
            return Label(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Representation(self):
        return self.Representation
    def set_Representation(self, Representation):
        self.Representation = Representation
    def add_Representation(self, value):
        self.Representation.append(value)
    def insert_Representation_at(self, index, value):
        self.Representation.insert(index, value)
    def replace_Representation_at(self, index, value):
        self.Representation[index] = value
    def hasContent_(self):
        if (
            self.Representation
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='Label', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Label')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Label')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Label', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Label'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='Label', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Representation_ in self.Representation:
            namespaceprefix_ = self.Representation_nsprefix_ + ':' if (UseCapturedNS_ and self.Representation_nsprefix_) else ''
            Representation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Representation', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Representation':
            obj_ = RepresentationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Representation.append(obj_)
            obj_.original_tagname_ = 'Representation'
# end class Label


class LabelRepr(GeneratedsSuper):
    """Language-specific simple label, using simple formatted text"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('language', 'xs:language', 0, 0, {'use': 'required'}),
        MemberSpec_('Text', ['String255', 'xs:normalizedString'], 0, 0, {'name': 'Text', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Organization-Name', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('Abbreviation', ['String50', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'Abbreviation', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/abbreviation', 'type': 'xs:normalizedString'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, language=None, Text=None, Abbreviation=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.Text = Text
        self.validate_String255(self.Text)
        self.Text_nsprefix_ = None
        self.Abbreviation = Abbreviation
        self.validate_String50(self.Abbreviation)
        self.Abbreviation_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LabelRepr)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LabelRepr.subclass:
            return LabelRepr.subclass(*args_, **kwargs_)
        else:
            return LabelRepr(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Text(self):
        return self.Text
    def set_Text(self, Text):
        self.Text = Text
    def get_Abbreviation(self):
        return self.Abbreviation
    def set_Abbreviation(self, Abbreviation):
        self.Abbreviation = Abbreviation
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_String255(self, value):
        result = True
        # Validate type String255, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 255:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on String255' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on String255' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_String50(self, value):
        result = True
        # Validate type String50, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 50:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on String50' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on String50' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.Text is not None or
            self.Abbreviation is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='LabelRepr', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LabelRepr')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LabelRepr')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LabelRepr', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LabelRepr'):
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='LabelRepr', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Text is not None:
            namespaceprefix_ = self.Text_nsprefix_ + ':' if (UseCapturedNS_ and self.Text_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sText>%s</%sText>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Text), input_name='Text')), namespaceprefix_ , eol_))
        if self.Abbreviation is not None:
            namespaceprefix_ = self.Abbreviation_nsprefix_ + ':' if (UseCapturedNS_ and self.Abbreviation_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAbbreviation>%s</%sAbbreviation>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Abbreviation), input_name='Abbreviation')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Text':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Text')
            value_ = self.gds_validate_string(value_, node, 'Text')
            self.Text = value_
            self.Text_nsprefix_ = child_.prefix
            # validate type String255
            self.validate_String255(self.Text)
        elif nodeName_ == 'Abbreviation':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Abbreviation')
            value_ = self.gds_validate_string(value_, node, 'Abbreviation')
            self.Abbreviation = value_
            self.Abbreviation_nsprefix_ = child_.prefix
            # validate type String50
            self.validate_String50(self.Abbreviation)
# end class LabelRepr


class PersonName(GeneratedsSuper):
    """Name of an individual person"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('FullName', ['String255', 'xs:normalizedString'], 0, 0, {'name': 'FullName', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/fullName', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('SortingName', ['String255', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'SortingName', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/sortingName', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('AtomizedName', 'AtomizedNameType', 0, 1, {'minOccurs': '0', 'name': 'AtomizedName', 'type': 'AtomizedNameType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, FullName=None, SortingName=None, AtomizedName=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.FullName = FullName
        self.validate_String255(self.FullName)
        self.FullName_nsprefix_ = None
        self.SortingName = SortingName
        self.validate_String255(self.SortingName)
        self.SortingName_nsprefix_ = None
        self.AtomizedName = AtomizedName
        self.AtomizedName_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PersonName)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PersonName.subclass:
            return PersonName.subclass(*args_, **kwargs_)
        else:
            return PersonName(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_FullName(self):
        return self.FullName
    def set_FullName(self, FullName):
        self.FullName = FullName
    def get_SortingName(self):
        return self.SortingName
    def set_SortingName(self, SortingName):
        self.SortingName = SortingName
    def get_AtomizedName(self):
        return self.AtomizedName
    def set_AtomizedName(self, AtomizedName):
        self.AtomizedName = AtomizedName
    def validate_String255(self, value):
        result = True
        # Validate type String255, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 255:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on String255' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on String255' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.FullName is not None or
            self.SortingName is not None or
            self.AtomizedName is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='PersonName', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PersonName')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PersonName')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PersonName', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PersonName'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='PersonName', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FullName is not None:
            namespaceprefix_ = self.FullName_nsprefix_ + ':' if (UseCapturedNS_ and self.FullName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFullName>%s</%sFullName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.FullName), input_name='FullName')), namespaceprefix_ , eol_))
        if self.SortingName is not None:
            namespaceprefix_ = self.SortingName_nsprefix_ + ':' if (UseCapturedNS_ and self.SortingName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSortingName>%s</%sSortingName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SortingName), input_name='SortingName')), namespaceprefix_ , eol_))
        if self.AtomizedName is not None:
            namespaceprefix_ = self.AtomizedName_nsprefix_ + ':' if (UseCapturedNS_ and self.AtomizedName_nsprefix_) else ''
            self.AtomizedName.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AtomizedName', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'FullName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'FullName')
            value_ = self.gds_validate_string(value_, node, 'FullName')
            self.FullName = value_
            self.FullName_nsprefix_ = child_.prefix
            # validate type String255
            self.validate_String255(self.FullName)
        elif nodeName_ == 'SortingName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SortingName')
            value_ = self.gds_validate_string(value_, node, 'SortingName')
            self.SortingName = value_
            self.SortingName_nsprefix_ = child_.prefix
            # validate type String255
            self.validate_String255(self.SortingName)
        elif nodeName_ == 'AtomizedName':
            obj_ = AtomizedNameType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AtomizedName = obj_
            obj_.original_tagname_ = 'AtomizedName'
# end class PersonName


class BotanicalGardenUnit(GeneratedsSuper):
    """Elements specific to units from botanical gardens"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('AccessionSpecimenNumbers', 'xs:int', 0, 1, {'minOccurs': '0', 'name': 'AccessionSpecimenNumbers', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/accessionSpecimenNumbers', 'type': 'xs:int'}, None),
        MemberSpec_('AccessionStatus', 'xs:byte', 0, 1, {'minOccurs': '0', 'name': 'AccessionStatus', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/accessionStatus', 'type': 'xs:byte'}, None),
        MemberSpec_('LocationInGarden', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'LocationInGarden', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/locationInGarden', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('AccessionMaterialType', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'AccessionMaterialType', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/accessionMaterialType', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('Hardiness', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'Hardiness', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/hardiness', 'type': 'xs:boolean'}, None),
        MemberSpec_('ProvenanceCategory', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'ProvenanceCategory', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/provenanceCategory', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('PropagationHistoryCode', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'PropagationHistoryCode', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/propagationHistoryCode', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('AccessionLineage', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'AccessionLineage', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/accessionLineage', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('DonorCategory', 'xs:byte', 0, 1, {'minOccurs': '0', 'name': 'DonorCategory', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/donorCategory', 'type': 'xs:byte'}, None),
        MemberSpec_('Cultivation', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'Cultivation', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/cultivation', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('PlantingDate', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'PlantingDate', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/PlantingDate', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('Propagation', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'Propagation', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/propagation', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('Perennation', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'Perennation', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/perennation', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('BreedingSystem', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'BreedingSystem', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/breedingSystem', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('IPEN', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'IPEN', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/ipen', 'type': 'xs:normalizedString'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, AccessionSpecimenNumbers=None, AccessionStatus=None, LocationInGarden=None, AccessionMaterialType=None, Hardiness=None, ProvenanceCategory=None, PropagationHistoryCode=None, AccessionLineage=None, DonorCategory=None, Cultivation=None, PlantingDate=None, Propagation=None, Perennation=None, BreedingSystem=None, IPEN=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.AccessionSpecimenNumbers = AccessionSpecimenNumbers
        self.AccessionSpecimenNumbers_nsprefix_ = None
        self.AccessionStatus = AccessionStatus
        self.AccessionStatus_nsprefix_ = None
        self.LocationInGarden = LocationInGarden
        self.validate_String(self.LocationInGarden)
        self.LocationInGarden_nsprefix_ = None
        self.AccessionMaterialType = AccessionMaterialType
        self.validate_String(self.AccessionMaterialType)
        self.AccessionMaterialType_nsprefix_ = None
        self.Hardiness = Hardiness
        self.Hardiness_nsprefix_ = None
        self.ProvenanceCategory = ProvenanceCategory
        self.validate_String(self.ProvenanceCategory)
        self.ProvenanceCategory_nsprefix_ = None
        self.PropagationHistoryCode = PropagationHistoryCode
        self.validate_String(self.PropagationHistoryCode)
        self.PropagationHistoryCode_nsprefix_ = None
        self.AccessionLineage = AccessionLineage
        self.validate_String(self.AccessionLineage)
        self.AccessionLineage_nsprefix_ = None
        self.DonorCategory = DonorCategory
        self.DonorCategory_nsprefix_ = None
        self.Cultivation = Cultivation
        self.validate_String(self.Cultivation)
        self.Cultivation_nsprefix_ = None
        self.PlantingDate = PlantingDate
        self.validate_String(self.PlantingDate)
        self.PlantingDate_nsprefix_ = None
        self.Propagation = Propagation
        self.validate_String(self.Propagation)
        self.Propagation_nsprefix_ = None
        self.Perennation = Perennation
        self.validate_String(self.Perennation)
        self.Perennation_nsprefix_ = None
        self.BreedingSystem = BreedingSystem
        self.validate_String(self.BreedingSystem)
        self.BreedingSystem_nsprefix_ = None
        self.IPEN = IPEN
        self.validate_String(self.IPEN)
        self.IPEN_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BotanicalGardenUnit)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BotanicalGardenUnit.subclass:
            return BotanicalGardenUnit.subclass(*args_, **kwargs_)
        else:
            return BotanicalGardenUnit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_AccessionSpecimenNumbers(self):
        return self.AccessionSpecimenNumbers
    def set_AccessionSpecimenNumbers(self, AccessionSpecimenNumbers):
        self.AccessionSpecimenNumbers = AccessionSpecimenNumbers
    def get_AccessionStatus(self):
        return self.AccessionStatus
    def set_AccessionStatus(self, AccessionStatus):
        self.AccessionStatus = AccessionStatus
    def get_LocationInGarden(self):
        return self.LocationInGarden
    def set_LocationInGarden(self, LocationInGarden):
        self.LocationInGarden = LocationInGarden
    def get_AccessionMaterialType(self):
        return self.AccessionMaterialType
    def set_AccessionMaterialType(self, AccessionMaterialType):
        self.AccessionMaterialType = AccessionMaterialType
    def get_Hardiness(self):
        return self.Hardiness
    def set_Hardiness(self, Hardiness):
        self.Hardiness = Hardiness
    def get_ProvenanceCategory(self):
        return self.ProvenanceCategory
    def set_ProvenanceCategory(self, ProvenanceCategory):
        self.ProvenanceCategory = ProvenanceCategory
    def get_PropagationHistoryCode(self):
        return self.PropagationHistoryCode
    def set_PropagationHistoryCode(self, PropagationHistoryCode):
        self.PropagationHistoryCode = PropagationHistoryCode
    def get_AccessionLineage(self):
        return self.AccessionLineage
    def set_AccessionLineage(self, AccessionLineage):
        self.AccessionLineage = AccessionLineage
    def get_DonorCategory(self):
        return self.DonorCategory
    def set_DonorCategory(self, DonorCategory):
        self.DonorCategory = DonorCategory
    def get_Cultivation(self):
        return self.Cultivation
    def set_Cultivation(self, Cultivation):
        self.Cultivation = Cultivation
    def get_PlantingDate(self):
        return self.PlantingDate
    def set_PlantingDate(self, PlantingDate):
        self.PlantingDate = PlantingDate
    def get_Propagation(self):
        return self.Propagation
    def set_Propagation(self, Propagation):
        self.Propagation = Propagation
    def get_Perennation(self):
        return self.Perennation
    def set_Perennation(self, Perennation):
        self.Perennation = Perennation
    def get_BreedingSystem(self):
        return self.BreedingSystem
    def set_BreedingSystem(self, BreedingSystem):
        self.BreedingSystem = BreedingSystem
    def get_IPEN(self):
        return self.IPEN
    def set_IPEN(self, IPEN):
        self.IPEN = IPEN
    def validate_String(self, value):
        result = True
        # Validate type String, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on String' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.AccessionSpecimenNumbers is not None or
            self.AccessionStatus is not None or
            self.LocationInGarden is not None or
            self.AccessionMaterialType is not None or
            self.Hardiness is not None or
            self.ProvenanceCategory is not None or
            self.PropagationHistoryCode is not None or
            self.AccessionLineage is not None or
            self.DonorCategory is not None or
            self.Cultivation is not None or
            self.PlantingDate is not None or
            self.Propagation is not None or
            self.Perennation is not None or
            self.BreedingSystem is not None or
            self.IPEN is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='BotanicalGardenUnit', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BotanicalGardenUnit')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BotanicalGardenUnit')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BotanicalGardenUnit', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BotanicalGardenUnit'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='BotanicalGardenUnit', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AccessionSpecimenNumbers is not None:
            namespaceprefix_ = self.AccessionSpecimenNumbers_nsprefix_ + ':' if (UseCapturedNS_ and self.AccessionSpecimenNumbers_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAccessionSpecimenNumbers>%s</%sAccessionSpecimenNumbers>%s' % (namespaceprefix_ , self.gds_format_integer(self.AccessionSpecimenNumbers, input_name='AccessionSpecimenNumbers'), namespaceprefix_ , eol_))
        if self.AccessionStatus is not None:
            namespaceprefix_ = self.AccessionStatus_nsprefix_ + ':' if (UseCapturedNS_ and self.AccessionStatus_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAccessionStatus>%s</%sAccessionStatus>%s' % (namespaceprefix_ , self.gds_format_integer(self.AccessionStatus, input_name='AccessionStatus'), namespaceprefix_ , eol_))
        if self.LocationInGarden is not None:
            namespaceprefix_ = self.LocationInGarden_nsprefix_ + ':' if (UseCapturedNS_ and self.LocationInGarden_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLocationInGarden>%s</%sLocationInGarden>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.LocationInGarden), input_name='LocationInGarden')), namespaceprefix_ , eol_))
        if self.AccessionMaterialType is not None:
            namespaceprefix_ = self.AccessionMaterialType_nsprefix_ + ':' if (UseCapturedNS_ and self.AccessionMaterialType_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAccessionMaterialType>%s</%sAccessionMaterialType>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.AccessionMaterialType), input_name='AccessionMaterialType')), namespaceprefix_ , eol_))
        if self.Hardiness is not None:
            namespaceprefix_ = self.Hardiness_nsprefix_ + ':' if (UseCapturedNS_ and self.Hardiness_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sHardiness>%s</%sHardiness>%s' % (namespaceprefix_ , self.gds_format_boolean(self.Hardiness, input_name='Hardiness'), namespaceprefix_ , eol_))
        if self.ProvenanceCategory is not None:
            namespaceprefix_ = self.ProvenanceCategory_nsprefix_ + ':' if (UseCapturedNS_ and self.ProvenanceCategory_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sProvenanceCategory>%s</%sProvenanceCategory>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ProvenanceCategory), input_name='ProvenanceCategory')), namespaceprefix_ , eol_))
        if self.PropagationHistoryCode is not None:
            namespaceprefix_ = self.PropagationHistoryCode_nsprefix_ + ':' if (UseCapturedNS_ and self.PropagationHistoryCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPropagationHistoryCode>%s</%sPropagationHistoryCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PropagationHistoryCode), input_name='PropagationHistoryCode')), namespaceprefix_ , eol_))
        if self.AccessionLineage is not None:
            namespaceprefix_ = self.AccessionLineage_nsprefix_ + ':' if (UseCapturedNS_ and self.AccessionLineage_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAccessionLineage>%s</%sAccessionLineage>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.AccessionLineage), input_name='AccessionLineage')), namespaceprefix_ , eol_))
        if self.DonorCategory is not None:
            namespaceprefix_ = self.DonorCategory_nsprefix_ + ':' if (UseCapturedNS_ and self.DonorCategory_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDonorCategory>%s</%sDonorCategory>%s' % (namespaceprefix_ , self.gds_format_integer(self.DonorCategory, input_name='DonorCategory'), namespaceprefix_ , eol_))
        if self.Cultivation is not None:
            namespaceprefix_ = self.Cultivation_nsprefix_ + ':' if (UseCapturedNS_ and self.Cultivation_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCultivation>%s</%sCultivation>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Cultivation), input_name='Cultivation')), namespaceprefix_ , eol_))
        if self.PlantingDate is not None:
            namespaceprefix_ = self.PlantingDate_nsprefix_ + ':' if (UseCapturedNS_ and self.PlantingDate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPlantingDate>%s</%sPlantingDate>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PlantingDate), input_name='PlantingDate')), namespaceprefix_ , eol_))
        if self.Propagation is not None:
            namespaceprefix_ = self.Propagation_nsprefix_ + ':' if (UseCapturedNS_ and self.Propagation_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPropagation>%s</%sPropagation>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Propagation), input_name='Propagation')), namespaceprefix_ , eol_))
        if self.Perennation is not None:
            namespaceprefix_ = self.Perennation_nsprefix_ + ':' if (UseCapturedNS_ and self.Perennation_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPerennation>%s</%sPerennation>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Perennation), input_name='Perennation')), namespaceprefix_ , eol_))
        if self.BreedingSystem is not None:
            namespaceprefix_ = self.BreedingSystem_nsprefix_ + ':' if (UseCapturedNS_ and self.BreedingSystem_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBreedingSystem>%s</%sBreedingSystem>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.BreedingSystem), input_name='BreedingSystem')), namespaceprefix_ , eol_))
        if self.IPEN is not None:
            namespaceprefix_ = self.IPEN_nsprefix_ + ':' if (UseCapturedNS_ and self.IPEN_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIPEN>%s</%sIPEN>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.IPEN), input_name='IPEN')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'AccessionSpecimenNumbers' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'AccessionSpecimenNumbers')
            ival_ = self.gds_validate_integer(ival_, node, 'AccessionSpecimenNumbers')
            self.AccessionSpecimenNumbers = ival_
            self.AccessionSpecimenNumbers_nsprefix_ = child_.prefix
        elif nodeName_ == 'AccessionStatus' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'AccessionStatus')
            ival_ = self.gds_validate_integer(ival_, node, 'AccessionStatus')
            self.AccessionStatus = ival_
            self.AccessionStatus_nsprefix_ = child_.prefix
        elif nodeName_ == 'LocationInGarden':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'LocationInGarden')
            value_ = self.gds_validate_string(value_, node, 'LocationInGarden')
            self.LocationInGarden = value_
            self.LocationInGarden_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.LocationInGarden)
        elif nodeName_ == 'AccessionMaterialType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'AccessionMaterialType')
            value_ = self.gds_validate_string(value_, node, 'AccessionMaterialType')
            self.AccessionMaterialType = value_
            self.AccessionMaterialType_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.AccessionMaterialType)
        elif nodeName_ == 'Hardiness':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'Hardiness')
            ival_ = self.gds_validate_boolean(ival_, node, 'Hardiness')
            self.Hardiness = ival_
            self.Hardiness_nsprefix_ = child_.prefix
        elif nodeName_ == 'ProvenanceCategory':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ProvenanceCategory')
            value_ = self.gds_validate_string(value_, node, 'ProvenanceCategory')
            self.ProvenanceCategory = value_
            self.ProvenanceCategory_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.ProvenanceCategory)
        elif nodeName_ == 'PropagationHistoryCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PropagationHistoryCode')
            value_ = self.gds_validate_string(value_, node, 'PropagationHistoryCode')
            self.PropagationHistoryCode = value_
            self.PropagationHistoryCode_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.PropagationHistoryCode)
        elif nodeName_ == 'AccessionLineage':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'AccessionLineage')
            value_ = self.gds_validate_string(value_, node, 'AccessionLineage')
            self.AccessionLineage = value_
            self.AccessionLineage_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.AccessionLineage)
        elif nodeName_ == 'DonorCategory' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'DonorCategory')
            ival_ = self.gds_validate_integer(ival_, node, 'DonorCategory')
            self.DonorCategory = ival_
            self.DonorCategory_nsprefix_ = child_.prefix
        elif nodeName_ == 'Cultivation':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Cultivation')
            value_ = self.gds_validate_string(value_, node, 'Cultivation')
            self.Cultivation = value_
            self.Cultivation_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.Cultivation)
        elif nodeName_ == 'PlantingDate':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PlantingDate')
            value_ = self.gds_validate_string(value_, node, 'PlantingDate')
            self.PlantingDate = value_
            self.PlantingDate_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.PlantingDate)
        elif nodeName_ == 'Propagation':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Propagation')
            value_ = self.gds_validate_string(value_, node, 'Propagation')
            self.Propagation = value_
            self.Propagation_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.Propagation)
        elif nodeName_ == 'Perennation':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Perennation')
            value_ = self.gds_validate_string(value_, node, 'Perennation')
            self.Perennation = value_
            self.Perennation_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.Perennation)
        elif nodeName_ == 'BreedingSystem':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'BreedingSystem')
            value_ = self.gds_validate_string(value_, node, 'BreedingSystem')
            self.BreedingSystem = value_
            self.BreedingSystem_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.BreedingSystem)
        elif nodeName_ == 'IPEN':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'IPEN')
            value_ = self.gds_validate_string(value_, node, 'IPEN')
            self.IPEN = value_
            self.IPEN_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.IPEN)
# end class BotanicalGardenUnit


class CultureCollectionUnit(GeneratedsSuper):
    """Elements only used for units in culture collections"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('OrganismType', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'OrganismType', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/organismType', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('InfrasubspecificName', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'InfrasubspecificName', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/infrasubspecificName', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('CultureNames', 'CultureNamesType', 0, 1, {'minOccurs': '0', 'name': 'CultureNames', 'type': 'CultureNamesType'}, None),
        MemberSpec_('Strain', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'Strain', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/strain', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('SerovarOrSerotype', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'SerovarOrSerotype', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/serovarOrSerotype', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('Pathovar', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'Pathovar', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/pathovar', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('Mutant', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'Mutant', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/mutant', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('Genotype', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'Genotype', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/genotype', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('GrowthConditions', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'GrowthConditions', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/growthConditionsText', 'type': 'StringL'}, None),
        MemberSpec_('GrowthConditionsAtomized', 'GrowthConditionsAtomizedType', 0, 1, {'minOccurs': '0', 'name': 'GrowthConditionsAtomized', 'type': 'GrowthConditionsAtomizedType'}, None),
        MemberSpec_('References', 'ReferencesType12', 0, 1, {'minOccurs': '0', 'name': 'References', 'type': 'ReferencesType12'}, None),
        MemberSpec_('FormOfSupply', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'FormOfSupply', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/formOfSupply', 'type': 'StringL'}, None),
        MemberSpec_('Applications', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'Applications', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/applications', 'type': 'StringL'}, None),
        MemberSpec_('Hazard', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'Hazard', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/hazard', 'type': 'StringL'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, OrganismType=None, InfrasubspecificName=None, CultureNames=None, Strain=None, SerovarOrSerotype=None, Pathovar=None, Mutant=None, Genotype=None, GrowthConditions=None, GrowthConditionsAtomized=None, References=None, FormOfSupply=None, Applications=None, Hazard=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.OrganismType = OrganismType
        self.validate_String(self.OrganismType)
        self.OrganismType_nsprefix_ = None
        self.InfrasubspecificName = InfrasubspecificName
        self.validate_String(self.InfrasubspecificName)
        self.InfrasubspecificName_nsprefix_ = None
        self.CultureNames = CultureNames
        self.CultureNames_nsprefix_ = None
        self.Strain = Strain
        self.validate_String(self.Strain)
        self.Strain_nsprefix_ = None
        self.SerovarOrSerotype = SerovarOrSerotype
        self.validate_String(self.SerovarOrSerotype)
        self.SerovarOrSerotype_nsprefix_ = None
        self.Pathovar = Pathovar
        self.validate_String(self.Pathovar)
        self.Pathovar_nsprefix_ = None
        self.Mutant = Mutant
        self.validate_String(self.Mutant)
        self.Mutant_nsprefix_ = None
        self.Genotype = Genotype
        self.validate_String(self.Genotype)
        self.Genotype_nsprefix_ = None
        self.GrowthConditions = GrowthConditions
        self.GrowthConditions_nsprefix_ = None
        self.GrowthConditionsAtomized = GrowthConditionsAtomized
        self.GrowthConditionsAtomized_nsprefix_ = None
        self.References = References
        self.References_nsprefix_ = None
        self.FormOfSupply = FormOfSupply
        self.FormOfSupply_nsprefix_ = None
        self.Applications = Applications
        self.Applications_nsprefix_ = None
        self.Hazard = Hazard
        self.Hazard_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CultureCollectionUnit)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CultureCollectionUnit.subclass:
            return CultureCollectionUnit.subclass(*args_, **kwargs_)
        else:
            return CultureCollectionUnit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_OrganismType(self):
        return self.OrganismType
    def set_OrganismType(self, OrganismType):
        self.OrganismType = OrganismType
    def get_InfrasubspecificName(self):
        return self.InfrasubspecificName
    def set_InfrasubspecificName(self, InfrasubspecificName):
        self.InfrasubspecificName = InfrasubspecificName
    def get_CultureNames(self):
        return self.CultureNames
    def set_CultureNames(self, CultureNames):
        self.CultureNames = CultureNames
    def get_Strain(self):
        return self.Strain
    def set_Strain(self, Strain):
        self.Strain = Strain
    def get_SerovarOrSerotype(self):
        return self.SerovarOrSerotype
    def set_SerovarOrSerotype(self, SerovarOrSerotype):
        self.SerovarOrSerotype = SerovarOrSerotype
    def get_Pathovar(self):
        return self.Pathovar
    def set_Pathovar(self, Pathovar):
        self.Pathovar = Pathovar
    def get_Mutant(self):
        return self.Mutant
    def set_Mutant(self, Mutant):
        self.Mutant = Mutant
    def get_Genotype(self):
        return self.Genotype
    def set_Genotype(self, Genotype):
        self.Genotype = Genotype
    def get_GrowthConditions(self):
        return self.GrowthConditions
    def set_GrowthConditions(self, GrowthConditions):
        self.GrowthConditions = GrowthConditions
    def get_GrowthConditionsAtomized(self):
        return self.GrowthConditionsAtomized
    def set_GrowthConditionsAtomized(self, GrowthConditionsAtomized):
        self.GrowthConditionsAtomized = GrowthConditionsAtomized
    def get_References(self):
        return self.References
    def set_References(self, References):
        self.References = References
    def get_FormOfSupply(self):
        return self.FormOfSupply
    def set_FormOfSupply(self, FormOfSupply):
        self.FormOfSupply = FormOfSupply
    def get_Applications(self):
        return self.Applications
    def set_Applications(self, Applications):
        self.Applications = Applications
    def get_Hazard(self):
        return self.Hazard
    def set_Hazard(self, Hazard):
        self.Hazard = Hazard
    def validate_String(self, value):
        result = True
        # Validate type String, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on String' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.OrganismType is not None or
            self.InfrasubspecificName is not None or
            self.CultureNames is not None or
            self.Strain is not None or
            self.SerovarOrSerotype is not None or
            self.Pathovar is not None or
            self.Mutant is not None or
            self.Genotype is not None or
            self.GrowthConditions is not None or
            self.GrowthConditionsAtomized is not None or
            self.References is not None or
            self.FormOfSupply is not None or
            self.Applications is not None or
            self.Hazard is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='CultureCollectionUnit', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CultureCollectionUnit')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CultureCollectionUnit')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CultureCollectionUnit', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CultureCollectionUnit'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='CultureCollectionUnit', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OrganismType is not None:
            namespaceprefix_ = self.OrganismType_nsprefix_ + ':' if (UseCapturedNS_ and self.OrganismType_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOrganismType>%s</%sOrganismType>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.OrganismType), input_name='OrganismType')), namespaceprefix_ , eol_))
        if self.InfrasubspecificName is not None:
            namespaceprefix_ = self.InfrasubspecificName_nsprefix_ + ':' if (UseCapturedNS_ and self.InfrasubspecificName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sInfrasubspecificName>%s</%sInfrasubspecificName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.InfrasubspecificName), input_name='InfrasubspecificName')), namespaceprefix_ , eol_))
        if self.CultureNames is not None:
            namespaceprefix_ = self.CultureNames_nsprefix_ + ':' if (UseCapturedNS_ and self.CultureNames_nsprefix_) else ''
            self.CultureNames.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CultureNames', pretty_print=pretty_print)
        if self.Strain is not None:
            namespaceprefix_ = self.Strain_nsprefix_ + ':' if (UseCapturedNS_ and self.Strain_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStrain>%s</%sStrain>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Strain), input_name='Strain')), namespaceprefix_ , eol_))
        if self.SerovarOrSerotype is not None:
            namespaceprefix_ = self.SerovarOrSerotype_nsprefix_ + ':' if (UseCapturedNS_ and self.SerovarOrSerotype_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSerovarOrSerotype>%s</%sSerovarOrSerotype>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SerovarOrSerotype), input_name='SerovarOrSerotype')), namespaceprefix_ , eol_))
        if self.Pathovar is not None:
            namespaceprefix_ = self.Pathovar_nsprefix_ + ':' if (UseCapturedNS_ and self.Pathovar_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPathovar>%s</%sPathovar>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Pathovar), input_name='Pathovar')), namespaceprefix_ , eol_))
        if self.Mutant is not None:
            namespaceprefix_ = self.Mutant_nsprefix_ + ':' if (UseCapturedNS_ and self.Mutant_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMutant>%s</%sMutant>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Mutant), input_name='Mutant')), namespaceprefix_ , eol_))
        if self.Genotype is not None:
            namespaceprefix_ = self.Genotype_nsprefix_ + ':' if (UseCapturedNS_ and self.Genotype_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGenotype>%s</%sGenotype>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Genotype), input_name='Genotype')), namespaceprefix_ , eol_))
        if self.GrowthConditions is not None:
            namespaceprefix_ = self.GrowthConditions_nsprefix_ + ':' if (UseCapturedNS_ and self.GrowthConditions_nsprefix_) else ''
            self.GrowthConditions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='GrowthConditions', pretty_print=pretty_print)
        if self.GrowthConditionsAtomized is not None:
            namespaceprefix_ = self.GrowthConditionsAtomized_nsprefix_ + ':' if (UseCapturedNS_ and self.GrowthConditionsAtomized_nsprefix_) else ''
            self.GrowthConditionsAtomized.export(outfile, level, namespaceprefix_, namespacedef_='', name_='GrowthConditionsAtomized', pretty_print=pretty_print)
        if self.References is not None:
            namespaceprefix_ = self.References_nsprefix_ + ':' if (UseCapturedNS_ and self.References_nsprefix_) else ''
            self.References.export(outfile, level, namespaceprefix_, namespacedef_='', name_='References', pretty_print=pretty_print)
        if self.FormOfSupply is not None:
            namespaceprefix_ = self.FormOfSupply_nsprefix_ + ':' if (UseCapturedNS_ and self.FormOfSupply_nsprefix_) else ''
            self.FormOfSupply.export(outfile, level, namespaceprefix_, namespacedef_='', name_='FormOfSupply', pretty_print=pretty_print)
        if self.Applications is not None:
            namespaceprefix_ = self.Applications_nsprefix_ + ':' if (UseCapturedNS_ and self.Applications_nsprefix_) else ''
            self.Applications.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Applications', pretty_print=pretty_print)
        if self.Hazard is not None:
            namespaceprefix_ = self.Hazard_nsprefix_ + ':' if (UseCapturedNS_ and self.Hazard_nsprefix_) else ''
            self.Hazard.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Hazard', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'OrganismType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'OrganismType')
            value_ = self.gds_validate_string(value_, node, 'OrganismType')
            self.OrganismType = value_
            self.OrganismType_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.OrganismType)
        elif nodeName_ == 'InfrasubspecificName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'InfrasubspecificName')
            value_ = self.gds_validate_string(value_, node, 'InfrasubspecificName')
            self.InfrasubspecificName = value_
            self.InfrasubspecificName_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.InfrasubspecificName)
        elif nodeName_ == 'CultureNames':
            obj_ = CultureNamesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CultureNames = obj_
            obj_.original_tagname_ = 'CultureNames'
        elif nodeName_ == 'Strain':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Strain')
            value_ = self.gds_validate_string(value_, node, 'Strain')
            self.Strain = value_
            self.Strain_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.Strain)
        elif nodeName_ == 'SerovarOrSerotype':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SerovarOrSerotype')
            value_ = self.gds_validate_string(value_, node, 'SerovarOrSerotype')
            self.SerovarOrSerotype = value_
            self.SerovarOrSerotype_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.SerovarOrSerotype)
        elif nodeName_ == 'Pathovar':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Pathovar')
            value_ = self.gds_validate_string(value_, node, 'Pathovar')
            self.Pathovar = value_
            self.Pathovar_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.Pathovar)
        elif nodeName_ == 'Mutant':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Mutant')
            value_ = self.gds_validate_string(value_, node, 'Mutant')
            self.Mutant = value_
            self.Mutant_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.Mutant)
        elif nodeName_ == 'Genotype':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Genotype')
            value_ = self.gds_validate_string(value_, node, 'Genotype')
            self.Genotype = value_
            self.Genotype_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.Genotype)
        elif nodeName_ == 'GrowthConditions':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.GrowthConditions = obj_
            obj_.original_tagname_ = 'GrowthConditions'
        elif nodeName_ == 'GrowthConditionsAtomized':
            obj_ = GrowthConditionsAtomizedType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.GrowthConditionsAtomized = obj_
            obj_.original_tagname_ = 'GrowthConditionsAtomized'
        elif nodeName_ == 'References':
            obj_ = ReferencesType12.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.References = obj_
            obj_.original_tagname_ = 'References'
        elif nodeName_ == 'FormOfSupply':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.FormOfSupply = obj_
            obj_.original_tagname_ = 'FormOfSupply'
        elif nodeName_ == 'Applications':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Applications = obj_
            obj_.original_tagname_ = 'Applications'
        elif nodeName_ == 'Hazard':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Hazard = obj_
            obj_.original_tagname_ = 'Hazard'
# end class CultureCollectionUnit


class GrowthConditionAtomized(GeneratedsSuper):
    """Atomized elements describing the growth conditions of the culture
    unit."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('CultureMedium', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'CultureMedium', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/cultureMedium', 'type': 'StringL'}, None),
        MemberSpec_('Aerobicity', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'Aerobicity', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/aerobicity', 'type': 'StringL'}, None),
        MemberSpec_('Temperature', 'Temperature', 0, 1, {'minOccurs': '0', 'name': 'Temperature', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/GrowthCondition-Temperature', 'type': 'Temperature'}, None),
        MemberSpec_('References', 'ReferencesType13', 0, 1, {'minOccurs': '0', 'name': 'References', 'type': 'ReferencesType13'}, None),
        MemberSpec_('GrowthConditionsMeasurementsOrFacts', 'GrowthConditionsMeasurementsOrFactsType', 0, 1, {'minOccurs': '0', 'name': 'GrowthConditionsMeasurementsOrFacts', 'type': 'GrowthConditionsMeasurementsOrFactsType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, CultureMedium=None, Aerobicity=None, Temperature=None, References=None, GrowthConditionsMeasurementsOrFacts=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.CultureMedium = CultureMedium
        self.CultureMedium_nsprefix_ = None
        self.Aerobicity = Aerobicity
        self.Aerobicity_nsprefix_ = None
        self.Temperature = Temperature
        self.Temperature_nsprefix_ = None
        self.References = References
        self.References_nsprefix_ = None
        self.GrowthConditionsMeasurementsOrFacts = GrowthConditionsMeasurementsOrFacts
        self.GrowthConditionsMeasurementsOrFacts_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GrowthConditionAtomized)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GrowthConditionAtomized.subclass:
            return GrowthConditionAtomized.subclass(*args_, **kwargs_)
        else:
            return GrowthConditionAtomized(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CultureMedium(self):
        return self.CultureMedium
    def set_CultureMedium(self, CultureMedium):
        self.CultureMedium = CultureMedium
    def get_Aerobicity(self):
        return self.Aerobicity
    def set_Aerobicity(self, Aerobicity):
        self.Aerobicity = Aerobicity
    def get_Temperature(self):
        return self.Temperature
    def set_Temperature(self, Temperature):
        self.Temperature = Temperature
    def get_References(self):
        return self.References
    def set_References(self, References):
        self.References = References
    def get_GrowthConditionsMeasurementsOrFacts(self):
        return self.GrowthConditionsMeasurementsOrFacts
    def set_GrowthConditionsMeasurementsOrFacts(self, GrowthConditionsMeasurementsOrFacts):
        self.GrowthConditionsMeasurementsOrFacts = GrowthConditionsMeasurementsOrFacts
    def hasContent_(self):
        if (
            self.CultureMedium is not None or
            self.Aerobicity is not None or
            self.Temperature is not None or
            self.References is not None or
            self.GrowthConditionsMeasurementsOrFacts is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='GrowthConditionAtomized', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GrowthConditionAtomized')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GrowthConditionAtomized')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GrowthConditionAtomized', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='GrowthConditionAtomized'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='GrowthConditionAtomized', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CultureMedium is not None:
            namespaceprefix_ = self.CultureMedium_nsprefix_ + ':' if (UseCapturedNS_ and self.CultureMedium_nsprefix_) else ''
            self.CultureMedium.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CultureMedium', pretty_print=pretty_print)
        if self.Aerobicity is not None:
            namespaceprefix_ = self.Aerobicity_nsprefix_ + ':' if (UseCapturedNS_ and self.Aerobicity_nsprefix_) else ''
            self.Aerobicity.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Aerobicity', pretty_print=pretty_print)
        if self.Temperature is not None:
            namespaceprefix_ = self.Temperature_nsprefix_ + ':' if (UseCapturedNS_ and self.Temperature_nsprefix_) else ''
            self.Temperature.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Temperature', pretty_print=pretty_print)
        if self.References is not None:
            namespaceprefix_ = self.References_nsprefix_ + ':' if (UseCapturedNS_ and self.References_nsprefix_) else ''
            self.References.export(outfile, level, namespaceprefix_, namespacedef_='', name_='References', pretty_print=pretty_print)
        if self.GrowthConditionsMeasurementsOrFacts is not None:
            namespaceprefix_ = self.GrowthConditionsMeasurementsOrFacts_nsprefix_ + ':' if (UseCapturedNS_ and self.GrowthConditionsMeasurementsOrFacts_nsprefix_) else ''
            self.GrowthConditionsMeasurementsOrFacts.export(outfile, level, namespaceprefix_, namespacedef_='', name_='GrowthConditionsMeasurementsOrFacts', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CultureMedium':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CultureMedium = obj_
            obj_.original_tagname_ = 'CultureMedium'
        elif nodeName_ == 'Aerobicity':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Aerobicity = obj_
            obj_.original_tagname_ = 'Aerobicity'
        elif nodeName_ == 'Temperature':
            obj_ = Temperature.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Temperature = obj_
            obj_.original_tagname_ = 'Temperature'
        elif nodeName_ == 'References':
            obj_ = ReferencesType13.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.References = obj_
            obj_.original_tagname_ = 'References'
        elif nodeName_ == 'GrowthConditionsMeasurementsOrFacts':
            obj_ = GrowthConditionsMeasurementsOrFactsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.GrowthConditionsMeasurementsOrFacts = obj_
            obj_.original_tagname_ = 'GrowthConditionsMeasurementsOrFacts'
# end class GrowthConditionAtomized


class HerbariumUnit(GeneratedsSuper):
    """Elements only used for herbarium units"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('Exsiccatum', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'Exsiccatum', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/exsiccatum', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('LoanID', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'LoanID', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/loanID', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('LoanSequenceNumber', 'xs:integer', 0, 1, {'minOccurs': '0', 'name': 'LoanSequenceNumber', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/loanSequenceNumber', 'type': 'xs:integer'}, None),
        MemberSpec_('LoanDestination', ['InstitutionCode', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'LoanDestination', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/loanDestination', 'type': 'xs:string'}, None),
        MemberSpec_('LoanForBotanist', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'LoanForBotanist', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/loanForBotanist', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('LoanDispatchMethod', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'LoanDispatchMethod', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/loanDispatchMethod', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('LoanDate', 'xs:date', 0, 1, {'minOccurs': '0', 'name': 'LoanDate', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/LoanDate', 'type': 'xs:date'}, None),
        MemberSpec_('LoanReturnDate', 'xs:date', 0, 1, {'minOccurs': '0', 'name': 'LoanReturnDate', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/LoanReturnDate', 'type': 'xs:date'}, None),
        MemberSpec_('NaturalOccurrence', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'NaturalOccurrence', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/naturalOccurrence', 'type': 'StringL'}, None),
        MemberSpec_('CultivatedOccurrence', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'CultivatedOccurrence', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/cultivatedOccurrence', 'type': 'StringL'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, Exsiccatum=None, LoanID=None, LoanSequenceNumber=None, LoanDestination=None, LoanForBotanist=None, LoanDispatchMethod=None, LoanDate=None, LoanReturnDate=None, NaturalOccurrence=None, CultivatedOccurrence=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Exsiccatum = Exsiccatum
        self.validate_String(self.Exsiccatum)
        self.Exsiccatum_nsprefix_ = None
        self.LoanID = LoanID
        self.validate_String(self.LoanID)
        self.LoanID_nsprefix_ = None
        self.LoanSequenceNumber = LoanSequenceNumber
        self.LoanSequenceNumber_nsprefix_ = None
        self.LoanDestination = LoanDestination
        self.validate_InstitutionCode(self.LoanDestination)
        self.LoanDestination_nsprefix_ = None
        self.LoanForBotanist = LoanForBotanist
        self.validate_String(self.LoanForBotanist)
        self.LoanForBotanist_nsprefix_ = None
        self.LoanDispatchMethod = LoanDispatchMethod
        self.validate_String(self.LoanDispatchMethod)
        self.LoanDispatchMethod_nsprefix_ = None
        if isinstance(LoanDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(LoanDate, '%Y-%m-%d').date()
        else:
            initvalue_ = LoanDate
        self.LoanDate = initvalue_
        self.LoanDate_nsprefix_ = None
        if isinstance(LoanReturnDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(LoanReturnDate, '%Y-%m-%d').date()
        else:
            initvalue_ = LoanReturnDate
        self.LoanReturnDate = initvalue_
        self.LoanReturnDate_nsprefix_ = None
        self.NaturalOccurrence = NaturalOccurrence
        self.NaturalOccurrence_nsprefix_ = None
        self.CultivatedOccurrence = CultivatedOccurrence
        self.CultivatedOccurrence_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HerbariumUnit)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HerbariumUnit.subclass:
            return HerbariumUnit.subclass(*args_, **kwargs_)
        else:
            return HerbariumUnit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Exsiccatum(self):
        return self.Exsiccatum
    def set_Exsiccatum(self, Exsiccatum):
        self.Exsiccatum = Exsiccatum
    def get_LoanID(self):
        return self.LoanID
    def set_LoanID(self, LoanID):
        self.LoanID = LoanID
    def get_LoanSequenceNumber(self):
        return self.LoanSequenceNumber
    def set_LoanSequenceNumber(self, LoanSequenceNumber):
        self.LoanSequenceNumber = LoanSequenceNumber
    def get_LoanDestination(self):
        return self.LoanDestination
    def set_LoanDestination(self, LoanDestination):
        self.LoanDestination = LoanDestination
    def get_LoanForBotanist(self):
        return self.LoanForBotanist
    def set_LoanForBotanist(self, LoanForBotanist):
        self.LoanForBotanist = LoanForBotanist
    def get_LoanDispatchMethod(self):
        return self.LoanDispatchMethod
    def set_LoanDispatchMethod(self, LoanDispatchMethod):
        self.LoanDispatchMethod = LoanDispatchMethod
    def get_LoanDate(self):
        return self.LoanDate
    def set_LoanDate(self, LoanDate):
        self.LoanDate = LoanDate
    def get_LoanReturnDate(self):
        return self.LoanReturnDate
    def set_LoanReturnDate(self, LoanReturnDate):
        self.LoanReturnDate = LoanReturnDate
    def get_NaturalOccurrence(self):
        return self.NaturalOccurrence
    def set_NaturalOccurrence(self, NaturalOccurrence):
        self.NaturalOccurrence = NaturalOccurrence
    def get_CultivatedOccurrence(self):
        return self.CultivatedOccurrence
    def set_CultivatedOccurrence(self, CultivatedOccurrence):
        self.CultivatedOccurrence = CultivatedOccurrence
    def validate_String(self, value):
        result = True
        # Validate type String, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on String' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_InstitutionCode(self, value):
        result = True
        # Validate type InstitutionCode, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def hasContent_(self):
        if (
            self.Exsiccatum is not None or
            self.LoanID is not None or
            self.LoanSequenceNumber is not None or
            self.LoanDestination is not None or
            self.LoanForBotanist is not None or
            self.LoanDispatchMethod is not None or
            self.LoanDate is not None or
            self.LoanReturnDate is not None or
            self.NaturalOccurrence is not None or
            self.CultivatedOccurrence is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='HerbariumUnit', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HerbariumUnit')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HerbariumUnit')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='HerbariumUnit', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='HerbariumUnit'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='HerbariumUnit', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Exsiccatum is not None:
            namespaceprefix_ = self.Exsiccatum_nsprefix_ + ':' if (UseCapturedNS_ and self.Exsiccatum_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sExsiccatum>%s</%sExsiccatum>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Exsiccatum), input_name='Exsiccatum')), namespaceprefix_ , eol_))
        if self.LoanID is not None:
            namespaceprefix_ = self.LoanID_nsprefix_ + ':' if (UseCapturedNS_ and self.LoanID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLoanID>%s</%sLoanID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.LoanID), input_name='LoanID')), namespaceprefix_ , eol_))
        if self.LoanSequenceNumber is not None:
            namespaceprefix_ = self.LoanSequenceNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.LoanSequenceNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLoanSequenceNumber>%s</%sLoanSequenceNumber>%s' % (namespaceprefix_ , self.gds_format_integer(self.LoanSequenceNumber, input_name='LoanSequenceNumber'), namespaceprefix_ , eol_))
        if self.LoanDestination is not None:
            namespaceprefix_ = self.LoanDestination_nsprefix_ + ':' if (UseCapturedNS_ and self.LoanDestination_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLoanDestination>%s</%sLoanDestination>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.LoanDestination), input_name='LoanDestination')), namespaceprefix_ , eol_))
        if self.LoanForBotanist is not None:
            namespaceprefix_ = self.LoanForBotanist_nsprefix_ + ':' if (UseCapturedNS_ and self.LoanForBotanist_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLoanForBotanist>%s</%sLoanForBotanist>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.LoanForBotanist), input_name='LoanForBotanist')), namespaceprefix_ , eol_))
        if self.LoanDispatchMethod is not None:
            namespaceprefix_ = self.LoanDispatchMethod_nsprefix_ + ':' if (UseCapturedNS_ and self.LoanDispatchMethod_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLoanDispatchMethod>%s</%sLoanDispatchMethod>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.LoanDispatchMethod), input_name='LoanDispatchMethod')), namespaceprefix_ , eol_))
        if self.LoanDate is not None:
            namespaceprefix_ = self.LoanDate_nsprefix_ + ':' if (UseCapturedNS_ and self.LoanDate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLoanDate>%s</%sLoanDate>%s' % (namespaceprefix_ , self.gds_format_date(self.LoanDate, input_name='LoanDate'), namespaceprefix_ , eol_))
        if self.LoanReturnDate is not None:
            namespaceprefix_ = self.LoanReturnDate_nsprefix_ + ':' if (UseCapturedNS_ and self.LoanReturnDate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLoanReturnDate>%s</%sLoanReturnDate>%s' % (namespaceprefix_ , self.gds_format_date(self.LoanReturnDate, input_name='LoanReturnDate'), namespaceprefix_ , eol_))
        if self.NaturalOccurrence is not None:
            namespaceprefix_ = self.NaturalOccurrence_nsprefix_ + ':' if (UseCapturedNS_ and self.NaturalOccurrence_nsprefix_) else ''
            self.NaturalOccurrence.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NaturalOccurrence', pretty_print=pretty_print)
        if self.CultivatedOccurrence is not None:
            namespaceprefix_ = self.CultivatedOccurrence_nsprefix_ + ':' if (UseCapturedNS_ and self.CultivatedOccurrence_nsprefix_) else ''
            self.CultivatedOccurrence.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CultivatedOccurrence', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Exsiccatum':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Exsiccatum')
            value_ = self.gds_validate_string(value_, node, 'Exsiccatum')
            self.Exsiccatum = value_
            self.Exsiccatum_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.Exsiccatum)
        elif nodeName_ == 'LoanID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'LoanID')
            value_ = self.gds_validate_string(value_, node, 'LoanID')
            self.LoanID = value_
            self.LoanID_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.LoanID)
        elif nodeName_ == 'LoanSequenceNumber' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'LoanSequenceNumber')
            ival_ = self.gds_validate_integer(ival_, node, 'LoanSequenceNumber')
            self.LoanSequenceNumber = ival_
            self.LoanSequenceNumber_nsprefix_ = child_.prefix
        elif nodeName_ == 'LoanDestination':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'LoanDestination')
            value_ = self.gds_validate_string(value_, node, 'LoanDestination')
            self.LoanDestination = value_
            self.LoanDestination_nsprefix_ = child_.prefix
            # validate type InstitutionCode
            self.validate_InstitutionCode(self.LoanDestination)
        elif nodeName_ == 'LoanForBotanist':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'LoanForBotanist')
            value_ = self.gds_validate_string(value_, node, 'LoanForBotanist')
            self.LoanForBotanist = value_
            self.LoanForBotanist_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.LoanForBotanist)
        elif nodeName_ == 'LoanDispatchMethod':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'LoanDispatchMethod')
            value_ = self.gds_validate_string(value_, node, 'LoanDispatchMethod')
            self.LoanDispatchMethod = value_
            self.LoanDispatchMethod_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.LoanDispatchMethod)
        elif nodeName_ == 'LoanDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.LoanDate = dval_
            self.LoanDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'LoanReturnDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.LoanReturnDate = dval_
            self.LoanReturnDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'NaturalOccurrence':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NaturalOccurrence = obj_
            obj_.original_tagname_ = 'NaturalOccurrence'
        elif nodeName_ == 'CultivatedOccurrence':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CultivatedOccurrence = obj_
            obj_.original_tagname_ = 'CultivatedOccurrence'
# end class HerbariumUnit


class MycologicalUnit(GeneratedsSuper):
    """Elements only used for mycological units"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('LichenMorphotype', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'LichenMorphotype', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/lichenMorphotype', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('MycologicalSexualStage', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'MycologicalSexualStage', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/mycologicalSexualStage', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('MycologicalLiveStages', 'MycologicalLiveStagesType', 0, 1, {'minOccurs': '0', 'name': 'MycologicalLiveStages', 'type': 'MycologicalLiveStagesType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, LichenMorphotype=None, MycologicalSexualStage=None, MycologicalLiveStages=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.LichenMorphotype = LichenMorphotype
        self.validate_String(self.LichenMorphotype)
        self.LichenMorphotype_nsprefix_ = None
        self.MycologicalSexualStage = MycologicalSexualStage
        self.validate_String(self.MycologicalSexualStage)
        self.MycologicalSexualStage_nsprefix_ = None
        self.MycologicalLiveStages = MycologicalLiveStages
        self.MycologicalLiveStages_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MycologicalUnit)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MycologicalUnit.subclass:
            return MycologicalUnit.subclass(*args_, **kwargs_)
        else:
            return MycologicalUnit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_LichenMorphotype(self):
        return self.LichenMorphotype
    def set_LichenMorphotype(self, LichenMorphotype):
        self.LichenMorphotype = LichenMorphotype
    def get_MycologicalSexualStage(self):
        return self.MycologicalSexualStage
    def set_MycologicalSexualStage(self, MycologicalSexualStage):
        self.MycologicalSexualStage = MycologicalSexualStage
    def get_MycologicalLiveStages(self):
        return self.MycologicalLiveStages
    def set_MycologicalLiveStages(self, MycologicalLiveStages):
        self.MycologicalLiveStages = MycologicalLiveStages
    def validate_String(self, value):
        result = True
        # Validate type String, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on String' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.LichenMorphotype is not None or
            self.MycologicalSexualStage is not None or
            self.MycologicalLiveStages is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='MycologicalUnit', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MycologicalUnit')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MycologicalUnit')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MycologicalUnit', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MycologicalUnit'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='MycologicalUnit', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LichenMorphotype is not None:
            namespaceprefix_ = self.LichenMorphotype_nsprefix_ + ':' if (UseCapturedNS_ and self.LichenMorphotype_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLichenMorphotype>%s</%sLichenMorphotype>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.LichenMorphotype), input_name='LichenMorphotype')), namespaceprefix_ , eol_))
        if self.MycologicalSexualStage is not None:
            namespaceprefix_ = self.MycologicalSexualStage_nsprefix_ + ':' if (UseCapturedNS_ and self.MycologicalSexualStage_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMycologicalSexualStage>%s</%sMycologicalSexualStage>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.MycologicalSexualStage), input_name='MycologicalSexualStage')), namespaceprefix_ , eol_))
        if self.MycologicalLiveStages is not None:
            namespaceprefix_ = self.MycologicalLiveStages_nsprefix_ + ':' if (UseCapturedNS_ and self.MycologicalLiveStages_nsprefix_) else ''
            self.MycologicalLiveStages.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MycologicalLiveStages', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'LichenMorphotype':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'LichenMorphotype')
            value_ = self.gds_validate_string(value_, node, 'LichenMorphotype')
            self.LichenMorphotype = value_
            self.LichenMorphotype_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.LichenMorphotype)
        elif nodeName_ == 'MycologicalSexualStage':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'MycologicalSexualStage')
            value_ = self.gds_validate_string(value_, node, 'MycologicalSexualStage')
            self.MycologicalSexualStage = value_
            self.MycologicalSexualStage_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.MycologicalSexualStage)
        elif nodeName_ == 'MycologicalLiveStages':
            obj_ = MycologicalLiveStagesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MycologicalLiveStages = obj_
            obj_.original_tagname_ = 'MycologicalLiveStages'
# end class MycologicalUnit


class PGRUnit(GeneratedsSuper):
    """Extension for elements only used in plant genetic resource collections.
    Currently, all elements represent EURISCO descriptors."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('NationalInventoryCode', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'NationalInventoryCode', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/nationalInventoryCode', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('BreedingCountryCode', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'BreedingCountryCode', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/breedingCountryCode', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('BreedingInstitutionCode', ['FAOInstituteCode', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'BreedingInstitutionCode', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/breedingInstitutionCode', 'type': 'xs:string'}, None),
        MemberSpec_('DecodedBreedingInstitute', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'DecodedBreedingInstitute', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/decodedBreedingInstitute', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('GatheringInstitutionCode', ['FAOInstituteCode', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'GatheringInstitutionCode', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/gatheringInstitutionCode', 'type': 'xs:string'}, None),
        MemberSpec_('DecodedGatheringInstitute', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'DecodedGatheringInstitute', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/decodedGatheringInstitute', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('BiologicalStatus', ['BiologicalStatus', 'xs:integer'], 0, 1, {'minOccurs': '0', 'name': 'BiologicalStatus', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/biologicalStatus', 'type': 'xs:integer'}, None),
        MemberSpec_('AncestralData', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'AncestralData', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/ancestralData', 'type': 'StringL'}, None),
        MemberSpec_('CollectingAcquisitionSource', ['CollectingAcquisitionSource', 'xs:integer'], 0, 1, {'minOccurs': '0', 'name': 'CollectingAcquisitionSource', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/collectingAcquisitionSource', 'type': 'xs:integer'}, None),
        MemberSpec_('OtherIdentification', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'OtherIdentification', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/otherIdentification', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('LocationSafetyDuplicates', ['FAOInstituteCode', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'LocationSafetyDuplicates', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/locationSafetyDuplicates', 'type': 'xs:string'}, None),
        MemberSpec_('DecodedLocationSafetyDuplicates', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'DecodedLocationSafetyDuplicates', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/decodedLocationSafetyDuplicates', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('TypeGermplasmStorage', ['TypeGermplasmStorage', 'xs:integer'], 0, 1, {'minOccurs': '0', 'name': 'TypeGermplasmStorage', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/typeGermplasmStorage', 'type': 'xs:integer'}, None),
        MemberSpec_('AccessionNames', 'AccessionNamesType', 0, 1, {'minOccurs': '0', 'name': 'AccessionNames', 'type': 'AccessionNamesType'}, None),
        MemberSpec_('AccessionNameText', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'AccessionNameText', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/accessionNameText', 'type': 'xs:normalizedString'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, NationalInventoryCode=None, BreedingCountryCode=None, BreedingInstitutionCode=None, DecodedBreedingInstitute=None, GatheringInstitutionCode=None, DecodedGatheringInstitute=None, BiologicalStatus=None, AncestralData=None, CollectingAcquisitionSource=None, OtherIdentification=None, LocationSafetyDuplicates=None, DecodedLocationSafetyDuplicates=None, TypeGermplasmStorage=None, AccessionNames=None, AccessionNameText=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.NationalInventoryCode = NationalInventoryCode
        self.validate_String(self.NationalInventoryCode)
        self.NationalInventoryCode_nsprefix_ = None
        self.BreedingCountryCode = BreedingCountryCode
        self.validate_String(self.BreedingCountryCode)
        self.BreedingCountryCode_nsprefix_ = None
        self.BreedingInstitutionCode = BreedingInstitutionCode
        self.validate_FAOInstituteCode(self.BreedingInstitutionCode)
        self.BreedingInstitutionCode_nsprefix_ = None
        self.DecodedBreedingInstitute = DecodedBreedingInstitute
        self.validate_String(self.DecodedBreedingInstitute)
        self.DecodedBreedingInstitute_nsprefix_ = None
        self.GatheringInstitutionCode = GatheringInstitutionCode
        self.validate_FAOInstituteCode(self.GatheringInstitutionCode)
        self.GatheringInstitutionCode_nsprefix_ = None
        self.DecodedGatheringInstitute = DecodedGatheringInstitute
        self.validate_String(self.DecodedGatheringInstitute)
        self.DecodedGatheringInstitute_nsprefix_ = None
        self.BiologicalStatus = BiologicalStatus
        self.validate_BiologicalStatus(self.BiologicalStatus)
        self.BiologicalStatus_nsprefix_ = None
        self.AncestralData = AncestralData
        self.AncestralData_nsprefix_ = None
        self.CollectingAcquisitionSource = CollectingAcquisitionSource
        self.validate_CollectingAcquisitionSource(self.CollectingAcquisitionSource)
        self.CollectingAcquisitionSource_nsprefix_ = None
        self.OtherIdentification = OtherIdentification
        self.validate_String(self.OtherIdentification)
        self.OtherIdentification_nsprefix_ = None
        self.LocationSafetyDuplicates = LocationSafetyDuplicates
        self.validate_FAOInstituteCode(self.LocationSafetyDuplicates)
        self.LocationSafetyDuplicates_nsprefix_ = None
        self.DecodedLocationSafetyDuplicates = DecodedLocationSafetyDuplicates
        self.validate_String(self.DecodedLocationSafetyDuplicates)
        self.DecodedLocationSafetyDuplicates_nsprefix_ = None
        self.TypeGermplasmStorage = TypeGermplasmStorage
        self.validate_TypeGermplasmStorage(self.TypeGermplasmStorage)
        self.TypeGermplasmStorage_nsprefix_ = None
        self.AccessionNames = AccessionNames
        self.AccessionNames_nsprefix_ = None
        self.AccessionNameText = AccessionNameText
        self.validate_String(self.AccessionNameText)
        self.AccessionNameText_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PGRUnit)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PGRUnit.subclass:
            return PGRUnit.subclass(*args_, **kwargs_)
        else:
            return PGRUnit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_NationalInventoryCode(self):
        return self.NationalInventoryCode
    def set_NationalInventoryCode(self, NationalInventoryCode):
        self.NationalInventoryCode = NationalInventoryCode
    def get_BreedingCountryCode(self):
        return self.BreedingCountryCode
    def set_BreedingCountryCode(self, BreedingCountryCode):
        self.BreedingCountryCode = BreedingCountryCode
    def get_BreedingInstitutionCode(self):
        return self.BreedingInstitutionCode
    def set_BreedingInstitutionCode(self, BreedingInstitutionCode):
        self.BreedingInstitutionCode = BreedingInstitutionCode
    def get_DecodedBreedingInstitute(self):
        return self.DecodedBreedingInstitute
    def set_DecodedBreedingInstitute(self, DecodedBreedingInstitute):
        self.DecodedBreedingInstitute = DecodedBreedingInstitute
    def get_GatheringInstitutionCode(self):
        return self.GatheringInstitutionCode
    def set_GatheringInstitutionCode(self, GatheringInstitutionCode):
        self.GatheringInstitutionCode = GatheringInstitutionCode
    def get_DecodedGatheringInstitute(self):
        return self.DecodedGatheringInstitute
    def set_DecodedGatheringInstitute(self, DecodedGatheringInstitute):
        self.DecodedGatheringInstitute = DecodedGatheringInstitute
    def get_BiologicalStatus(self):
        return self.BiologicalStatus
    def set_BiologicalStatus(self, BiologicalStatus):
        self.BiologicalStatus = BiologicalStatus
    def get_AncestralData(self):
        return self.AncestralData
    def set_AncestralData(self, AncestralData):
        self.AncestralData = AncestralData
    def get_CollectingAcquisitionSource(self):
        return self.CollectingAcquisitionSource
    def set_CollectingAcquisitionSource(self, CollectingAcquisitionSource):
        self.CollectingAcquisitionSource = CollectingAcquisitionSource
    def get_OtherIdentification(self):
        return self.OtherIdentification
    def set_OtherIdentification(self, OtherIdentification):
        self.OtherIdentification = OtherIdentification
    def get_LocationSafetyDuplicates(self):
        return self.LocationSafetyDuplicates
    def set_LocationSafetyDuplicates(self, LocationSafetyDuplicates):
        self.LocationSafetyDuplicates = LocationSafetyDuplicates
    def get_DecodedLocationSafetyDuplicates(self):
        return self.DecodedLocationSafetyDuplicates
    def set_DecodedLocationSafetyDuplicates(self, DecodedLocationSafetyDuplicates):
        self.DecodedLocationSafetyDuplicates = DecodedLocationSafetyDuplicates
    def get_TypeGermplasmStorage(self):
        return self.TypeGermplasmStorage
    def set_TypeGermplasmStorage(self, TypeGermplasmStorage):
        self.TypeGermplasmStorage = TypeGermplasmStorage
    def get_AccessionNames(self):
        return self.AccessionNames
    def set_AccessionNames(self, AccessionNames):
        self.AccessionNames = AccessionNames
    def get_AccessionNameText(self):
        return self.AccessionNameText
    def set_AccessionNameText(self, AccessionNameText):
        self.AccessionNameText = AccessionNameText
    def validate_String(self, value):
        result = True
        # Validate type String, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on String' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_FAOInstituteCode(self, value):
        result = True
        # Validate type FAOInstituteCode, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_BiologicalStatus(self, value):
        result = True
        # Validate type BiologicalStatus, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = [100, 110, 120, 200, 300, 400, 410, 411, 412, 413, 414, 415, 420, 500, 999]
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on BiologicalStatus' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_CollectingAcquisitionSource(self, value):
        result = True
        # Validate type CollectingAcquisitionSource, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = [10, 11, 12, 13, 14, 15, 20, 21, 22, 23, 24, 25, 26, 27, 28, 30, 40, 50, 60, 61, 62, 99]
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on CollectingAcquisitionSource' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_TypeGermplasmStorage(self, value):
        result = True
        # Validate type TypeGermplasmStorage, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = [10, 11, 12, 13, 20, 30, 40, 99]
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TypeGermplasmStorage' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.NationalInventoryCode is not None or
            self.BreedingCountryCode is not None or
            self.BreedingInstitutionCode is not None or
            self.DecodedBreedingInstitute is not None or
            self.GatheringInstitutionCode is not None or
            self.DecodedGatheringInstitute is not None or
            self.BiologicalStatus is not None or
            self.AncestralData is not None or
            self.CollectingAcquisitionSource is not None or
            self.OtherIdentification is not None or
            self.LocationSafetyDuplicates is not None or
            self.DecodedLocationSafetyDuplicates is not None or
            self.TypeGermplasmStorage is not None or
            self.AccessionNames is not None or
            self.AccessionNameText is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='PGRUnit', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PGRUnit')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PGRUnit')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PGRUnit', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PGRUnit'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='PGRUnit', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.NationalInventoryCode is not None:
            namespaceprefix_ = self.NationalInventoryCode_nsprefix_ + ':' if (UseCapturedNS_ and self.NationalInventoryCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNationalInventoryCode>%s</%sNationalInventoryCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NationalInventoryCode), input_name='NationalInventoryCode')), namespaceprefix_ , eol_))
        if self.BreedingCountryCode is not None:
            namespaceprefix_ = self.BreedingCountryCode_nsprefix_ + ':' if (UseCapturedNS_ and self.BreedingCountryCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBreedingCountryCode>%s</%sBreedingCountryCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.BreedingCountryCode), input_name='BreedingCountryCode')), namespaceprefix_ , eol_))
        if self.BreedingInstitutionCode is not None:
            namespaceprefix_ = self.BreedingInstitutionCode_nsprefix_ + ':' if (UseCapturedNS_ and self.BreedingInstitutionCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBreedingInstitutionCode>%s</%sBreedingInstitutionCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.BreedingInstitutionCode), input_name='BreedingInstitutionCode')), namespaceprefix_ , eol_))
        if self.DecodedBreedingInstitute is not None:
            namespaceprefix_ = self.DecodedBreedingInstitute_nsprefix_ + ':' if (UseCapturedNS_ and self.DecodedBreedingInstitute_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDecodedBreedingInstitute>%s</%sDecodedBreedingInstitute>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DecodedBreedingInstitute), input_name='DecodedBreedingInstitute')), namespaceprefix_ , eol_))
        if self.GatheringInstitutionCode is not None:
            namespaceprefix_ = self.GatheringInstitutionCode_nsprefix_ + ':' if (UseCapturedNS_ and self.GatheringInstitutionCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGatheringInstitutionCode>%s</%sGatheringInstitutionCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.GatheringInstitutionCode), input_name='GatheringInstitutionCode')), namespaceprefix_ , eol_))
        if self.DecodedGatheringInstitute is not None:
            namespaceprefix_ = self.DecodedGatheringInstitute_nsprefix_ + ':' if (UseCapturedNS_ and self.DecodedGatheringInstitute_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDecodedGatheringInstitute>%s</%sDecodedGatheringInstitute>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DecodedGatheringInstitute), input_name='DecodedGatheringInstitute')), namespaceprefix_ , eol_))
        if self.BiologicalStatus is not None:
            namespaceprefix_ = self.BiologicalStatus_nsprefix_ + ':' if (UseCapturedNS_ and self.BiologicalStatus_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBiologicalStatus>%s</%sBiologicalStatus>%s' % (namespaceprefix_ , self.gds_format_integer(self.BiologicalStatus, input_name='BiologicalStatus'), namespaceprefix_ , eol_))
        if self.AncestralData is not None:
            namespaceprefix_ = self.AncestralData_nsprefix_ + ':' if (UseCapturedNS_ and self.AncestralData_nsprefix_) else ''
            self.AncestralData.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AncestralData', pretty_print=pretty_print)
        if self.CollectingAcquisitionSource is not None:
            namespaceprefix_ = self.CollectingAcquisitionSource_nsprefix_ + ':' if (UseCapturedNS_ and self.CollectingAcquisitionSource_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCollectingAcquisitionSource>%s</%sCollectingAcquisitionSource>%s' % (namespaceprefix_ , self.gds_format_integer(self.CollectingAcquisitionSource, input_name='CollectingAcquisitionSource'), namespaceprefix_ , eol_))
        if self.OtherIdentification is not None:
            namespaceprefix_ = self.OtherIdentification_nsprefix_ + ':' if (UseCapturedNS_ and self.OtherIdentification_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOtherIdentification>%s</%sOtherIdentification>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.OtherIdentification), input_name='OtherIdentification')), namespaceprefix_ , eol_))
        if self.LocationSafetyDuplicates is not None:
            namespaceprefix_ = self.LocationSafetyDuplicates_nsprefix_ + ':' if (UseCapturedNS_ and self.LocationSafetyDuplicates_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLocationSafetyDuplicates>%s</%sLocationSafetyDuplicates>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.LocationSafetyDuplicates), input_name='LocationSafetyDuplicates')), namespaceprefix_ , eol_))
        if self.DecodedLocationSafetyDuplicates is not None:
            namespaceprefix_ = self.DecodedLocationSafetyDuplicates_nsprefix_ + ':' if (UseCapturedNS_ and self.DecodedLocationSafetyDuplicates_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDecodedLocationSafetyDuplicates>%s</%sDecodedLocationSafetyDuplicates>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DecodedLocationSafetyDuplicates), input_name='DecodedLocationSafetyDuplicates')), namespaceprefix_ , eol_))
        if self.TypeGermplasmStorage is not None:
            namespaceprefix_ = self.TypeGermplasmStorage_nsprefix_ + ':' if (UseCapturedNS_ and self.TypeGermplasmStorage_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTypeGermplasmStorage>%s</%sTypeGermplasmStorage>%s' % (namespaceprefix_ , self.gds_format_integer(self.TypeGermplasmStorage, input_name='TypeGermplasmStorage'), namespaceprefix_ , eol_))
        if self.AccessionNames is not None:
            namespaceprefix_ = self.AccessionNames_nsprefix_ + ':' if (UseCapturedNS_ and self.AccessionNames_nsprefix_) else ''
            self.AccessionNames.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AccessionNames', pretty_print=pretty_print)
        if self.AccessionNameText is not None:
            namespaceprefix_ = self.AccessionNameText_nsprefix_ + ':' if (UseCapturedNS_ and self.AccessionNameText_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAccessionNameText>%s</%sAccessionNameText>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.AccessionNameText), input_name='AccessionNameText')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'NationalInventoryCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NationalInventoryCode')
            value_ = self.gds_validate_string(value_, node, 'NationalInventoryCode')
            self.NationalInventoryCode = value_
            self.NationalInventoryCode_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.NationalInventoryCode)
        elif nodeName_ == 'BreedingCountryCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'BreedingCountryCode')
            value_ = self.gds_validate_string(value_, node, 'BreedingCountryCode')
            self.BreedingCountryCode = value_
            self.BreedingCountryCode_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.BreedingCountryCode)
        elif nodeName_ == 'BreedingInstitutionCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'BreedingInstitutionCode')
            value_ = self.gds_validate_string(value_, node, 'BreedingInstitutionCode')
            self.BreedingInstitutionCode = value_
            self.BreedingInstitutionCode_nsprefix_ = child_.prefix
            # validate type FAOInstituteCode
            self.validate_FAOInstituteCode(self.BreedingInstitutionCode)
        elif nodeName_ == 'DecodedBreedingInstitute':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DecodedBreedingInstitute')
            value_ = self.gds_validate_string(value_, node, 'DecodedBreedingInstitute')
            self.DecodedBreedingInstitute = value_
            self.DecodedBreedingInstitute_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.DecodedBreedingInstitute)
        elif nodeName_ == 'GatheringInstitutionCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'GatheringInstitutionCode')
            value_ = self.gds_validate_string(value_, node, 'GatheringInstitutionCode')
            self.GatheringInstitutionCode = value_
            self.GatheringInstitutionCode_nsprefix_ = child_.prefix
            # validate type FAOInstituteCode
            self.validate_FAOInstituteCode(self.GatheringInstitutionCode)
        elif nodeName_ == 'DecodedGatheringInstitute':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DecodedGatheringInstitute')
            value_ = self.gds_validate_string(value_, node, 'DecodedGatheringInstitute')
            self.DecodedGatheringInstitute = value_
            self.DecodedGatheringInstitute_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.DecodedGatheringInstitute)
        elif nodeName_ == 'BiologicalStatus' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'BiologicalStatus')
            ival_ = self.gds_validate_integer(ival_, node, 'BiologicalStatus')
            self.BiologicalStatus = ival_
            self.BiologicalStatus_nsprefix_ = child_.prefix
            # validate type BiologicalStatus
            self.validate_BiologicalStatus(self.BiologicalStatus)
        elif nodeName_ == 'AncestralData':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AncestralData = obj_
            obj_.original_tagname_ = 'AncestralData'
        elif nodeName_ == 'CollectingAcquisitionSource' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'CollectingAcquisitionSource')
            ival_ = self.gds_validate_integer(ival_, node, 'CollectingAcquisitionSource')
            self.CollectingAcquisitionSource = ival_
            self.CollectingAcquisitionSource_nsprefix_ = child_.prefix
            # validate type CollectingAcquisitionSource
            self.validate_CollectingAcquisitionSource(self.CollectingAcquisitionSource)
        elif nodeName_ == 'OtherIdentification':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'OtherIdentification')
            value_ = self.gds_validate_string(value_, node, 'OtherIdentification')
            self.OtherIdentification = value_
            self.OtherIdentification_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.OtherIdentification)
        elif nodeName_ == 'LocationSafetyDuplicates':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'LocationSafetyDuplicates')
            value_ = self.gds_validate_string(value_, node, 'LocationSafetyDuplicates')
            self.LocationSafetyDuplicates = value_
            self.LocationSafetyDuplicates_nsprefix_ = child_.prefix
            # validate type FAOInstituteCode
            self.validate_FAOInstituteCode(self.LocationSafetyDuplicates)
        elif nodeName_ == 'DecodedLocationSafetyDuplicates':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DecodedLocationSafetyDuplicates')
            value_ = self.gds_validate_string(value_, node, 'DecodedLocationSafetyDuplicates')
            self.DecodedLocationSafetyDuplicates = value_
            self.DecodedLocationSafetyDuplicates_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.DecodedLocationSafetyDuplicates)
        elif nodeName_ == 'TypeGermplasmStorage' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'TypeGermplasmStorage')
            ival_ = self.gds_validate_integer(ival_, node, 'TypeGermplasmStorage')
            self.TypeGermplasmStorage = ival_
            self.TypeGermplasmStorage_nsprefix_ = child_.prefix
            # validate type TypeGermplasmStorage
            self.validate_TypeGermplasmStorage(self.TypeGermplasmStorage)
        elif nodeName_ == 'AccessionNames':
            obj_ = AccessionNamesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AccessionNames = obj_
            obj_.original_tagname_ = 'AccessionNames'
        elif nodeName_ == 'AccessionNameText':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'AccessionNameText')
            value_ = self.gds_validate_string(value_, node, 'AccessionNameText')
            self.AccessionNameText = value_
            self.AccessionNameText_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.AccessionNameText)
# end class PGRUnit


class PaleontologicalUnit(GeneratedsSuper):
    """Elements only used for paleontological units"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('Preservation', 'PreservationType14', 0, 1, {'minOccurs': '0', 'name': 'Preservation', 'type': 'PreservationType14'}, None),
        MemberSpec_('TimeRange', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'TimeRange', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/paleontologicalTimeRange', 'type': 'xs:normalizedString'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, Preservation=None, TimeRange=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Preservation = Preservation
        self.Preservation_nsprefix_ = None
        self.TimeRange = TimeRange
        self.validate_String(self.TimeRange)
        self.TimeRange_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PaleontologicalUnit)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PaleontologicalUnit.subclass:
            return PaleontologicalUnit.subclass(*args_, **kwargs_)
        else:
            return PaleontologicalUnit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Preservation(self):
        return self.Preservation
    def set_Preservation(self, Preservation):
        self.Preservation = Preservation
    def get_TimeRange(self):
        return self.TimeRange
    def set_TimeRange(self, TimeRange):
        self.TimeRange = TimeRange
    def validate_String(self, value):
        result = True
        # Validate type String, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on String' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.Preservation is not None or
            self.TimeRange is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='PaleontologicalUnit', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PaleontologicalUnit')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PaleontologicalUnit')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PaleontologicalUnit', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PaleontologicalUnit'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='PaleontologicalUnit', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Preservation is not None:
            namespaceprefix_ = self.Preservation_nsprefix_ + ':' if (UseCapturedNS_ and self.Preservation_nsprefix_) else ''
            self.Preservation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Preservation', pretty_print=pretty_print)
        if self.TimeRange is not None:
            namespaceprefix_ = self.TimeRange_nsprefix_ + ':' if (UseCapturedNS_ and self.TimeRange_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTimeRange>%s</%sTimeRange>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TimeRange), input_name='TimeRange')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Preservation':
            obj_ = PreservationType14.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Preservation = obj_
            obj_.original_tagname_ = 'Preservation'
        elif nodeName_ == 'TimeRange':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TimeRange')
            value_ = self.gds_validate_string(value_, node, 'TimeRange')
            self.TimeRange = value_
            self.TimeRange_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.TimeRange)
# end class PaleontologicalUnit


class Stratigraphy(GeneratedsSuper):
    """Elements expressing stratigraphy at the gathering site."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('ChronostratigraphicTerms', 'ChronostratigraphicTermsType', 0, 1, {'minOccurs': '0', 'name': 'ChronostratigraphicTerms', 'type': 'ChronostratigraphicTermsType'}, None),
        MemberSpec_('BiostratigraphicTerms', 'BiostratigraphicTermsType', 0, 1, {'minOccurs': '0', 'name': 'BiostratigraphicTerms', 'type': 'BiostratigraphicTermsType'}, None),
        MemberSpec_('LithostratigraphicTerms', 'LithostratigraphicTermsType', 0, 1, {'minOccurs': '0', 'name': 'LithostratigraphicTerms', 'type': 'LithostratigraphicTermsType'}, None),
        MemberSpec_('StratigraphyText', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'StratigraphyText', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/stratigraphy', 'type': 'StringL'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, ChronostratigraphicTerms=None, BiostratigraphicTerms=None, LithostratigraphicTerms=None, StratigraphyText=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ChronostratigraphicTerms = ChronostratigraphicTerms
        self.ChronostratigraphicTerms_nsprefix_ = None
        self.BiostratigraphicTerms = BiostratigraphicTerms
        self.BiostratigraphicTerms_nsprefix_ = None
        self.LithostratigraphicTerms = LithostratigraphicTerms
        self.LithostratigraphicTerms_nsprefix_ = None
        self.StratigraphyText = StratigraphyText
        self.StratigraphyText_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Stratigraphy)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Stratigraphy.subclass:
            return Stratigraphy.subclass(*args_, **kwargs_)
        else:
            return Stratigraphy(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ChronostratigraphicTerms(self):
        return self.ChronostratigraphicTerms
    def set_ChronostratigraphicTerms(self, ChronostratigraphicTerms):
        self.ChronostratigraphicTerms = ChronostratigraphicTerms
    def get_BiostratigraphicTerms(self):
        return self.BiostratigraphicTerms
    def set_BiostratigraphicTerms(self, BiostratigraphicTerms):
        self.BiostratigraphicTerms = BiostratigraphicTerms
    def get_LithostratigraphicTerms(self):
        return self.LithostratigraphicTerms
    def set_LithostratigraphicTerms(self, LithostratigraphicTerms):
        self.LithostratigraphicTerms = LithostratigraphicTerms
    def get_StratigraphyText(self):
        return self.StratigraphyText
    def set_StratigraphyText(self, StratigraphyText):
        self.StratigraphyText = StratigraphyText
    def hasContent_(self):
        if (
            self.ChronostratigraphicTerms is not None or
            self.BiostratigraphicTerms is not None or
            self.LithostratigraphicTerms is not None or
            self.StratigraphyText is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='Stratigraphy', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Stratigraphy')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Stratigraphy')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Stratigraphy', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Stratigraphy'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='Stratigraphy', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ChronostratigraphicTerms is not None:
            namespaceprefix_ = self.ChronostratigraphicTerms_nsprefix_ + ':' if (UseCapturedNS_ and self.ChronostratigraphicTerms_nsprefix_) else ''
            self.ChronostratigraphicTerms.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ChronostratigraphicTerms', pretty_print=pretty_print)
        if self.BiostratigraphicTerms is not None:
            namespaceprefix_ = self.BiostratigraphicTerms_nsprefix_ + ':' if (UseCapturedNS_ and self.BiostratigraphicTerms_nsprefix_) else ''
            self.BiostratigraphicTerms.export(outfile, level, namespaceprefix_, namespacedef_='', name_='BiostratigraphicTerms', pretty_print=pretty_print)
        if self.LithostratigraphicTerms is not None:
            namespaceprefix_ = self.LithostratigraphicTerms_nsprefix_ + ':' if (UseCapturedNS_ and self.LithostratigraphicTerms_nsprefix_) else ''
            self.LithostratigraphicTerms.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LithostratigraphicTerms', pretty_print=pretty_print)
        if self.StratigraphyText is not None:
            namespaceprefix_ = self.StratigraphyText_nsprefix_ + ':' if (UseCapturedNS_ and self.StratigraphyText_nsprefix_) else ''
            self.StratigraphyText.export(outfile, level, namespaceprefix_, namespacedef_='', name_='StratigraphyText', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ChronostratigraphicTerms':
            obj_ = ChronostratigraphicTermsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ChronostratigraphicTerms = obj_
            obj_.original_tagname_ = 'ChronostratigraphicTerms'
        elif nodeName_ == 'BiostratigraphicTerms':
            obj_ = BiostratigraphicTermsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BiostratigraphicTerms = obj_
            obj_.original_tagname_ = 'BiostratigraphicTerms'
        elif nodeName_ == 'LithostratigraphicTerms':
            obj_ = LithostratigraphicTermsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LithostratigraphicTerms = obj_
            obj_.original_tagname_ = 'LithostratigraphicTerms'
        elif nodeName_ == 'StratigraphyText':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.StratigraphyText = obj_
            obj_.original_tagname_ = 'StratigraphyText'
# end class Stratigraphy


class ZoologicalUnit(GeneratedsSuper):
    """Elements only used for zoological units"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('PhasesOrStages', 'PhasesOrStagesType', 0, 1, {'minOccurs': '0', 'name': 'PhasesOrStages', 'type': 'PhasesOrStagesType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, PhasesOrStages=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.PhasesOrStages = PhasesOrStages
        self.PhasesOrStages_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ZoologicalUnit)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ZoologicalUnit.subclass:
            return ZoologicalUnit.subclass(*args_, **kwargs_)
        else:
            return ZoologicalUnit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_PhasesOrStages(self):
        return self.PhasesOrStages
    def set_PhasesOrStages(self, PhasesOrStages):
        self.PhasesOrStages = PhasesOrStages
    def hasContent_(self):
        if (
            self.PhasesOrStages is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='ZoologicalUnit', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ZoologicalUnit')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ZoologicalUnit')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ZoologicalUnit', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ZoologicalUnit'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='ZoologicalUnit', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PhasesOrStages is not None:
            namespaceprefix_ = self.PhasesOrStages_nsprefix_ + ':' if (UseCapturedNS_ and self.PhasesOrStages_nsprefix_) else ''
            self.PhasesOrStages.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PhasesOrStages', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'PhasesOrStages':
            obj_ = PhasesOrStagesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PhasesOrStages = obj_
            obj_.original_tagname_ = 'PhasesOrStages'
# end class ZoologicalUnit


class Country(GeneratedsSuper):
    """Details of the country"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('Name', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'Name', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Country-Name', 'type': 'StringL'}, None),
        MemberSpec_('DerivedFlag', 'xs:boolean', 0, 1, {'default': 'false', 'minOccurs': '0', 'name': 'DerivedFlag', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/derivedFlag', 'type': 'xs:boolean'}, None),
        MemberSpec_('ISO3166Code', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'ISO3166Code', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/iso3166Code', 'type': 'xs:normalizedString'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, Name=None, DerivedFlag=False, ISO3166Code=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Name = Name
        self.Name_nsprefix_ = None
        self.DerivedFlag = DerivedFlag
        self.DerivedFlag_nsprefix_ = None
        self.ISO3166Code = ISO3166Code
        self.validate_String(self.ISO3166Code)
        self.ISO3166Code_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Country)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Country.subclass:
            return Country.subclass(*args_, **kwargs_)
        else:
            return Country(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Name(self):
        return self.Name
    def set_Name(self, Name):
        self.Name = Name
    def get_DerivedFlag(self):
        return self.DerivedFlag
    def set_DerivedFlag(self, DerivedFlag):
        self.DerivedFlag = DerivedFlag
    def get_ISO3166Code(self):
        return self.ISO3166Code
    def set_ISO3166Code(self, ISO3166Code):
        self.ISO3166Code = ISO3166Code
    def validate_String(self, value):
        result = True
        # Validate type String, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on String' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.Name is not None or
            self.DerivedFlag or
            self.ISO3166Code is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='Country', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Country')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Country')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Country', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Country'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='Country', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            namespaceprefix_ = self.Name_nsprefix_ + ':' if (UseCapturedNS_ and self.Name_nsprefix_) else ''
            self.Name.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Name', pretty_print=pretty_print)
        if self.DerivedFlag:
            namespaceprefix_ = self.DerivedFlag_nsprefix_ + ':' if (UseCapturedNS_ and self.DerivedFlag_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDerivedFlag>%s</%sDerivedFlag>%s' % (namespaceprefix_ , self.gds_format_boolean(self.DerivedFlag, input_name='DerivedFlag'), namespaceprefix_ , eol_))
        if self.ISO3166Code is not None:
            namespaceprefix_ = self.ISO3166Code_nsprefix_ + ':' if (UseCapturedNS_ and self.ISO3166Code_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sISO3166Code>%s</%sISO3166Code>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ISO3166Code), input_name='ISO3166Code')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Name':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Name = obj_
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'DerivedFlag':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'DerivedFlag')
            ival_ = self.gds_validate_boolean(ival_, node, 'DerivedFlag')
            self.DerivedFlag = ival_
            self.DerivedFlag_nsprefix_ = child_.prefix
        elif nodeName_ == 'ISO3166Code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ISO3166Code')
            value_ = self.gds_validate_string(value_, node, 'ISO3166Code')
            self.ISO3166Code = value_
            self.ISO3166Code_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.ISO3166Code)
# end class Country


class MeasurementOrFact(GeneratedsSuper):
    """General purpose measurement and fact (descriptor) recording."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('MeasurementOrFactAtomized', 'MeasurementOrFactAtomizedType', 0, 1, {'minOccurs': '0', 'name': 'MeasurementOrFactAtomized', 'type': 'MeasurementOrFactAtomizedType'}, None),
        MemberSpec_('MeasurementOrFactText', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'MeasurementOrFactText', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/MeasurementOrFactText', 'type': 'StringL'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, MeasurementOrFactAtomized=None, MeasurementOrFactText=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.MeasurementOrFactAtomized = MeasurementOrFactAtomized
        self.MeasurementOrFactAtomized_nsprefix_ = None
        self.MeasurementOrFactText = MeasurementOrFactText
        self.MeasurementOrFactText_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MeasurementOrFact)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MeasurementOrFact.subclass:
            return MeasurementOrFact.subclass(*args_, **kwargs_)
        else:
            return MeasurementOrFact(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_MeasurementOrFactAtomized(self):
        return self.MeasurementOrFactAtomized
    def set_MeasurementOrFactAtomized(self, MeasurementOrFactAtomized):
        self.MeasurementOrFactAtomized = MeasurementOrFactAtomized
    def get_MeasurementOrFactText(self):
        return self.MeasurementOrFactText
    def set_MeasurementOrFactText(self, MeasurementOrFactText):
        self.MeasurementOrFactText = MeasurementOrFactText
    def hasContent_(self):
        if (
            self.MeasurementOrFactAtomized is not None or
            self.MeasurementOrFactText is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='MeasurementOrFact', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MeasurementOrFact')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MeasurementOrFact')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MeasurementOrFact', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MeasurementOrFact'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='MeasurementOrFact', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MeasurementOrFactAtomized is not None:
            namespaceprefix_ = self.MeasurementOrFactAtomized_nsprefix_ + ':' if (UseCapturedNS_ and self.MeasurementOrFactAtomized_nsprefix_) else ''
            self.MeasurementOrFactAtomized.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MeasurementOrFactAtomized', pretty_print=pretty_print)
        if self.MeasurementOrFactText is not None:
            namespaceprefix_ = self.MeasurementOrFactText_nsprefix_ + ':' if (UseCapturedNS_ and self.MeasurementOrFactText_nsprefix_) else ''
            self.MeasurementOrFactText.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MeasurementOrFactText', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'MeasurementOrFactAtomized':
            obj_ = MeasurementOrFactAtomizedType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MeasurementOrFactAtomized = obj_
            obj_.original_tagname_ = 'MeasurementOrFactAtomized'
        elif nodeName_ == 'MeasurementOrFactText':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MeasurementOrFactText = obj_
            obj_.original_tagname_ = 'MeasurementOrFactText'
# end class MeasurementOrFact


class StratigraphicTerm(GeneratedsSuper):
    """Descriptive term. May be taken from a controlled vocabulary maintained
    by a third party."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('Domain', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'Domain', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/termDomain', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('Term', ['String', 'xs:normalizedString'], 0, 0, {'name': 'Term', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/term', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('Source', 'Reference', 0, 1, {'minOccurs': '0', 'name': 'Source', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/StratigraphicTerm-Source', 'type': 'Reference'}, None),
        MemberSpec_('Comment', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'Comment', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Term-Notes', 'type': 'xs:normalizedString'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, Domain=None, Term=None, Source=None, Comment=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Domain = Domain
        self.validate_String(self.Domain)
        self.Domain_nsprefix_ = None
        self.Term = Term
        self.validate_String(self.Term)
        self.Term_nsprefix_ = None
        self.Source = Source
        self.Source_nsprefix_ = None
        self.Comment = Comment
        self.validate_String(self.Comment)
        self.Comment_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StratigraphicTerm)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StratigraphicTerm.subclass:
            return StratigraphicTerm.subclass(*args_, **kwargs_)
        else:
            return StratigraphicTerm(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Domain(self):
        return self.Domain
    def set_Domain(self, Domain):
        self.Domain = Domain
    def get_Term(self):
        return self.Term
    def set_Term(self, Term):
        self.Term = Term
    def get_Source(self):
        return self.Source
    def set_Source(self, Source):
        self.Source = Source
    def get_Comment(self):
        return self.Comment
    def set_Comment(self, Comment):
        self.Comment = Comment
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_String(self, value):
        result = True
        # Validate type String, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on String' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.Domain is not None or
            self.Term is not None or
            self.Source is not None or
            self.Comment is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='StratigraphicTerm', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StratigraphicTerm')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StratigraphicTerm')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StratigraphicTerm', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StratigraphicTerm'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='StratigraphicTerm', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Domain is not None:
            namespaceprefix_ = self.Domain_nsprefix_ + ':' if (UseCapturedNS_ and self.Domain_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDomain>%s</%sDomain>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Domain), input_name='Domain')), namespaceprefix_ , eol_))
        if self.Term is not None:
            namespaceprefix_ = self.Term_nsprefix_ + ':' if (UseCapturedNS_ and self.Term_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTerm>%s</%sTerm>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Term), input_name='Term')), namespaceprefix_ , eol_))
        if self.Source is not None:
            namespaceprefix_ = self.Source_nsprefix_ + ':' if (UseCapturedNS_ and self.Source_nsprefix_) else ''
            self.Source.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Source', pretty_print=pretty_print)
        if self.Comment is not None:
            namespaceprefix_ = self.Comment_nsprefix_ + ':' if (UseCapturedNS_ and self.Comment_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sComment>%s</%sComment>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Comment), input_name='Comment')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Domain':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Domain')
            value_ = self.gds_validate_string(value_, node, 'Domain')
            self.Domain = value_
            self.Domain_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.Domain)
        elif nodeName_ == 'Term':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Term')
            value_ = self.gds_validate_string(value_, node, 'Term')
            self.Term = value_
            self.Term_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.Term)
        elif nodeName_ == 'Source':
            obj_ = Reference.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Source = obj_
            obj_.original_tagname_ = 'Source'
        elif nodeName_ == 'Comment':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Comment')
            value_ = self.gds_validate_string(value_, node, 'Comment')
            self.Comment = value_
            self.Comment_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.Comment)
# end class StratigraphicTerm


class StratigraphicTermL(StratigraphicTerm):
    """StratigraphicTerm type extended with language attribute."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('language', 'xs:language', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = StratigraphicTerm
    def __init__(self, Domain=None, Term=None, Source=None, Comment=None, language=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(StratigraphicTermL, self).__init__(Domain, Term, Source, Comment,  **kwargs_)
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StratigraphicTermL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StratigraphicTermL.subclass:
            return StratigraphicTermL.subclass(*args_, **kwargs_)
        else:
            return StratigraphicTermL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def hasContent_(self):
        if (
            super(StratigraphicTermL, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='StratigraphicTermL', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StratigraphicTermL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StratigraphicTermL')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StratigraphicTermL', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StratigraphicTermL'):
        super(StratigraphicTermL, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StratigraphicTermL')
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='StratigraphicTermL', fromsubclass_=False, pretty_print=True):
        super(StratigraphicTermL, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        super(StratigraphicTermL, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(StratigraphicTermL, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class StratigraphicTermL


class ContentMetadata(GeneratedsSuper):
    """Metadata referring to the principal source of the entire data collection
    (thus the metadata scope may be wider than the objects actually
    contained in the data set). If a history of the data collection
    (revised or expanded in various projects or at different institutions)
    exist, this must be reflected in the IPR statements and possibly in the
    list of Owners."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('Description', 'DescriptionType', 0, 0, {'name': 'Description', 'type': 'DescriptionType'}, None),
        MemberSpec_('LogoURL', 'xs:anyURI', 0, 1, {'minOccurs': '0', 'name': 'LogoURL', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/logoURL http://rs.tdwg.org/abcd/mappings/DataSet-LogoURL', 'type': 'xs:anyURI'}, None),
        MemberSpec_('Scope', 'ScopeType', 0, 1, {'minOccurs': '0', 'name': 'Scope', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/scope', 'type': 'ScopeType'}, None),
        MemberSpec_('Version', 'VersionType', 0, 1, {'minOccurs': '0', 'name': 'Version', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/DataSet-Version', 'type': 'VersionType'}, None),
        MemberSpec_('RevisionData', 'RevisionData', 0, 0, {'name': 'RevisionData', 'type': 'RevisionData'}, None),
        MemberSpec_('Owners', 'OwnersType', 0, 1, {'minOccurs': '0', 'name': 'Owners', 'type': 'OwnersType'}, None),
        MemberSpec_('LegalStatements', 'LegalStatements', 0, 1, {'minOccurs': '0', 'name': 'LegalStatements', 'type': 'LegalStatements'}, None),
        MemberSpec_('InformationWithheld', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'InformationWithheld', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/informationWithheld http://rs.tdwg.org/abcd/mappings/DataSet-InformationWithheld', 'type': 'StringL'}, None),
        MemberSpec_('DirectAccessURL', 'xs:anyURI', 0, 1, {'minOccurs': '0', 'name': 'DirectAccessURL', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/directAccessURL http://rs.tdwg.org/abcd/mappings/DataSet-DirectAccessURL', 'type': 'xs:anyURI'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, Description=None, LogoURL=None, Scope=None, Version=None, RevisionData=None, Owners=None, LegalStatements=None, InformationWithheld=None, DirectAccessURL=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Description = Description
        self.Description_nsprefix_ = None
        self.LogoURL = LogoURL
        self.LogoURL_nsprefix_ = None
        self.Scope = Scope
        self.Scope_nsprefix_ = None
        self.Version = Version
        self.Version_nsprefix_ = None
        self.RevisionData = RevisionData
        self.RevisionData_nsprefix_ = None
        self.Owners = Owners
        self.Owners_nsprefix_ = None
        self.LegalStatements = LegalStatements
        self.LegalStatements_nsprefix_ = None
        self.InformationWithheld = InformationWithheld
        self.InformationWithheld_nsprefix_ = None
        self.DirectAccessURL = DirectAccessURL
        self.DirectAccessURL_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContentMetadata)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContentMetadata.subclass:
            return ContentMetadata.subclass(*args_, **kwargs_)
        else:
            return ContentMetadata(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Description(self):
        return self.Description
    def set_Description(self, Description):
        self.Description = Description
    def get_LogoURL(self):
        return self.LogoURL
    def set_LogoURL(self, LogoURL):
        self.LogoURL = LogoURL
    def get_Scope(self):
        return self.Scope
    def set_Scope(self, Scope):
        self.Scope = Scope
    def get_Version(self):
        return self.Version
    def set_Version(self, Version):
        self.Version = Version
    def get_RevisionData(self):
        return self.RevisionData
    def set_RevisionData(self, RevisionData):
        self.RevisionData = RevisionData
    def get_Owners(self):
        return self.Owners
    def set_Owners(self, Owners):
        self.Owners = Owners
    def get_LegalStatements(self):
        return self.LegalStatements
    def set_LegalStatements(self, LegalStatements):
        self.LegalStatements = LegalStatements
    def get_InformationWithheld(self):
        return self.InformationWithheld
    def set_InformationWithheld(self, InformationWithheld):
        self.InformationWithheld = InformationWithheld
    def get_DirectAccessURL(self):
        return self.DirectAccessURL
    def set_DirectAccessURL(self, DirectAccessURL):
        self.DirectAccessURL = DirectAccessURL
    def hasContent_(self):
        if (
            self.Description is not None or
            self.LogoURL is not None or
            self.Scope is not None or
            self.Version is not None or
            self.RevisionData is not None or
            self.Owners is not None or
            self.LegalStatements is not None or
            self.InformationWithheld is not None or
            self.DirectAccessURL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='ContentMetadata', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ContentMetadata')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ContentMetadata')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ContentMetadata', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ContentMetadata'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='ContentMetadata', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Description is not None:
            namespaceprefix_ = self.Description_nsprefix_ + ':' if (UseCapturedNS_ and self.Description_nsprefix_) else ''
            self.Description.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Description', pretty_print=pretty_print)
        if self.LogoURL is not None:
            namespaceprefix_ = self.LogoURL_nsprefix_ + ':' if (UseCapturedNS_ and self.LogoURL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLogoURL>%s</%sLogoURL>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.LogoURL), input_name='LogoURL')), namespaceprefix_ , eol_))
        if self.Scope is not None:
            namespaceprefix_ = self.Scope_nsprefix_ + ':' if (UseCapturedNS_ and self.Scope_nsprefix_) else ''
            self.Scope.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Scope', pretty_print=pretty_print)
        if self.Version is not None:
            namespaceprefix_ = self.Version_nsprefix_ + ':' if (UseCapturedNS_ and self.Version_nsprefix_) else ''
            self.Version.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Version', pretty_print=pretty_print)
        if self.RevisionData is not None:
            namespaceprefix_ = self.RevisionData_nsprefix_ + ':' if (UseCapturedNS_ and self.RevisionData_nsprefix_) else ''
            self.RevisionData.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RevisionData', pretty_print=pretty_print)
        if self.Owners is not None:
            namespaceprefix_ = self.Owners_nsprefix_ + ':' if (UseCapturedNS_ and self.Owners_nsprefix_) else ''
            self.Owners.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Owners', pretty_print=pretty_print)
        if self.LegalStatements is not None:
            namespaceprefix_ = self.LegalStatements_nsprefix_ + ':' if (UseCapturedNS_ and self.LegalStatements_nsprefix_) else ''
            self.LegalStatements.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LegalStatements', pretty_print=pretty_print)
        if self.InformationWithheld is not None:
            namespaceprefix_ = self.InformationWithheld_nsprefix_ + ':' if (UseCapturedNS_ and self.InformationWithheld_nsprefix_) else ''
            self.InformationWithheld.export(outfile, level, namespaceprefix_, namespacedef_='', name_='InformationWithheld', pretty_print=pretty_print)
        if self.DirectAccessURL is not None:
            namespaceprefix_ = self.DirectAccessURL_nsprefix_ + ':' if (UseCapturedNS_ and self.DirectAccessURL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDirectAccessURL>%s</%sDirectAccessURL>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DirectAccessURL), input_name='DirectAccessURL')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Description':
            obj_ = DescriptionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Description = obj_
            obj_.original_tagname_ = 'Description'
        elif nodeName_ == 'LogoURL':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'LogoURL')
            value_ = self.gds_validate_string(value_, node, 'LogoURL')
            self.LogoURL = value_
            self.LogoURL_nsprefix_ = child_.prefix
        elif nodeName_ == 'Scope':
            obj_ = ScopeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Scope = obj_
            obj_.original_tagname_ = 'Scope'
        elif nodeName_ == 'Version':
            obj_ = VersionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Version = obj_
            obj_.original_tagname_ = 'Version'
        elif nodeName_ == 'RevisionData':
            obj_ = RevisionData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RevisionData = obj_
            obj_.original_tagname_ = 'RevisionData'
        elif nodeName_ == 'Owners':
            obj_ = OwnersType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Owners = obj_
            obj_.original_tagname_ = 'Owners'
        elif nodeName_ == 'LegalStatements':
            obj_ = LegalStatements.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LegalStatements = obj_
            obj_.original_tagname_ = 'LegalStatements'
        elif nodeName_ == 'InformationWithheld':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.InformationWithheld = obj_
            obj_.original_tagname_ = 'InformationWithheld'
        elif nodeName_ == 'DirectAccessURL':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DirectAccessURL')
            value_ = self.gds_validate_string(value_, node, 'DirectAccessURL')
            self.DirectAccessURL = value_
            self.DirectAccessURL_nsprefix_ = child_.prefix
# end class ContentMetadata


class MetadataDescriptionRepr(GeneratedsSuper):
    """Language-specific content metadata (title, description, etc.) with
    *required* language attribute added."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('language', 'xs:language', 0, 0, {'use': 'required'}),
        MemberSpec_('Title', ['String255', 'xs:normalizedString'], 0, 0, {'name': 'Title', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/title http://rs.tdwg.org/abcd/mappings/DataSet-Title', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('Details', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'Details', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/notes', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('Coverage', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'Coverage', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/coverage', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('WebsiteURL', 'xs:anyURI', 0, 1, {'minOccurs': '0', 'name': 'WebsiteURL', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/websiteURL http://rs.tdwg.org/abcd/mappings/DataSet-WebsiteURL', 'type': 'xs:anyURI'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, language=None, Title=None, Details=None, Coverage=None, WebsiteURL=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.Title = Title
        self.validate_String255(self.Title)
        self.Title_nsprefix_ = None
        self.Details = Details
        self.validate_String(self.Details)
        self.Details_nsprefix_ = None
        self.Coverage = Coverage
        self.validate_String(self.Coverage)
        self.Coverage_nsprefix_ = None
        self.WebsiteURL = WebsiteURL
        self.WebsiteURL_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MetadataDescriptionRepr)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MetadataDescriptionRepr.subclass:
            return MetadataDescriptionRepr.subclass(*args_, **kwargs_)
        else:
            return MetadataDescriptionRepr(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Title(self):
        return self.Title
    def set_Title(self, Title):
        self.Title = Title
    def get_Details(self):
        return self.Details
    def set_Details(self, Details):
        self.Details = Details
    def get_Coverage(self):
        return self.Coverage
    def set_Coverage(self, Coverage):
        self.Coverage = Coverage
    def get_WebsiteURL(self):
        return self.WebsiteURL
    def set_WebsiteURL(self, WebsiteURL):
        self.WebsiteURL = WebsiteURL
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def validate_String255(self, value):
        result = True
        # Validate type String255, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 255:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on String255' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on String255' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_String(self, value):
        result = True
        # Validate type String, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on String' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.Title is not None or
            self.Details is not None or
            self.Coverage is not None or
            self.WebsiteURL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='MetadataDescriptionRepr', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MetadataDescriptionRepr')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MetadataDescriptionRepr')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MetadataDescriptionRepr', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MetadataDescriptionRepr'):
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='MetadataDescriptionRepr', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Title is not None:
            namespaceprefix_ = self.Title_nsprefix_ + ':' if (UseCapturedNS_ and self.Title_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTitle>%s</%sTitle>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Title), input_name='Title')), namespaceprefix_ , eol_))
        if self.Details is not None:
            namespaceprefix_ = self.Details_nsprefix_ + ':' if (UseCapturedNS_ and self.Details_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDetails>%s</%sDetails>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Details), input_name='Details')), namespaceprefix_ , eol_))
        if self.Coverage is not None:
            namespaceprefix_ = self.Coverage_nsprefix_ + ':' if (UseCapturedNS_ and self.Coverage_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCoverage>%s</%sCoverage>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Coverage), input_name='Coverage')), namespaceprefix_ , eol_))
        if self.WebsiteURL is not None:
            namespaceprefix_ = self.WebsiteURL_nsprefix_ + ':' if (UseCapturedNS_ and self.WebsiteURL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sWebsiteURL>%s</%sWebsiteURL>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.WebsiteURL), input_name='WebsiteURL')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Title':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Title')
            value_ = self.gds_validate_string(value_, node, 'Title')
            self.Title = value_
            self.Title_nsprefix_ = child_.prefix
            # validate type String255
            self.validate_String255(self.Title)
        elif nodeName_ == 'Details':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Details')
            value_ = self.gds_validate_string(value_, node, 'Details')
            self.Details = value_
            self.Details_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.Details)
        elif nodeName_ == 'Coverage':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Coverage')
            value_ = self.gds_validate_string(value_, node, 'Coverage')
            self.Coverage = value_
            self.Coverage_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.Coverage)
        elif nodeName_ == 'WebsiteURL':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'WebsiteURL')
            value_ = self.gds_validate_string(value_, node, 'WebsiteURL')
            self.WebsiteURL = value_
            self.WebsiteURL_nsprefix_ = child_.prefix
# end class MetadataDescriptionRepr


class RevisionData(GeneratedsSuper):
    """Revision data (creators, dates, revision) for the entire project/data
    set or individual objects."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('Creators', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'Creators', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/creators', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('Contributors', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'Contributors', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/contributors', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('DateCreated', ['DateTimeISO', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'DateCreated', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/timeSpanBegin http://rs.tdwg.org/abcd/mappings/DateCreated http://rs.tdwg.org/abcd/mappings/DataSet-DateCreated', 'type': 'xs:string'}, None),
        MemberSpec_('DateModified', ['DateTimeISO', 'xs:string'], 0, 0, {'name': 'DateModified', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/DateModified', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, Creators=None, Contributors=None, DateCreated=None, DateModified=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Creators = Creators
        self.validate_String(self.Creators)
        self.Creators_nsprefix_ = None
        self.Contributors = Contributors
        self.validate_String(self.Contributors)
        self.Contributors_nsprefix_ = None
        self.DateCreated = DateCreated
        self.validate_DateTimeISO(self.DateCreated)
        self.DateCreated_nsprefix_ = None
        self.DateModified = DateModified
        self.validate_DateTimeISO(self.DateModified)
        self.DateModified_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RevisionData)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RevisionData.subclass:
            return RevisionData.subclass(*args_, **kwargs_)
        else:
            return RevisionData(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Creators(self):
        return self.Creators
    def set_Creators(self, Creators):
        self.Creators = Creators
    def get_Contributors(self):
        return self.Contributors
    def set_Contributors(self, Contributors):
        self.Contributors = Contributors
    def get_DateCreated(self):
        return self.DateCreated
    def set_DateCreated(self, DateCreated):
        self.DateCreated = DateCreated
    def get_DateModified(self):
        return self.DateModified
    def set_DateModified(self, DateModified):
        self.DateModified = DateModified
    def validate_String(self, value):
        result = True
        # Validate type String, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on String' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_DateTimeISO(self, value):
        result = True
        # Validate type DateTimeISO, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_DateTimeISO_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_DateTimeISO_patterns_, ))
                result = False
        return result
    validate_DateTimeISO_patterns_ = [['^(((1(5(8[3-9]|9\\d)|[6789]\\d\\d))|(20\\d\\d))(-((0[1-9]|1[012])(-(0[1-9]|1\\d|2[0-8])(T(0\\d|1\\d|2[0-3])(:[0-5]\\d(:[0-5]\\d(.\\d+)?)?)?(Z|[+\\-](0\\d|1[12])(:[0-5]\\d)?)?)?)?|(0[13-9]|1[012])-(29|30)(T(0\\d|1\\d|2[0-3])(:[0-5]\\d(:[0-5]\\d(.\\d+)?)?)?(Z|[+\\-](0\\d|1[12])(:[0-5]\\d)?)?)?|(0[13578]|1[02])-31(T(0\\d|1\\d|2[0-3])(:[0-5]\\d(:[0-5]\\d(.\\d+)?)?)?(Z|[+\\-](0\\d|1[12])(:[0-5]\\d)?)?)?))?|((15(8[48]|9[26]))|(1[6-9](0[48]|[2468][048]|[13579][26])|20(0[48]|[2468][048]|[13579][26]))|((16|20)00))-02-29(T(\\d|1\\d|2[0-3])(:[0-5]\\d(:[0-5]\\d(.\\d+)?)?)?(Z|[+\\-](0\\d|1[12])(:[0-5]\\d)?)?)?)$']]
    def hasContent_(self):
        if (
            self.Creators is not None or
            self.Contributors is not None or
            self.DateCreated is not None or
            self.DateModified is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='RevisionData', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RevisionData')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RevisionData')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RevisionData', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RevisionData'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='RevisionData', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Creators is not None:
            namespaceprefix_ = self.Creators_nsprefix_ + ':' if (UseCapturedNS_ and self.Creators_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCreators>%s</%sCreators>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Creators), input_name='Creators')), namespaceprefix_ , eol_))
        if self.Contributors is not None:
            namespaceprefix_ = self.Contributors_nsprefix_ + ':' if (UseCapturedNS_ and self.Contributors_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sContributors>%s</%sContributors>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Contributors), input_name='Contributors')), namespaceprefix_ , eol_))
        if self.DateCreated is not None:
            namespaceprefix_ = self.DateCreated_nsprefix_ + ':' if (UseCapturedNS_ and self.DateCreated_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDateCreated>%s</%sDateCreated>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DateCreated), input_name='DateCreated')), namespaceprefix_ , eol_))
        if self.DateModified is not None:
            namespaceprefix_ = self.DateModified_nsprefix_ + ':' if (UseCapturedNS_ and self.DateModified_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDateModified>%s</%sDateModified>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DateModified), input_name='DateModified')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Creators':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Creators')
            value_ = self.gds_validate_string(value_, node, 'Creators')
            self.Creators = value_
            self.Creators_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.Creators)
        elif nodeName_ == 'Contributors':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Contributors')
            value_ = self.gds_validate_string(value_, node, 'Contributors')
            self.Contributors = value_
            self.Contributors_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.Contributors)
        elif nodeName_ == 'DateCreated':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DateCreated')
            value_ = self.gds_validate_string(value_, node, 'DateCreated')
            self.DateCreated = value_
            self.DateCreated_nsprefix_ = child_.prefix
            # validate type DateTimeISO
            self.validate_DateTimeISO(self.DateCreated)
        elif nodeName_ == 'DateModified':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DateModified')
            value_ = self.gds_validate_string(value_, node, 'DateModified')
            self.DateModified = value_
            self.DateModified_nsprefix_ = child_.prefix
            # validate type DateTimeISO
            self.validate_DateTimeISO(self.DateModified)
# end class RevisionData


class TaxonIdentified(GeneratedsSuper):
    """Scientific or informal name as a result of an identification."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('HigherTaxa', 'HigherTaxaType', 0, 1, {'minOccurs': '0', 'name': 'HigherTaxa', 'type': 'HigherTaxaType'}, None),
        MemberSpec_('ScientificName', 'ScientificName', 0, 1, {'minOccurs': '0', 'name': 'ScientificName', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/ScientificName', 'type': 'ScientificNameIdentified'}, 2),
        MemberSpec_('InformalName', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'InformalName', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/informalName', 'type': 'StringL'}, 2),
        MemberSpec_('NameComments', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'NameComments', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/TaxonIdentified-NameComments', 'type': 'StringL'}, None),
        MemberSpec_('Code', ['CodeOfNomenclatureEnum', 'xs:Name'], 0, 1, {'minOccurs': '0', 'name': 'Code', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/NomenclatureCode', 'type': 'xs:Name'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, HigherTaxa=None, ScientificName=None, InformalName=None, NameComments=None, Code=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.HigherTaxa = HigherTaxa
        self.HigherTaxa_nsprefix_ = None
        self.ScientificName = ScientificName
        self.ScientificName_nsprefix_ = None
        self.InformalName = InformalName
        self.InformalName_nsprefix_ = None
        self.NameComments = NameComments
        self.NameComments_nsprefix_ = None
        self.Code = Code
        self.validate_CodeOfNomenclatureEnum(self.Code)
        self.Code_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TaxonIdentified)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TaxonIdentified.subclass:
            return TaxonIdentified.subclass(*args_, **kwargs_)
        else:
            return TaxonIdentified(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_HigherTaxa(self):
        return self.HigherTaxa
    def set_HigherTaxa(self, HigherTaxa):
        self.HigherTaxa = HigherTaxa
    def get_ScientificName(self):
        return self.ScientificName
    def set_ScientificName(self, ScientificName):
        self.ScientificName = ScientificName
    def get_InformalName(self):
        return self.InformalName
    def set_InformalName(self, InformalName):
        self.InformalName = InformalName
    def get_NameComments(self):
        return self.NameComments
    def set_NameComments(self, NameComments):
        self.NameComments = NameComments
    def get_Code(self):
        return self.Code
    def set_Code(self, Code):
        self.Code = Code
    def validate_CodeOfNomenclatureEnum(self, value):
        result = True
        # Validate type CodeOfNomenclatureEnum, a restriction on xs:Name.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Bacteriological', 'Botanical', 'Viral', 'Zoological', 'Cultivated']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on CodeOfNomenclatureEnum' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.HigherTaxa is not None or
            self.ScientificName is not None or
            self.InformalName is not None or
            self.NameComments is not None or
            self.Code is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='TaxonIdentified', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TaxonIdentified')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TaxonIdentified')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TaxonIdentified', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TaxonIdentified'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='TaxonIdentified', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.HigherTaxa is not None:
            namespaceprefix_ = self.HigherTaxa_nsprefix_ + ':' if (UseCapturedNS_ and self.HigherTaxa_nsprefix_) else ''
            self.HigherTaxa.export(outfile, level, namespaceprefix_, namespacedef_='', name_='HigherTaxa', pretty_print=pretty_print)
        if self.ScientificName is not None:
            namespaceprefix_ = self.ScientificName_nsprefix_ + ':' if (UseCapturedNS_ and self.ScientificName_nsprefix_) else ''
            self.ScientificName.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ScientificName', pretty_print=pretty_print)
        if self.InformalName is not None:
            namespaceprefix_ = self.InformalName_nsprefix_ + ':' if (UseCapturedNS_ and self.InformalName_nsprefix_) else ''
            self.InformalName.export(outfile, level, namespaceprefix_, namespacedef_='', name_='InformalName', pretty_print=pretty_print)
        if self.NameComments is not None:
            namespaceprefix_ = self.NameComments_nsprefix_ + ':' if (UseCapturedNS_ and self.NameComments_nsprefix_) else ''
            self.NameComments.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NameComments', pretty_print=pretty_print)
        if self.Code is not None:
            namespaceprefix_ = self.Code_nsprefix_ + ':' if (UseCapturedNS_ and self.Code_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCode>%s</%sCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Code), input_name='Code')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'HigherTaxa':
            obj_ = HigherTaxaType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.HigherTaxa = obj_
            obj_.original_tagname_ = 'HigherTaxa'
        elif nodeName_ == 'ScientificName':
            obj_ = ScientificNameIdentified.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ScientificName = obj_
            obj_.original_tagname_ = 'ScientificName'
        elif nodeName_ == 'InformalName':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.InformalName = obj_
            obj_.original_tagname_ = 'InformalName'
        elif nodeName_ == 'NameComments':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NameComments = obj_
            obj_.original_tagname_ = 'NameComments'
        elif nodeName_ == 'Code':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Code')
            value_ = self.gds_validate_string(value_, node, 'Code')
            self.Code = value_
            self.Code_nsprefix_ = child_.prefix
            # validate type CodeOfNomenclatureEnum
            self.validate_CodeOfNomenclatureEnum(self.Code)
# end class TaxonIdentified


class NameBacterial(GeneratedsSuper):
    """An atomized name under the International Code of Nomenclature of
    Bacteria"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('GenusOrMonomial', ['Monomial', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'GenusOrMonomial', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/genusOrMonomial', 'type': 'xs:string'}, None),
        MemberSpec_('Subgenus', ['Monomial', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'Subgenus', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/subgenus', 'type': 'xs:string'}, None),
        MemberSpec_('SubgenusAuthorAndYear', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'SubgenusAuthorAndYear', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/subgenusAuthorAndYear', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('SpeciesEpithet', ['Epithet', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'SpeciesEpithet', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/speciesEpithet', 'type': 'xs:string'}, None),
        MemberSpec_('SubspeciesEpithet', ['Epithet', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'SubspeciesEpithet', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/subspeciesEpithet', 'type': 'xs:string'}, None),
        MemberSpec_('ParentheticalAuthorTeamAndYear', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'ParentheticalAuthorTeamAndYear', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/parentheticalAuthorTeamAndYear', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('AuthorTeamAndYear', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'AuthorTeamAndYear', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/authorTeamAndYear', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('NameApprobation', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'NameApprobation', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/nameApprobation', 'type': 'xs:normalizedString'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, GenusOrMonomial=None, Subgenus=None, SubgenusAuthorAndYear=None, SpeciesEpithet=None, SubspeciesEpithet=None, ParentheticalAuthorTeamAndYear=None, AuthorTeamAndYear=None, NameApprobation=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.GenusOrMonomial = GenusOrMonomial
        self.validate_Monomial(self.GenusOrMonomial)
        self.GenusOrMonomial_nsprefix_ = None
        self.Subgenus = Subgenus
        self.validate_Monomial(self.Subgenus)
        self.Subgenus_nsprefix_ = None
        self.SubgenusAuthorAndYear = SubgenusAuthorAndYear
        self.validate_String(self.SubgenusAuthorAndYear)
        self.SubgenusAuthorAndYear_nsprefix_ = None
        self.SpeciesEpithet = SpeciesEpithet
        self.validate_Epithet(self.SpeciesEpithet)
        self.SpeciesEpithet_nsprefix_ = None
        self.SubspeciesEpithet = SubspeciesEpithet
        self.validate_Epithet(self.SubspeciesEpithet)
        self.SubspeciesEpithet_nsprefix_ = None
        self.ParentheticalAuthorTeamAndYear = ParentheticalAuthorTeamAndYear
        self.validate_String(self.ParentheticalAuthorTeamAndYear)
        self.ParentheticalAuthorTeamAndYear_nsprefix_ = None
        self.AuthorTeamAndYear = AuthorTeamAndYear
        self.validate_String(self.AuthorTeamAndYear)
        self.AuthorTeamAndYear_nsprefix_ = None
        self.NameApprobation = NameApprobation
        self.validate_String(self.NameApprobation)
        self.NameApprobation_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NameBacterial)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NameBacterial.subclass:
            return NameBacterial.subclass(*args_, **kwargs_)
        else:
            return NameBacterial(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_GenusOrMonomial(self):
        return self.GenusOrMonomial
    def set_GenusOrMonomial(self, GenusOrMonomial):
        self.GenusOrMonomial = GenusOrMonomial
    def get_Subgenus(self):
        return self.Subgenus
    def set_Subgenus(self, Subgenus):
        self.Subgenus = Subgenus
    def get_SubgenusAuthorAndYear(self):
        return self.SubgenusAuthorAndYear
    def set_SubgenusAuthorAndYear(self, SubgenusAuthorAndYear):
        self.SubgenusAuthorAndYear = SubgenusAuthorAndYear
    def get_SpeciesEpithet(self):
        return self.SpeciesEpithet
    def set_SpeciesEpithet(self, SpeciesEpithet):
        self.SpeciesEpithet = SpeciesEpithet
    def get_SubspeciesEpithet(self):
        return self.SubspeciesEpithet
    def set_SubspeciesEpithet(self, SubspeciesEpithet):
        self.SubspeciesEpithet = SubspeciesEpithet
    def get_ParentheticalAuthorTeamAndYear(self):
        return self.ParentheticalAuthorTeamAndYear
    def set_ParentheticalAuthorTeamAndYear(self, ParentheticalAuthorTeamAndYear):
        self.ParentheticalAuthorTeamAndYear = ParentheticalAuthorTeamAndYear
    def get_AuthorTeamAndYear(self):
        return self.AuthorTeamAndYear
    def set_AuthorTeamAndYear(self, AuthorTeamAndYear):
        self.AuthorTeamAndYear = AuthorTeamAndYear
    def get_NameApprobation(self):
        return self.NameApprobation
    def set_NameApprobation(self, NameApprobation):
        self.NameApprobation = NameApprobation
    def validate_Monomial(self, value):
        result = True
        # Validate type Monomial, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_String(self, value):
        result = True
        # Validate type String, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on String' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_Epithet(self, value):
        result = True
        # Validate type Epithet, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def hasContent_(self):
        if (
            self.GenusOrMonomial is not None or
            self.Subgenus is not None or
            self.SubgenusAuthorAndYear is not None or
            self.SpeciesEpithet is not None or
            self.SubspeciesEpithet is not None or
            self.ParentheticalAuthorTeamAndYear is not None or
            self.AuthorTeamAndYear is not None or
            self.NameApprobation is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='NameBacterial', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NameBacterial')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NameBacterial')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NameBacterial', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NameBacterial'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='NameBacterial', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.GenusOrMonomial is not None:
            namespaceprefix_ = self.GenusOrMonomial_nsprefix_ + ':' if (UseCapturedNS_ and self.GenusOrMonomial_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGenusOrMonomial>%s</%sGenusOrMonomial>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.GenusOrMonomial), input_name='GenusOrMonomial')), namespaceprefix_ , eol_))
        if self.Subgenus is not None:
            namespaceprefix_ = self.Subgenus_nsprefix_ + ':' if (UseCapturedNS_ and self.Subgenus_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSubgenus>%s</%sSubgenus>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Subgenus), input_name='Subgenus')), namespaceprefix_ , eol_))
        if self.SubgenusAuthorAndYear is not None:
            namespaceprefix_ = self.SubgenusAuthorAndYear_nsprefix_ + ':' if (UseCapturedNS_ and self.SubgenusAuthorAndYear_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSubgenusAuthorAndYear>%s</%sSubgenusAuthorAndYear>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SubgenusAuthorAndYear), input_name='SubgenusAuthorAndYear')), namespaceprefix_ , eol_))
        if self.SpeciesEpithet is not None:
            namespaceprefix_ = self.SpeciesEpithet_nsprefix_ + ':' if (UseCapturedNS_ and self.SpeciesEpithet_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSpeciesEpithet>%s</%sSpeciesEpithet>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SpeciesEpithet), input_name='SpeciesEpithet')), namespaceprefix_ , eol_))
        if self.SubspeciesEpithet is not None:
            namespaceprefix_ = self.SubspeciesEpithet_nsprefix_ + ':' if (UseCapturedNS_ and self.SubspeciesEpithet_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSubspeciesEpithet>%s</%sSubspeciesEpithet>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SubspeciesEpithet), input_name='SubspeciesEpithet')), namespaceprefix_ , eol_))
        if self.ParentheticalAuthorTeamAndYear is not None:
            namespaceprefix_ = self.ParentheticalAuthorTeamAndYear_nsprefix_ + ':' if (UseCapturedNS_ and self.ParentheticalAuthorTeamAndYear_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sParentheticalAuthorTeamAndYear>%s</%sParentheticalAuthorTeamAndYear>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ParentheticalAuthorTeamAndYear), input_name='ParentheticalAuthorTeamAndYear')), namespaceprefix_ , eol_))
        if self.AuthorTeamAndYear is not None:
            namespaceprefix_ = self.AuthorTeamAndYear_nsprefix_ + ':' if (UseCapturedNS_ and self.AuthorTeamAndYear_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAuthorTeamAndYear>%s</%sAuthorTeamAndYear>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.AuthorTeamAndYear), input_name='AuthorTeamAndYear')), namespaceprefix_ , eol_))
        if self.NameApprobation is not None:
            namespaceprefix_ = self.NameApprobation_nsprefix_ + ':' if (UseCapturedNS_ and self.NameApprobation_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNameApprobation>%s</%sNameApprobation>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NameApprobation), input_name='NameApprobation')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'GenusOrMonomial':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'GenusOrMonomial')
            value_ = self.gds_validate_string(value_, node, 'GenusOrMonomial')
            self.GenusOrMonomial = value_
            self.GenusOrMonomial_nsprefix_ = child_.prefix
            # validate type Monomial
            self.validate_Monomial(self.GenusOrMonomial)
        elif nodeName_ == 'Subgenus':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Subgenus')
            value_ = self.gds_validate_string(value_, node, 'Subgenus')
            self.Subgenus = value_
            self.Subgenus_nsprefix_ = child_.prefix
            # validate type Monomial
            self.validate_Monomial(self.Subgenus)
        elif nodeName_ == 'SubgenusAuthorAndYear':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SubgenusAuthorAndYear')
            value_ = self.gds_validate_string(value_, node, 'SubgenusAuthorAndYear')
            self.SubgenusAuthorAndYear = value_
            self.SubgenusAuthorAndYear_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.SubgenusAuthorAndYear)
        elif nodeName_ == 'SpeciesEpithet':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SpeciesEpithet')
            value_ = self.gds_validate_string(value_, node, 'SpeciesEpithet')
            self.SpeciesEpithet = value_
            self.SpeciesEpithet_nsprefix_ = child_.prefix
            # validate type Epithet
            self.validate_Epithet(self.SpeciesEpithet)
        elif nodeName_ == 'SubspeciesEpithet':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SubspeciesEpithet')
            value_ = self.gds_validate_string(value_, node, 'SubspeciesEpithet')
            self.SubspeciesEpithet = value_
            self.SubspeciesEpithet_nsprefix_ = child_.prefix
            # validate type Epithet
            self.validate_Epithet(self.SubspeciesEpithet)
        elif nodeName_ == 'ParentheticalAuthorTeamAndYear':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ParentheticalAuthorTeamAndYear')
            value_ = self.gds_validate_string(value_, node, 'ParentheticalAuthorTeamAndYear')
            self.ParentheticalAuthorTeamAndYear = value_
            self.ParentheticalAuthorTeamAndYear_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.ParentheticalAuthorTeamAndYear)
        elif nodeName_ == 'AuthorTeamAndYear':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'AuthorTeamAndYear')
            value_ = self.gds_validate_string(value_, node, 'AuthorTeamAndYear')
            self.AuthorTeamAndYear = value_
            self.AuthorTeamAndYear_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.AuthorTeamAndYear)
        elif nodeName_ == 'NameApprobation':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NameApprobation')
            value_ = self.gds_validate_string(value_, node, 'NameApprobation')
            self.NameApprobation = value_
            self.NameApprobation_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.NameApprobation)
# end class NameBacterial


class NameBotanical(GeneratedsSuper):
    """An atomized scientific name under the International Code of Botanical
    Nomenclature or the International Code of Nomenclature for Cultivated
    Plants"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('GenusOrMonomial', ['Monomial', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'GenusOrMonomial', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/genusOrMonomial', 'type': 'xs:string'}, None),
        MemberSpec_('FirstEpithet', ['Epithet', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'FirstEpithet', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/firstEpithet', 'type': 'xs:string'}, None),
        MemberSpec_('InfraspecificEpithet', ['Epithet', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'InfraspecificEpithet', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/infraspecificEpithet', 'type': 'xs:string'}, None),
        MemberSpec_('Rank', ['RankAbbreviation', 'xs:Name'], 0, 1, {'minOccurs': '0', 'name': 'Rank', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/BotanicalTaxonRank', 'type': 'xs:Name'}, None),
        MemberSpec_('HybridFlag', 'HybridFlagType', 0, 1, {'minOccurs': '0', 'name': 'HybridFlag', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/hybridFlag', 'type': 'HybridFlagType'}, None),
        MemberSpec_('AuthorTeamParenthesis', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'AuthorTeamParenthesis', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/authorTeamParenthesis', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('AuthorTeam', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'AuthorTeam', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/authorTeam', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('CultivarGroupName', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'CultivarGroupName', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/cultivarGroupName', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('CultivarName', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'CultivarName', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/cultivarName', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('TradeDesignationNames', 'TradeDesignationNamesType', 0, 1, {'minOccurs': '0', 'name': 'TradeDesignationNames', 'type': 'TradeDesignationNamesType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, GenusOrMonomial=None, FirstEpithet=None, InfraspecificEpithet=None, Rank=None, HybridFlag=None, AuthorTeamParenthesis=None, AuthorTeam=None, CultivarGroupName=None, CultivarName=None, TradeDesignationNames=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.GenusOrMonomial = GenusOrMonomial
        self.validate_Monomial(self.GenusOrMonomial)
        self.GenusOrMonomial_nsprefix_ = None
        self.FirstEpithet = FirstEpithet
        self.validate_Epithet(self.FirstEpithet)
        self.FirstEpithet_nsprefix_ = None
        self.InfraspecificEpithet = InfraspecificEpithet
        self.validate_Epithet(self.InfraspecificEpithet)
        self.InfraspecificEpithet_nsprefix_ = None
        self.Rank = Rank
        self.validate_RankAbbreviation(self.Rank)
        self.Rank_nsprefix_ = None
        self.HybridFlag = HybridFlag
        self.HybridFlag_nsprefix_ = None
        self.AuthorTeamParenthesis = AuthorTeamParenthesis
        self.validate_String(self.AuthorTeamParenthesis)
        self.AuthorTeamParenthesis_nsprefix_ = None
        self.AuthorTeam = AuthorTeam
        self.validate_String(self.AuthorTeam)
        self.AuthorTeam_nsprefix_ = None
        self.CultivarGroupName = CultivarGroupName
        self.validate_String(self.CultivarGroupName)
        self.CultivarGroupName_nsprefix_ = None
        self.CultivarName = CultivarName
        self.validate_String(self.CultivarName)
        self.CultivarName_nsprefix_ = None
        self.TradeDesignationNames = TradeDesignationNames
        self.TradeDesignationNames_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NameBotanical)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NameBotanical.subclass:
            return NameBotanical.subclass(*args_, **kwargs_)
        else:
            return NameBotanical(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_GenusOrMonomial(self):
        return self.GenusOrMonomial
    def set_GenusOrMonomial(self, GenusOrMonomial):
        self.GenusOrMonomial = GenusOrMonomial
    def get_FirstEpithet(self):
        return self.FirstEpithet
    def set_FirstEpithet(self, FirstEpithet):
        self.FirstEpithet = FirstEpithet
    def get_InfraspecificEpithet(self):
        return self.InfraspecificEpithet
    def set_InfraspecificEpithet(self, InfraspecificEpithet):
        self.InfraspecificEpithet = InfraspecificEpithet
    def get_Rank(self):
        return self.Rank
    def set_Rank(self, Rank):
        self.Rank = Rank
    def get_HybridFlag(self):
        return self.HybridFlag
    def set_HybridFlag(self, HybridFlag):
        self.HybridFlag = HybridFlag
    def get_AuthorTeamParenthesis(self):
        return self.AuthorTeamParenthesis
    def set_AuthorTeamParenthesis(self, AuthorTeamParenthesis):
        self.AuthorTeamParenthesis = AuthorTeamParenthesis
    def get_AuthorTeam(self):
        return self.AuthorTeam
    def set_AuthorTeam(self, AuthorTeam):
        self.AuthorTeam = AuthorTeam
    def get_CultivarGroupName(self):
        return self.CultivarGroupName
    def set_CultivarGroupName(self, CultivarGroupName):
        self.CultivarGroupName = CultivarGroupName
    def get_CultivarName(self):
        return self.CultivarName
    def set_CultivarName(self, CultivarName):
        self.CultivarName = CultivarName
    def get_TradeDesignationNames(self):
        return self.TradeDesignationNames
    def set_TradeDesignationNames(self, TradeDesignationNames):
        self.TradeDesignationNames = TradeDesignationNames
    def validate_Monomial(self, value):
        result = True
        # Validate type Monomial, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_Epithet(self, value):
        result = True
        # Validate type Epithet, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_RankAbbreviation(self, value):
        result = True
        # Validate type RankAbbreviation, a restriction on xs:Name.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['subgen.', 'sect.', 'subsp.', 'var.', 'subvar.', 'forma', 'f.', 'subforma', 'subf.', 'f.spec.']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on RankAbbreviation' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_String(self, value):
        result = True
        # Validate type String, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on String' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.GenusOrMonomial is not None or
            self.FirstEpithet is not None or
            self.InfraspecificEpithet is not None or
            self.Rank is not None or
            self.HybridFlag is not None or
            self.AuthorTeamParenthesis is not None or
            self.AuthorTeam is not None or
            self.CultivarGroupName is not None or
            self.CultivarName is not None or
            self.TradeDesignationNames is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='NameBotanical', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NameBotanical')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NameBotanical')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NameBotanical', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NameBotanical'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='NameBotanical', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.GenusOrMonomial is not None:
            namespaceprefix_ = self.GenusOrMonomial_nsprefix_ + ':' if (UseCapturedNS_ and self.GenusOrMonomial_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGenusOrMonomial>%s</%sGenusOrMonomial>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.GenusOrMonomial), input_name='GenusOrMonomial')), namespaceprefix_ , eol_))
        if self.FirstEpithet is not None:
            namespaceprefix_ = self.FirstEpithet_nsprefix_ + ':' if (UseCapturedNS_ and self.FirstEpithet_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFirstEpithet>%s</%sFirstEpithet>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.FirstEpithet), input_name='FirstEpithet')), namespaceprefix_ , eol_))
        if self.InfraspecificEpithet is not None:
            namespaceprefix_ = self.InfraspecificEpithet_nsprefix_ + ':' if (UseCapturedNS_ and self.InfraspecificEpithet_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sInfraspecificEpithet>%s</%sInfraspecificEpithet>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.InfraspecificEpithet), input_name='InfraspecificEpithet')), namespaceprefix_ , eol_))
        if self.Rank is not None:
            namespaceprefix_ = self.Rank_nsprefix_ + ':' if (UseCapturedNS_ and self.Rank_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRank>%s</%sRank>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Rank), input_name='Rank')), namespaceprefix_ , eol_))
        if self.HybridFlag is not None:
            namespaceprefix_ = self.HybridFlag_nsprefix_ + ':' if (UseCapturedNS_ and self.HybridFlag_nsprefix_) else ''
            self.HybridFlag.export(outfile, level, namespaceprefix_, namespacedef_='', name_='HybridFlag', pretty_print=pretty_print)
        if self.AuthorTeamParenthesis is not None:
            namespaceprefix_ = self.AuthorTeamParenthesis_nsprefix_ + ':' if (UseCapturedNS_ and self.AuthorTeamParenthesis_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAuthorTeamParenthesis>%s</%sAuthorTeamParenthesis>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.AuthorTeamParenthesis), input_name='AuthorTeamParenthesis')), namespaceprefix_ , eol_))
        if self.AuthorTeam is not None:
            namespaceprefix_ = self.AuthorTeam_nsprefix_ + ':' if (UseCapturedNS_ and self.AuthorTeam_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAuthorTeam>%s</%sAuthorTeam>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.AuthorTeam), input_name='AuthorTeam')), namespaceprefix_ , eol_))
        if self.CultivarGroupName is not None:
            namespaceprefix_ = self.CultivarGroupName_nsprefix_ + ':' if (UseCapturedNS_ and self.CultivarGroupName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCultivarGroupName>%s</%sCultivarGroupName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CultivarGroupName), input_name='CultivarGroupName')), namespaceprefix_ , eol_))
        if self.CultivarName is not None:
            namespaceprefix_ = self.CultivarName_nsprefix_ + ':' if (UseCapturedNS_ and self.CultivarName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCultivarName>%s</%sCultivarName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CultivarName), input_name='CultivarName')), namespaceprefix_ , eol_))
        if self.TradeDesignationNames is not None:
            namespaceprefix_ = self.TradeDesignationNames_nsprefix_ + ':' if (UseCapturedNS_ and self.TradeDesignationNames_nsprefix_) else ''
            self.TradeDesignationNames.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TradeDesignationNames', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'GenusOrMonomial':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'GenusOrMonomial')
            value_ = self.gds_validate_string(value_, node, 'GenusOrMonomial')
            self.GenusOrMonomial = value_
            self.GenusOrMonomial_nsprefix_ = child_.prefix
            # validate type Monomial
            self.validate_Monomial(self.GenusOrMonomial)
        elif nodeName_ == 'FirstEpithet':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'FirstEpithet')
            value_ = self.gds_validate_string(value_, node, 'FirstEpithet')
            self.FirstEpithet = value_
            self.FirstEpithet_nsprefix_ = child_.prefix
            # validate type Epithet
            self.validate_Epithet(self.FirstEpithet)
        elif nodeName_ == 'InfraspecificEpithet':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'InfraspecificEpithet')
            value_ = self.gds_validate_string(value_, node, 'InfraspecificEpithet')
            self.InfraspecificEpithet = value_
            self.InfraspecificEpithet_nsprefix_ = child_.prefix
            # validate type Epithet
            self.validate_Epithet(self.InfraspecificEpithet)
        elif nodeName_ == 'Rank':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Rank')
            value_ = self.gds_validate_string(value_, node, 'Rank')
            self.Rank = value_
            self.Rank_nsprefix_ = child_.prefix
            # validate type RankAbbreviation
            self.validate_RankAbbreviation(self.Rank)
        elif nodeName_ == 'HybridFlag':
            obj_ = HybridFlagType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.HybridFlag = obj_
            obj_.original_tagname_ = 'HybridFlag'
        elif nodeName_ == 'AuthorTeamParenthesis':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'AuthorTeamParenthesis')
            value_ = self.gds_validate_string(value_, node, 'AuthorTeamParenthesis')
            self.AuthorTeamParenthesis = value_
            self.AuthorTeamParenthesis_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.AuthorTeamParenthesis)
        elif nodeName_ == 'AuthorTeam':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'AuthorTeam')
            value_ = self.gds_validate_string(value_, node, 'AuthorTeam')
            self.AuthorTeam = value_
            self.AuthorTeam_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.AuthorTeam)
        elif nodeName_ == 'CultivarGroupName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CultivarGroupName')
            value_ = self.gds_validate_string(value_, node, 'CultivarGroupName')
            self.CultivarGroupName = value_
            self.CultivarGroupName_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.CultivarGroupName)
        elif nodeName_ == 'CultivarName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CultivarName')
            value_ = self.gds_validate_string(value_, node, 'CultivarName')
            self.CultivarName = value_
            self.CultivarName_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.CultivarName)
        elif nodeName_ == 'TradeDesignationNames':
            obj_ = TradeDesignationNamesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TradeDesignationNames = obj_
            obj_.original_tagname_ = 'TradeDesignationNames'
# end class NameBotanical


class NameViral(GeneratedsSuper):
    """An atomized scientific name under the International Code of Virus
    Classification and Nomenclature"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('GenusOrMonomial', ['Monomial', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'GenusOrMonomial', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/genusOrMonomial', 'type': 'xs:string'}, None),
        MemberSpec_('ViralSpeciesDesignation', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'ViralSpeciesDesignation', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/viralSpeciesDesignation', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('Acronym', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'Acronym', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/acronym', 'type': 'xs:normalizedString'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, GenusOrMonomial=None, ViralSpeciesDesignation=None, Acronym=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.GenusOrMonomial = GenusOrMonomial
        self.validate_Monomial(self.GenusOrMonomial)
        self.GenusOrMonomial_nsprefix_ = None
        self.ViralSpeciesDesignation = ViralSpeciesDesignation
        self.validate_String(self.ViralSpeciesDesignation)
        self.ViralSpeciesDesignation_nsprefix_ = None
        self.Acronym = Acronym
        self.validate_String(self.Acronym)
        self.Acronym_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NameViral)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NameViral.subclass:
            return NameViral.subclass(*args_, **kwargs_)
        else:
            return NameViral(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_GenusOrMonomial(self):
        return self.GenusOrMonomial
    def set_GenusOrMonomial(self, GenusOrMonomial):
        self.GenusOrMonomial = GenusOrMonomial
    def get_ViralSpeciesDesignation(self):
        return self.ViralSpeciesDesignation
    def set_ViralSpeciesDesignation(self, ViralSpeciesDesignation):
        self.ViralSpeciesDesignation = ViralSpeciesDesignation
    def get_Acronym(self):
        return self.Acronym
    def set_Acronym(self, Acronym):
        self.Acronym = Acronym
    def validate_Monomial(self, value):
        result = True
        # Validate type Monomial, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_String(self, value):
        result = True
        # Validate type String, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on String' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.GenusOrMonomial is not None or
            self.ViralSpeciesDesignation is not None or
            self.Acronym is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='NameViral', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NameViral')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NameViral')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NameViral', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NameViral'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='NameViral', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.GenusOrMonomial is not None:
            namespaceprefix_ = self.GenusOrMonomial_nsprefix_ + ':' if (UseCapturedNS_ and self.GenusOrMonomial_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGenusOrMonomial>%s</%sGenusOrMonomial>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.GenusOrMonomial), input_name='GenusOrMonomial')), namespaceprefix_ , eol_))
        if self.ViralSpeciesDesignation is not None:
            namespaceprefix_ = self.ViralSpeciesDesignation_nsprefix_ + ':' if (UseCapturedNS_ and self.ViralSpeciesDesignation_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sViralSpeciesDesignation>%s</%sViralSpeciesDesignation>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ViralSpeciesDesignation), input_name='ViralSpeciesDesignation')), namespaceprefix_ , eol_))
        if self.Acronym is not None:
            namespaceprefix_ = self.Acronym_nsprefix_ + ':' if (UseCapturedNS_ and self.Acronym_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAcronym>%s</%sAcronym>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Acronym), input_name='Acronym')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'GenusOrMonomial':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'GenusOrMonomial')
            value_ = self.gds_validate_string(value_, node, 'GenusOrMonomial')
            self.GenusOrMonomial = value_
            self.GenusOrMonomial_nsprefix_ = child_.prefix
            # validate type Monomial
            self.validate_Monomial(self.GenusOrMonomial)
        elif nodeName_ == 'ViralSpeciesDesignation':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ViralSpeciesDesignation')
            value_ = self.gds_validate_string(value_, node, 'ViralSpeciesDesignation')
            self.ViralSpeciesDesignation = value_
            self.ViralSpeciesDesignation_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.ViralSpeciesDesignation)
        elif nodeName_ == 'Acronym':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Acronym')
            value_ = self.gds_validate_string(value_, node, 'Acronym')
            self.Acronym = value_
            self.Acronym_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.Acronym)
# end class NameViral


class NameZoological(GeneratedsSuper):
    """An atomized scientific name under the International Code of Zoological
    Nomenclature"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('GenusOrMonomial', ['Monomial', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'GenusOrMonomial', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/genusOrMonomial', 'type': 'xs:string'}, None),
        MemberSpec_('Subgenus', ['Monomial', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'Subgenus', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/subgenus', 'type': 'xs:string'}, None),
        MemberSpec_('SpeciesEpithet', ['Epithet', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'SpeciesEpithet', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/speciesEpithet', 'type': 'xs:string'}, None),
        MemberSpec_('SubspeciesEpithet', ['Epithet', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'SubspeciesEpithet', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/subspeciesEpithet', 'type': 'xs:string'}, None),
        MemberSpec_('AuthorTeamOriginalAndYear', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'AuthorTeamOriginalAndYear', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/authorTeamOriginalAndYear', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('AuthorTeamParenthesisAndYear', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'AuthorTeamParenthesisAndYear', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/authorTeamParenthesisAndYear', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('CombinationAuthorTeamAndYear', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'CombinationAuthorTeamAndYear', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/combinationAuthorTeamAndYear', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('Breed', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'Breed', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/breed', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('NamedIndividual', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'NamedIndividual', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/namedIndividual', 'type': 'xs:normalizedString'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, GenusOrMonomial=None, Subgenus=None, SpeciesEpithet=None, SubspeciesEpithet=None, AuthorTeamOriginalAndYear=None, AuthorTeamParenthesisAndYear=None, CombinationAuthorTeamAndYear=None, Breed=None, NamedIndividual=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.GenusOrMonomial = GenusOrMonomial
        self.validate_Monomial(self.GenusOrMonomial)
        self.GenusOrMonomial_nsprefix_ = None
        self.Subgenus = Subgenus
        self.validate_Monomial(self.Subgenus)
        self.Subgenus_nsprefix_ = None
        self.SpeciesEpithet = SpeciesEpithet
        self.validate_Epithet(self.SpeciesEpithet)
        self.SpeciesEpithet_nsprefix_ = None
        self.SubspeciesEpithet = SubspeciesEpithet
        self.validate_Epithet(self.SubspeciesEpithet)
        self.SubspeciesEpithet_nsprefix_ = None
        self.AuthorTeamOriginalAndYear = AuthorTeamOriginalAndYear
        self.validate_String(self.AuthorTeamOriginalAndYear)
        self.AuthorTeamOriginalAndYear_nsprefix_ = None
        self.AuthorTeamParenthesisAndYear = AuthorTeamParenthesisAndYear
        self.validate_String(self.AuthorTeamParenthesisAndYear)
        self.AuthorTeamParenthesisAndYear_nsprefix_ = None
        self.CombinationAuthorTeamAndYear = CombinationAuthorTeamAndYear
        self.validate_String(self.CombinationAuthorTeamAndYear)
        self.CombinationAuthorTeamAndYear_nsprefix_ = None
        self.Breed = Breed
        self.validate_String(self.Breed)
        self.Breed_nsprefix_ = None
        self.NamedIndividual = NamedIndividual
        self.validate_String(self.NamedIndividual)
        self.NamedIndividual_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NameZoological)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NameZoological.subclass:
            return NameZoological.subclass(*args_, **kwargs_)
        else:
            return NameZoological(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_GenusOrMonomial(self):
        return self.GenusOrMonomial
    def set_GenusOrMonomial(self, GenusOrMonomial):
        self.GenusOrMonomial = GenusOrMonomial
    def get_Subgenus(self):
        return self.Subgenus
    def set_Subgenus(self, Subgenus):
        self.Subgenus = Subgenus
    def get_SpeciesEpithet(self):
        return self.SpeciesEpithet
    def set_SpeciesEpithet(self, SpeciesEpithet):
        self.SpeciesEpithet = SpeciesEpithet
    def get_SubspeciesEpithet(self):
        return self.SubspeciesEpithet
    def set_SubspeciesEpithet(self, SubspeciesEpithet):
        self.SubspeciesEpithet = SubspeciesEpithet
    def get_AuthorTeamOriginalAndYear(self):
        return self.AuthorTeamOriginalAndYear
    def set_AuthorTeamOriginalAndYear(self, AuthorTeamOriginalAndYear):
        self.AuthorTeamOriginalAndYear = AuthorTeamOriginalAndYear
    def get_AuthorTeamParenthesisAndYear(self):
        return self.AuthorTeamParenthesisAndYear
    def set_AuthorTeamParenthesisAndYear(self, AuthorTeamParenthesisAndYear):
        self.AuthorTeamParenthesisAndYear = AuthorTeamParenthesisAndYear
    def get_CombinationAuthorTeamAndYear(self):
        return self.CombinationAuthorTeamAndYear
    def set_CombinationAuthorTeamAndYear(self, CombinationAuthorTeamAndYear):
        self.CombinationAuthorTeamAndYear = CombinationAuthorTeamAndYear
    def get_Breed(self):
        return self.Breed
    def set_Breed(self, Breed):
        self.Breed = Breed
    def get_NamedIndividual(self):
        return self.NamedIndividual
    def set_NamedIndividual(self, NamedIndividual):
        self.NamedIndividual = NamedIndividual
    def validate_Monomial(self, value):
        result = True
        # Validate type Monomial, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_Epithet(self, value):
        result = True
        # Validate type Epithet, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_String(self, value):
        result = True
        # Validate type String, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on String' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.GenusOrMonomial is not None or
            self.Subgenus is not None or
            self.SpeciesEpithet is not None or
            self.SubspeciesEpithet is not None or
            self.AuthorTeamOriginalAndYear is not None or
            self.AuthorTeamParenthesisAndYear is not None or
            self.CombinationAuthorTeamAndYear is not None or
            self.Breed is not None or
            self.NamedIndividual is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='NameZoological', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NameZoological')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NameZoological')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NameZoological', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NameZoological'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='NameZoological', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.GenusOrMonomial is not None:
            namespaceprefix_ = self.GenusOrMonomial_nsprefix_ + ':' if (UseCapturedNS_ and self.GenusOrMonomial_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGenusOrMonomial>%s</%sGenusOrMonomial>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.GenusOrMonomial), input_name='GenusOrMonomial')), namespaceprefix_ , eol_))
        if self.Subgenus is not None:
            namespaceprefix_ = self.Subgenus_nsprefix_ + ':' if (UseCapturedNS_ and self.Subgenus_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSubgenus>%s</%sSubgenus>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Subgenus), input_name='Subgenus')), namespaceprefix_ , eol_))
        if self.SpeciesEpithet is not None:
            namespaceprefix_ = self.SpeciesEpithet_nsprefix_ + ':' if (UseCapturedNS_ and self.SpeciesEpithet_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSpeciesEpithet>%s</%sSpeciesEpithet>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SpeciesEpithet), input_name='SpeciesEpithet')), namespaceprefix_ , eol_))
        if self.SubspeciesEpithet is not None:
            namespaceprefix_ = self.SubspeciesEpithet_nsprefix_ + ':' if (UseCapturedNS_ and self.SubspeciesEpithet_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSubspeciesEpithet>%s</%sSubspeciesEpithet>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SubspeciesEpithet), input_name='SubspeciesEpithet')), namespaceprefix_ , eol_))
        if self.AuthorTeamOriginalAndYear is not None:
            namespaceprefix_ = self.AuthorTeamOriginalAndYear_nsprefix_ + ':' if (UseCapturedNS_ and self.AuthorTeamOriginalAndYear_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAuthorTeamOriginalAndYear>%s</%sAuthorTeamOriginalAndYear>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.AuthorTeamOriginalAndYear), input_name='AuthorTeamOriginalAndYear')), namespaceprefix_ , eol_))
        if self.AuthorTeamParenthesisAndYear is not None:
            namespaceprefix_ = self.AuthorTeamParenthesisAndYear_nsprefix_ + ':' if (UseCapturedNS_ and self.AuthorTeamParenthesisAndYear_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAuthorTeamParenthesisAndYear>%s</%sAuthorTeamParenthesisAndYear>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.AuthorTeamParenthesisAndYear), input_name='AuthorTeamParenthesisAndYear')), namespaceprefix_ , eol_))
        if self.CombinationAuthorTeamAndYear is not None:
            namespaceprefix_ = self.CombinationAuthorTeamAndYear_nsprefix_ + ':' if (UseCapturedNS_ and self.CombinationAuthorTeamAndYear_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCombinationAuthorTeamAndYear>%s</%sCombinationAuthorTeamAndYear>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CombinationAuthorTeamAndYear), input_name='CombinationAuthorTeamAndYear')), namespaceprefix_ , eol_))
        if self.Breed is not None:
            namespaceprefix_ = self.Breed_nsprefix_ + ':' if (UseCapturedNS_ and self.Breed_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBreed>%s</%sBreed>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Breed), input_name='Breed')), namespaceprefix_ , eol_))
        if self.NamedIndividual is not None:
            namespaceprefix_ = self.NamedIndividual_nsprefix_ + ':' if (UseCapturedNS_ and self.NamedIndividual_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNamedIndividual>%s</%sNamedIndividual>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NamedIndividual), input_name='NamedIndividual')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'GenusOrMonomial':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'GenusOrMonomial')
            value_ = self.gds_validate_string(value_, node, 'GenusOrMonomial')
            self.GenusOrMonomial = value_
            self.GenusOrMonomial_nsprefix_ = child_.prefix
            # validate type Monomial
            self.validate_Monomial(self.GenusOrMonomial)
        elif nodeName_ == 'Subgenus':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Subgenus')
            value_ = self.gds_validate_string(value_, node, 'Subgenus')
            self.Subgenus = value_
            self.Subgenus_nsprefix_ = child_.prefix
            # validate type Monomial
            self.validate_Monomial(self.Subgenus)
        elif nodeName_ == 'SpeciesEpithet':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SpeciesEpithet')
            value_ = self.gds_validate_string(value_, node, 'SpeciesEpithet')
            self.SpeciesEpithet = value_
            self.SpeciesEpithet_nsprefix_ = child_.prefix
            # validate type Epithet
            self.validate_Epithet(self.SpeciesEpithet)
        elif nodeName_ == 'SubspeciesEpithet':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SubspeciesEpithet')
            value_ = self.gds_validate_string(value_, node, 'SubspeciesEpithet')
            self.SubspeciesEpithet = value_
            self.SubspeciesEpithet_nsprefix_ = child_.prefix
            # validate type Epithet
            self.validate_Epithet(self.SubspeciesEpithet)
        elif nodeName_ == 'AuthorTeamOriginalAndYear':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'AuthorTeamOriginalAndYear')
            value_ = self.gds_validate_string(value_, node, 'AuthorTeamOriginalAndYear')
            self.AuthorTeamOriginalAndYear = value_
            self.AuthorTeamOriginalAndYear_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.AuthorTeamOriginalAndYear)
        elif nodeName_ == 'AuthorTeamParenthesisAndYear':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'AuthorTeamParenthesisAndYear')
            value_ = self.gds_validate_string(value_, node, 'AuthorTeamParenthesisAndYear')
            self.AuthorTeamParenthesisAndYear = value_
            self.AuthorTeamParenthesisAndYear_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.AuthorTeamParenthesisAndYear)
        elif nodeName_ == 'CombinationAuthorTeamAndYear':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CombinationAuthorTeamAndYear')
            value_ = self.gds_validate_string(value_, node, 'CombinationAuthorTeamAndYear')
            self.CombinationAuthorTeamAndYear = value_
            self.CombinationAuthorTeamAndYear_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.CombinationAuthorTeamAndYear)
        elif nodeName_ == 'Breed':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Breed')
            value_ = self.gds_validate_string(value_, node, 'Breed')
            self.Breed = value_
            self.Breed_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.Breed)
        elif nodeName_ == 'NamedIndividual':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NamedIndividual')
            value_ = self.gds_validate_string(value_, node, 'NamedIndividual')
            self.NamedIndividual = value_
            self.NamedIndividual_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.NamedIndividual)
# end class NameZoological


class ScientificName(GeneratedsSuper):
    """Name of the taxon identified, formed according to the different Codes of
    Nomenclature which apply to scientific names."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('FullScientificName', ['String', 'xs:normalizedString'], 0, 0, {'name': 'FullScientificName', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/fullScientificName', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('NameAtomized', 'NameAtomizedType', 0, 1, {'minOccurs': '0', 'name': 'NameAtomized', 'type': 'NameAtomizedType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, FullScientificName=None, NameAtomized=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.FullScientificName = FullScientificName
        self.validate_String(self.FullScientificName)
        self.FullScientificName_nsprefix_ = None
        self.NameAtomized = NameAtomized
        self.NameAtomized_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ScientificName)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ScientificName.subclass:
            return ScientificName.subclass(*args_, **kwargs_)
        else:
            return ScientificName(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_FullScientificName(self):
        return self.FullScientificName
    def set_FullScientificName(self, FullScientificName):
        self.FullScientificName = FullScientificName
    def get_NameAtomized(self):
        return self.NameAtomized
    def set_NameAtomized(self, NameAtomized):
        self.NameAtomized = NameAtomized
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_String(self, value):
        result = True
        # Validate type String, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on String' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.FullScientificName is not None or
            self.NameAtomized is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='ScientificName', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ScientificName')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ScientificName')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ScientificName', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ScientificName'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='ScientificName', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FullScientificName is not None:
            namespaceprefix_ = self.FullScientificName_nsprefix_ + ':' if (UseCapturedNS_ and self.FullScientificName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFullScientificName>%s</%sFullScientificName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.FullScientificName), input_name='FullScientificName')), namespaceprefix_ , eol_))
        if self.NameAtomized is not None:
            namespaceprefix_ = self.NameAtomized_nsprefix_ + ':' if (UseCapturedNS_ and self.NameAtomized_nsprefix_) else ''
            self.NameAtomized.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NameAtomized', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'FullScientificName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'FullScientificName')
            value_ = self.gds_validate_string(value_, node, 'FullScientificName')
            self.FullScientificName = value_
            self.FullScientificName_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.FullScientificName)
        elif nodeName_ == 'NameAtomized':
            obj_ = NameAtomizedType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NameAtomized = obj_
            obj_.original_tagname_ = 'NameAtomized'
# end class ScientificName


class ScientificNameIdentified(ScientificName):
    """Name of the taxon identified, formed according to the different Codes of
    Nomenclature which apply to scientific names - with additional elements
    for suffixes or other expressions commonly used in taxonomic
    identifications."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('IdentificationQualifier', 'IdentificationQualifierType', 0, 1, {'minOccurs': '0', 'name': 'IdentificationQualifier', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/identificationQualifier', 'type': 'IdentificationQualifierType'}, None),
        MemberSpec_('NameAddendum', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'NameAddendum', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/nameAddendum', 'type': 'xs:normalizedString'}, None),
    ]
    subclass = None
    superclass = ScientificName
    def __init__(self, FullScientificName=None, NameAtomized=None, IdentificationQualifier=None, NameAddendum=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ScientificNameIdentified, self).__init__(FullScientificName, NameAtomized,  **kwargs_)
        self.IdentificationQualifier = IdentificationQualifier
        self.IdentificationQualifier_nsprefix_ = None
        self.NameAddendum = NameAddendum
        self.validate_String(self.NameAddendum)
        self.NameAddendum_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ScientificNameIdentified)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ScientificNameIdentified.subclass:
            return ScientificNameIdentified.subclass(*args_, **kwargs_)
        else:
            return ScientificNameIdentified(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_IdentificationQualifier(self):
        return self.IdentificationQualifier
    def set_IdentificationQualifier(self, IdentificationQualifier):
        self.IdentificationQualifier = IdentificationQualifier
    def get_NameAddendum(self):
        return self.NameAddendum
    def set_NameAddendum(self, NameAddendum):
        self.NameAddendum = NameAddendum
    def validate_String(self, value):
        result = True
        # Validate type String, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on String' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.IdentificationQualifier is not None or
            self.NameAddendum is not None or
            super(ScientificNameIdentified, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='ScientificNameIdentified', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ScientificNameIdentified')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ScientificNameIdentified')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ScientificNameIdentified', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ScientificNameIdentified'):
        super(ScientificNameIdentified, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ScientificNameIdentified')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='ScientificNameIdentified', fromsubclass_=False, pretty_print=True):
        super(ScientificNameIdentified, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.IdentificationQualifier is not None:
            namespaceprefix_ = self.IdentificationQualifier_nsprefix_ + ':' if (UseCapturedNS_ and self.IdentificationQualifier_nsprefix_) else ''
            self.IdentificationQualifier.export(outfile, level, namespaceprefix_, namespacedef_='', name_='IdentificationQualifier', pretty_print=pretty_print)
        if self.NameAddendum is not None:
            namespaceprefix_ = self.NameAddendum_nsprefix_ + ':' if (UseCapturedNS_ and self.NameAddendum_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNameAddendum>%s</%sNameAddendum>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NameAddendum), input_name='NameAddendum')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ScientificNameIdentified, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'IdentificationQualifier':
            obj_ = IdentificationQualifierType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IdentificationQualifier = obj_
            obj_.original_tagname_ = 'IdentificationQualifier'
        elif nodeName_ == 'NameAddendum':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NameAddendum')
            value_ = self.gds_validate_string(value_, node, 'NameAddendum')
            self.NameAddendum = value_
            self.NameAddendum_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.NameAddendum)
        super(ScientificNameIdentified, self).buildChildren(child_, node, nodeName_, True)
# end class ScientificNameIdentified


class HigherTaxon(GeneratedsSuper):
    """Taxon name used to further classify the identification result."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('HigherTaxonName', ['Monomial', 'xs:string'], 0, 0, {'name': 'HigherTaxonName', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/HigherTaxonName', 'type': 'xs:string'}, None),
        MemberSpec_('HigherTaxonRank', ['HigherTaxonRankEnum', 'xs:Name'], 0, 1, {'minOccurs': '0', 'name': 'HigherTaxonRank', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/HigherTaxonRank', 'type': 'xs:Name'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, HigherTaxonName=None, HigherTaxonRank=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.HigherTaxonName = HigherTaxonName
        self.validate_Monomial(self.HigherTaxonName)
        self.HigherTaxonName_nsprefix_ = None
        self.HigherTaxonRank = HigherTaxonRank
        self.validate_HigherTaxonRankEnum(self.HigherTaxonRank)
        self.HigherTaxonRank_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HigherTaxon)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HigherTaxon.subclass:
            return HigherTaxon.subclass(*args_, **kwargs_)
        else:
            return HigherTaxon(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_HigherTaxonName(self):
        return self.HigherTaxonName
    def set_HigherTaxonName(self, HigherTaxonName):
        self.HigherTaxonName = HigherTaxonName
    def get_HigherTaxonRank(self):
        return self.HigherTaxonRank
    def set_HigherTaxonRank(self, HigherTaxonRank):
        self.HigherTaxonRank = HigherTaxonRank
    def validate_Monomial(self, value):
        result = True
        # Validate type Monomial, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_HigherTaxonRankEnum(self, value):
        result = True
        # Validate type HigherTaxonRankEnum, a restriction on xs:Name.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['regnum', 'subregnum', 'superphylum', 'phylum', 'subphylum', 'superclassis', 'classis', 'subclassis', 'supercohors', 'cohors', 'subcohors', 'superordo', 'ordo', 'subordo', 'superfamilia', 'familia', 'subfamilia', 'tribus', 'genusgroup', 'unranked']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on HigherTaxonRankEnum' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.HigherTaxonName is not None or
            self.HigherTaxonRank is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='HigherTaxon', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HigherTaxon')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HigherTaxon')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='HigherTaxon', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='HigherTaxon'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='HigherTaxon', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.HigherTaxonName is not None:
            namespaceprefix_ = self.HigherTaxonName_nsprefix_ + ':' if (UseCapturedNS_ and self.HigherTaxonName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sHigherTaxonName>%s</%sHigherTaxonName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.HigherTaxonName), input_name='HigherTaxonName')), namespaceprefix_ , eol_))
        if self.HigherTaxonRank is not None:
            namespaceprefix_ = self.HigherTaxonRank_nsprefix_ + ':' if (UseCapturedNS_ and self.HigherTaxonRank_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sHigherTaxonRank>%s</%sHigherTaxonRank>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.HigherTaxonRank), input_name='HigherTaxonRank')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'HigherTaxonName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'HigherTaxonName')
            value_ = self.gds_validate_string(value_, node, 'HigherTaxonName')
            self.HigherTaxonName = value_
            self.HigherTaxonName_nsprefix_ = child_.prefix
            # validate type Monomial
            self.validate_Monomial(self.HigherTaxonName)
        elif nodeName_ == 'HigherTaxonRank':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'HigherTaxonRank')
            value_ = self.gds_validate_string(value_, node, 'HigherTaxonRank')
            self.HigherTaxonRank = value_
            self.HigherTaxonRank_nsprefix_ = child_.prefix
            # validate type HigherTaxonRankEnum
            self.validate_HigherTaxonRankEnum(self.HigherTaxonRank)
# end class HigherTaxon


class Permit(GeneratedsSuper):
    """Container element for information on permits related to the Gathering
    event"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('Type', ['TypeType', 'xs:string'], 0, 0, {'name': 'Type', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/PermitType', 'type': 'xs:string'}, None),
        MemberSpec_('Status', ['StatusType', 'xs:string'], 0, 0, {'name': 'Status', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/PermitStatus', 'type': 'xs:string'}, None),
        MemberSpec_('Details', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'Details', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Permit-Details', 'type': 'StringL'}, None),
        MemberSpec_('ResourceURI', 'xs:anyURI', 0, 1, {'minOccurs': '0', 'name': 'ResourceURI', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Permit-ResourceURI', 'type': 'xs:anyURI'}, None),
        MemberSpec_('WebsiteURL', 'xs:anyURI', 0, 1, {'minOccurs': '0', 'name': 'WebsiteURL', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Permit-WebsiteURL', 'type': 'xs:anyURI'}, None),
        MemberSpec_('Text', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'Text', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Permit-Text', 'type': 'StringL'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, Type=None, Status=None, Details=None, ResourceURI=None, WebsiteURL=None, Text=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Type = Type
        self.validate_TypeType(self.Type)
        self.Type_nsprefix_ = None
        self.Status = Status
        self.validate_StatusType(self.Status)
        self.Status_nsprefix_ = None
        self.Details = Details
        self.Details_nsprefix_ = None
        self.ResourceURI = ResourceURI
        self.ResourceURI_nsprefix_ = None
        self.WebsiteURL = WebsiteURL
        self.WebsiteURL_nsprefix_ = None
        self.Text = Text
        self.Text_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Permit)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Permit.subclass:
            return Permit.subclass(*args_, **kwargs_)
        else:
            return Permit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Type(self):
        return self.Type
    def set_Type(self, Type):
        self.Type = Type
    def get_Status(self):
        return self.Status
    def set_Status(self, Status):
        self.Status = Status
    def get_Details(self):
        return self.Details
    def set_Details(self, Details):
        self.Details = Details
    def get_ResourceURI(self):
        return self.ResourceURI
    def set_ResourceURI(self, ResourceURI):
        self.ResourceURI = ResourceURI
    def get_WebsiteURL(self):
        return self.WebsiteURL
    def set_WebsiteURL(self, WebsiteURL):
        self.WebsiteURL = WebsiteURL
    def get_Text(self):
        return self.Text
    def set_Text(self, Text):
        self.Text = Text
    def validate_TypeType(self, value):
        result = True
        # Validate type TypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Contract', 'Copyright', 'Data use', 'Exemption Permit', 'Export Permit', 'Genetically Modified Organism', 'Human Pathogens', 'Intellectual Property Rights', 'Internationally Recognized Certificate of Compliance', 'Import Permit', 'Collecting Permit', 'Material Transfer Agreement', 'Memorandum of Cooperation', 'Memorandum of Understanding', 'Patent', 'Phytosanitary', 'Salvage', 'Veterinary Certificate']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TypeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_StatusType(self, value):
        result = True
        # Validate type StatusType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Permit available', 'Permit not required', 'Permit not available', 'Unknown']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on StatusType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.Type is not None or
            self.Status is not None or
            self.Details is not None or
            self.ResourceURI is not None or
            self.WebsiteURL is not None or
            self.Text is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='Permit', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Permit')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Permit')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Permit', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Permit'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='Permit', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Type is not None:
            namespaceprefix_ = self.Type_nsprefix_ + ':' if (UseCapturedNS_ and self.Type_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sType>%s</%sType>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Type), input_name='Type')), namespaceprefix_ , eol_))
        if self.Status is not None:
            namespaceprefix_ = self.Status_nsprefix_ + ':' if (UseCapturedNS_ and self.Status_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStatus>%s</%sStatus>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Status), input_name='Status')), namespaceprefix_ , eol_))
        if self.Details is not None:
            namespaceprefix_ = self.Details_nsprefix_ + ':' if (UseCapturedNS_ and self.Details_nsprefix_) else ''
            self.Details.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Details', pretty_print=pretty_print)
        if self.ResourceURI is not None:
            namespaceprefix_ = self.ResourceURI_nsprefix_ + ':' if (UseCapturedNS_ and self.ResourceURI_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sResourceURI>%s</%sResourceURI>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ResourceURI), input_name='ResourceURI')), namespaceprefix_ , eol_))
        if self.WebsiteURL is not None:
            namespaceprefix_ = self.WebsiteURL_nsprefix_ + ':' if (UseCapturedNS_ and self.WebsiteURL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sWebsiteURL>%s</%sWebsiteURL>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.WebsiteURL), input_name='WebsiteURL')), namespaceprefix_ , eol_))
        if self.Text is not None:
            namespaceprefix_ = self.Text_nsprefix_ + ':' if (UseCapturedNS_ and self.Text_nsprefix_) else ''
            self.Text.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Text', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Type':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Type')
            value_ = self.gds_validate_string(value_, node, 'Type')
            self.Type = value_
            self.Type_nsprefix_ = child_.prefix
            # validate type TypeType
            self.validate_TypeType(self.Type)
        elif nodeName_ == 'Status':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Status')
            value_ = self.gds_validate_string(value_, node, 'Status')
            self.Status = value_
            self.Status_nsprefix_ = child_.prefix
            # validate type StatusType
            self.validate_StatusType(self.Status)
        elif nodeName_ == 'Details':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Details = obj_
            obj_.original_tagname_ = 'Details'
        elif nodeName_ == 'ResourceURI':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ResourceURI')
            value_ = self.gds_validate_string(value_, node, 'ResourceURI')
            self.ResourceURI = value_
            self.ResourceURI_nsprefix_ = child_.prefix
        elif nodeName_ == 'WebsiteURL':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'WebsiteURL')
            value_ = self.gds_validate_string(value_, node, 'WebsiteURL')
            self.WebsiteURL = value_
            self.WebsiteURL_nsprefix_ = child_.prefix
        elif nodeName_ == 'Text':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Text = obj_
            obj_.original_tagname_ = 'Text'
# end class Permit


class DataSetType(GeneratedsSuper):
    """A dataset containing unit data and their shared metadata elements."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('GUID', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'GUID', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/guid http://rs.tdwg.org/abcd/mappings/DataSet-GUID', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('ID', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'ID', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/id http://rs.tdwg.org/abcd/mappings/DataSet-ID', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('ResourceURIs', 'ResourceURIsType', 0, 1, {'minOccurs': '0', 'name': 'ResourceURIs', 'type': 'ResourceURIsType'}, None),
        MemberSpec_('TechnicalContacts', 'TechnicalContactsType', 0, 1, {'minOccurs': '0', 'name': 'TechnicalContacts', 'type': 'TechnicalContactsType'}, None),
        MemberSpec_('ContentContacts', 'ContentContactsType', 0, 0, {'name': 'ContentContacts', 'type': 'ContentContactsType'}, None),
        MemberSpec_('DataCenter', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'DataCenter', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/dataCenter', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('OtherProviders', 'OtherProvidersType', 0, 1, {'minOccurs': '0', 'name': 'OtherProviders', 'type': 'OtherProvidersType'}, None),
        MemberSpec_('Metadata', 'ContentMetadata', 0, 0, {'name': 'Metadata', 'type': 'ContentMetadata'}, None),
        MemberSpec_('Units', 'UnitsType', 0, 0, {'name': 'Units', 'type': 'UnitsType'}, None),
        MemberSpec_('DataSetExtension', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'DataSetExtension', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, GUID=None, ID=None, ResourceURIs=None, TechnicalContacts=None, ContentContacts=None, DataCenter=None, OtherProviders=None, Metadata=None, Units=None, DataSetExtension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.GUID = GUID
        self.validate_String(self.GUID)
        self.GUID_nsprefix_ = None
        self.ID = ID
        self.validate_String(self.ID)
        self.ID_nsprefix_ = None
        self.ResourceURIs = ResourceURIs
        self.ResourceURIs_nsprefix_ = None
        self.TechnicalContacts = TechnicalContacts
        self.TechnicalContacts_nsprefix_ = None
        self.ContentContacts = ContentContacts
        self.ContentContacts_nsprefix_ = None
        self.DataCenter = DataCenter
        self.validate_String(self.DataCenter)
        self.DataCenter_nsprefix_ = None
        self.OtherProviders = OtherProviders
        self.OtherProviders_nsprefix_ = None
        self.Metadata = Metadata
        self.Metadata_nsprefix_ = None
        self.Units = Units
        self.Units_nsprefix_ = None
        self.DataSetExtension = DataSetExtension
        self.DataSetExtension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DataSetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DataSetType.subclass:
            return DataSetType.subclass(*args_, **kwargs_)
        else:
            return DataSetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_GUID(self):
        return self.GUID
    def set_GUID(self, GUID):
        self.GUID = GUID
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_ResourceURIs(self):
        return self.ResourceURIs
    def set_ResourceURIs(self, ResourceURIs):
        self.ResourceURIs = ResourceURIs
    def get_TechnicalContacts(self):
        return self.TechnicalContacts
    def set_TechnicalContacts(self, TechnicalContacts):
        self.TechnicalContacts = TechnicalContacts
    def get_ContentContacts(self):
        return self.ContentContacts
    def set_ContentContacts(self, ContentContacts):
        self.ContentContacts = ContentContacts
    def get_DataCenter(self):
        return self.DataCenter
    def set_DataCenter(self, DataCenter):
        self.DataCenter = DataCenter
    def get_OtherProviders(self):
        return self.OtherProviders
    def set_OtherProviders(self, OtherProviders):
        self.OtherProviders = OtherProviders
    def get_Metadata(self):
        return self.Metadata
    def set_Metadata(self, Metadata):
        self.Metadata = Metadata
    def get_Units(self):
        return self.Units
    def set_Units(self, Units):
        self.Units = Units
    def get_DataSetExtension(self):
        return self.DataSetExtension
    def set_DataSetExtension(self, DataSetExtension):
        self.DataSetExtension = DataSetExtension
    def validate_String(self, value):
        result = True
        # Validate type String, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on String' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.GUID is not None or
            self.ID is not None or
            self.ResourceURIs is not None or
            self.TechnicalContacts is not None or
            self.ContentContacts is not None or
            self.DataCenter is not None or
            self.OtherProviders is not None or
            self.Metadata is not None or
            self.Units is not None or
            self.DataSetExtension is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='DataSetType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DataSetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DataSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DataSetType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DataSetType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='DataSetType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.GUID is not None:
            namespaceprefix_ = self.GUID_nsprefix_ + ':' if (UseCapturedNS_ and self.GUID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGUID>%s</%sGUID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.GUID), input_name='GUID')), namespaceprefix_ , eol_))
        if self.ID is not None:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ID), input_name='ID')), namespaceprefix_ , eol_))
        if self.ResourceURIs is not None:
            namespaceprefix_ = self.ResourceURIs_nsprefix_ + ':' if (UseCapturedNS_ and self.ResourceURIs_nsprefix_) else ''
            self.ResourceURIs.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ResourceURIs', pretty_print=pretty_print)
        if self.TechnicalContacts is not None:
            namespaceprefix_ = self.TechnicalContacts_nsprefix_ + ':' if (UseCapturedNS_ and self.TechnicalContacts_nsprefix_) else ''
            self.TechnicalContacts.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TechnicalContacts', pretty_print=pretty_print)
        if self.ContentContacts is not None:
            namespaceprefix_ = self.ContentContacts_nsprefix_ + ':' if (UseCapturedNS_ and self.ContentContacts_nsprefix_) else ''
            self.ContentContacts.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ContentContacts', pretty_print=pretty_print)
        if self.DataCenter is not None:
            namespaceprefix_ = self.DataCenter_nsprefix_ + ':' if (UseCapturedNS_ and self.DataCenter_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDataCenter>%s</%sDataCenter>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DataCenter), input_name='DataCenter')), namespaceprefix_ , eol_))
        if self.OtherProviders is not None:
            namespaceprefix_ = self.OtherProviders_nsprefix_ + ':' if (UseCapturedNS_ and self.OtherProviders_nsprefix_) else ''
            self.OtherProviders.export(outfile, level, namespaceprefix_, namespacedef_='', name_='OtherProviders', pretty_print=pretty_print)
        if self.Metadata is not None:
            namespaceprefix_ = self.Metadata_nsprefix_ + ':' if (UseCapturedNS_ and self.Metadata_nsprefix_) else ''
            self.Metadata.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Metadata', pretty_print=pretty_print)
        if self.Units is not None:
            namespaceprefix_ = self.Units_nsprefix_ + ':' if (UseCapturedNS_ and self.Units_nsprefix_) else ''
            self.Units.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Units', pretty_print=pretty_print)
        if self.DataSetExtension is not None:
            namespaceprefix_ = self.DataSetExtension_nsprefix_ + ':' if (UseCapturedNS_ and self.DataSetExtension_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDataSetExtension>%s</%sDataSetExtension>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DataSetExtension), input_name='DataSetExtension')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'GUID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'GUID')
            value_ = self.gds_validate_string(value_, node, 'GUID')
            self.GUID = value_
            self.GUID_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.GUID)
        elif nodeName_ == 'ID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ID')
            value_ = self.gds_validate_string(value_, node, 'ID')
            self.ID = value_
            self.ID_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.ID)
        elif nodeName_ == 'ResourceURIs':
            obj_ = ResourceURIsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ResourceURIs = obj_
            obj_.original_tagname_ = 'ResourceURIs'
        elif nodeName_ == 'TechnicalContacts':
            obj_ = TechnicalContactsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TechnicalContacts = obj_
            obj_.original_tagname_ = 'TechnicalContacts'
        elif nodeName_ == 'ContentContacts':
            obj_ = ContentContactsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ContentContacts = obj_
            obj_.original_tagname_ = 'ContentContacts'
        elif nodeName_ == 'DataCenter':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DataCenter')
            value_ = self.gds_validate_string(value_, node, 'DataCenter')
            self.DataCenter = value_
            self.DataCenter_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.DataCenter)
        elif nodeName_ == 'OtherProviders':
            obj_ = OtherProvidersType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OtherProviders = obj_
            obj_.original_tagname_ = 'OtherProviders'
        elif nodeName_ == 'Metadata':
            obj_ = ContentMetadata.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Metadata = obj_
            obj_.original_tagname_ = 'Metadata'
        elif nodeName_ == 'Units':
            obj_ = UnitsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Units = obj_
            obj_.original_tagname_ = 'Units'
        elif nodeName_ == 'DataSetExtension':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DataSetExtension')
            value_ = self.gds_validate_string(value_, node, 'DataSetExtension')
            self.DataSetExtension = value_
            self.DataSetExtension_nsprefix_ = child_.prefix
# end class DataSetType


class ResourceURIsType(GeneratedsSuper):
    """Preferably resolvable URIs of the association."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('ResourceURI', 'xs:anyURI', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'ResourceURI', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/resourceURI http://rs.tdwg.org/abcd/mappings/DataSet-ResourceURI', 'type': 'xs:anyURI'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, ResourceURI=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ResourceURI is None:
            self.ResourceURI = []
        else:
            self.ResourceURI = ResourceURI
        self.ResourceURI_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ResourceURIsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ResourceURIsType.subclass:
            return ResourceURIsType.subclass(*args_, **kwargs_)
        else:
            return ResourceURIsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ResourceURI(self):
        return self.ResourceURI
    def set_ResourceURI(self, ResourceURI):
        self.ResourceURI = ResourceURI
    def add_ResourceURI(self, value):
        self.ResourceURI.append(value)
    def insert_ResourceURI_at(self, index, value):
        self.ResourceURI.insert(index, value)
    def replace_ResourceURI_at(self, index, value):
        self.ResourceURI[index] = value
    def hasContent_(self):
        if (
            self.ResourceURI
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='ResourceURIsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ResourceURIsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ResourceURIsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ResourceURIsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ResourceURIsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='ResourceURIsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ResourceURI_ in self.ResourceURI:
            namespaceprefix_ = self.ResourceURI_nsprefix_ + ':' if (UseCapturedNS_ and self.ResourceURI_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sResourceURI>%s</%sResourceURI>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(ResourceURI_), input_name='ResourceURI')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ResourceURI':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ResourceURI')
            value_ = self.gds_validate_string(value_, node, 'ResourceURI')
            self.ResourceURI.append(value_)
            self.ResourceURI_nsprefix_ = child_.prefix
# end class ResourceURIsType


class TechnicalContactsType(GeneratedsSuper):
    """Container element for the technical contacts responsilbe for the data
    set."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('TechnicalContact', 'ContactP', 1, 0, {'maxOccurs': 'unbounded', 'name': 'TechnicalContact', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/TechnicalContact', 'type': 'ContactP'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, TechnicalContact=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if TechnicalContact is None:
            self.TechnicalContact = []
        else:
            self.TechnicalContact = TechnicalContact
        self.TechnicalContact_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TechnicalContactsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TechnicalContactsType.subclass:
            return TechnicalContactsType.subclass(*args_, **kwargs_)
        else:
            return TechnicalContactsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_TechnicalContact(self):
        return self.TechnicalContact
    def set_TechnicalContact(self, TechnicalContact):
        self.TechnicalContact = TechnicalContact
    def add_TechnicalContact(self, value):
        self.TechnicalContact.append(value)
    def insert_TechnicalContact_at(self, index, value):
        self.TechnicalContact.insert(index, value)
    def replace_TechnicalContact_at(self, index, value):
        self.TechnicalContact[index] = value
    def hasContent_(self):
        if (
            self.TechnicalContact
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='TechnicalContactsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TechnicalContactsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TechnicalContactsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TechnicalContactsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TechnicalContactsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='TechnicalContactsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for TechnicalContact_ in self.TechnicalContact:
            namespaceprefix_ = self.TechnicalContact_nsprefix_ + ':' if (UseCapturedNS_ and self.TechnicalContact_nsprefix_) else ''
            TechnicalContact_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TechnicalContact', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'TechnicalContact':
            obj_ = ContactP.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TechnicalContact.append(obj_)
            obj_.original_tagname_ = 'TechnicalContact'
# end class TechnicalContactsType


class ContentContactsType(GeneratedsSuper):
    """Questions and feedback about data, or restrictions on use of the data
    should be directed here. This contact normally represents the agent
    acting as the original supplier or custodian of the dataset. If a
    content contact is given on the unit-level, that one should be used for
    end-user purposes. The element is unbounded to provide for alternative
    contacts (vacation etc.)."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('ContentContact', 'ContactP', 1, 0, {'maxOccurs': 'unbounded', 'name': 'ContentContact', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/ContentContact http://rs.tdwg.org/abcd/mappings/DataSet-ContentContact', 'type': 'ContactP'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, ContentContact=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ContentContact is None:
            self.ContentContact = []
        else:
            self.ContentContact = ContentContact
        self.ContentContact_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContentContactsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContentContactsType.subclass:
            return ContentContactsType.subclass(*args_, **kwargs_)
        else:
            return ContentContactsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ContentContact(self):
        return self.ContentContact
    def set_ContentContact(self, ContentContact):
        self.ContentContact = ContentContact
    def add_ContentContact(self, value):
        self.ContentContact.append(value)
    def insert_ContentContact_at(self, index, value):
        self.ContentContact.insert(index, value)
    def replace_ContentContact_at(self, index, value):
        self.ContentContact[index] = value
    def hasContent_(self):
        if (
            self.ContentContact
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='ContentContactsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ContentContactsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ContentContactsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ContentContactsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ContentContactsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='ContentContactsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ContentContact_ in self.ContentContact:
            namespaceprefix_ = self.ContentContact_nsprefix_ + ':' if (UseCapturedNS_ and self.ContentContact_nsprefix_) else ''
            ContentContact_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ContentContact', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ContentContact':
            obj_ = ContactP.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ContentContact.append(obj_)
            obj_.original_tagname_ = 'ContentContact'
# end class ContentContactsType


class OtherProvidersType(GeneratedsSuper):
    """Other known providers of a Data Set."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('OtherProvider', ['String', 'xs:normalizedString'], 1, 0, {'maxOccurs': 'unbounded', 'name': 'OtherProvider', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/otherProvider', 'type': 'xs:normalizedString'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, OtherProvider=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if OtherProvider is None:
            self.OtherProvider = []
        else:
            self.OtherProvider = OtherProvider
        self.OtherProvider_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OtherProvidersType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OtherProvidersType.subclass:
            return OtherProvidersType.subclass(*args_, **kwargs_)
        else:
            return OtherProvidersType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_OtherProvider(self):
        return self.OtherProvider
    def set_OtherProvider(self, OtherProvider):
        self.OtherProvider = OtherProvider
    def add_OtherProvider(self, value):
        self.OtherProvider.append(value)
    def insert_OtherProvider_at(self, index, value):
        self.OtherProvider.insert(index, value)
    def replace_OtherProvider_at(self, index, value):
        self.OtherProvider[index] = value
    def validate_String(self, value):
        result = True
        # Validate type String, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on String' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.OtherProvider
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='OtherProvidersType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OtherProvidersType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OtherProvidersType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='OtherProvidersType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='OtherProvidersType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='OtherProvidersType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for OtherProvider_ in self.OtherProvider:
            namespaceprefix_ = self.OtherProvider_nsprefix_ + ':' if (UseCapturedNS_ and self.OtherProvider_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOtherProvider>%s</%sOtherProvider>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(OtherProvider_), input_name='OtherProvider')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'OtherProvider':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'OtherProvider')
            value_ = self.gds_validate_string(value_, node, 'OtherProvider')
            self.OtherProvider.append(value_)
            self.OtherProvider_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.OtherProvider[-1])
# end class OtherProvidersType


class UnitsType(GeneratedsSuper):
    """A container for one or more unit data records from the gathering"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('Unit', 'Unit', 1, 0, {'maxOccurs': 'unbounded', 'name': 'Unit', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/Unit', 'type': 'Unit'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, Unit=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Unit is None:
            self.Unit = []
        else:
            self.Unit = Unit
        self.Unit_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UnitsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UnitsType.subclass:
            return UnitsType.subclass(*args_, **kwargs_)
        else:
            return UnitsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Unit(self):
        return self.Unit
    def set_Unit(self, Unit):
        self.Unit = Unit
    def add_Unit(self, value):
        self.Unit.append(value)
    def insert_Unit_at(self, index, value):
        self.Unit.insert(index, value)
    def replace_Unit_at(self, index, value):
        self.Unit[index] = value
    def hasContent_(self):
        if (
            self.Unit
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='UnitsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('UnitsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UnitsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='UnitsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='UnitsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='UnitsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Unit_ in self.Unit:
            namespaceprefix_ = self.Unit_nsprefix_ + ':' if (UseCapturedNS_ and self.Unit_nsprefix_) else ''
            Unit_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Unit', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Unit':
            obj_ = Unit.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Unit.append(obj_)
            obj_.original_tagname_ = 'Unit'
# end class UnitsType


class GatheringAgentsType(GeneratedsSuper):
    """A container element for the agent(s) responsible for collecting or
    recording."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('GatheringAgent', 'GatheringAgentType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'GatheringAgent', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/GatheringAgent', 'type': 'GatheringAgentType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, GatheringAgent=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if GatheringAgent is None:
            self.GatheringAgent = []
        else:
            self.GatheringAgent = GatheringAgent
        self.GatheringAgent_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GatheringAgentsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GatheringAgentsType.subclass:
            return GatheringAgentsType.subclass(*args_, **kwargs_)
        else:
            return GatheringAgentsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_GatheringAgent(self):
        return self.GatheringAgent
    def set_GatheringAgent(self, GatheringAgent):
        self.GatheringAgent = GatheringAgent
    def add_GatheringAgent(self, value):
        self.GatheringAgent.append(value)
    def insert_GatheringAgent_at(self, index, value):
        self.GatheringAgent.insert(index, value)
    def replace_GatheringAgent_at(self, index, value):
        self.GatheringAgent[index] = value
    def hasContent_(self):
        if (
            self.GatheringAgent
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='GatheringAgentsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GatheringAgentsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GatheringAgentsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GatheringAgentsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='GatheringAgentsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='GatheringAgentsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for GatheringAgent_ in self.GatheringAgent:
            namespaceprefix_ = self.GatheringAgent_nsprefix_ + ':' if (UseCapturedNS_ and self.GatheringAgent_nsprefix_) else ''
            GatheringAgent_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='GatheringAgent', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'GatheringAgent':
            obj_ = GatheringAgentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.GatheringAgent.append(obj_)
            obj_.original_tagname_ = 'GatheringAgent'
# end class GatheringAgentsType


class GatheringAgentType(Contact):
    """The person, or one of the persons or team(s) or organization(s)
    responsible for collecting or recording. Attributes: a flag indicating
    the primary collector, and a sequence number."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('sequence', 'xs:int', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = Contact
    def __init__(self, UnformattedValue=None, Organization=None, Person=None, Roles=None, Addresses=None, TelephoneNumbers=None, EmailAddresses=None, WebsiteURL=None, ResourceURIs=None, sequence=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(GatheringAgentType, self).__init__(UnformattedValue, Organization, Person, Roles, Addresses, TelephoneNumbers, EmailAddresses, WebsiteURL, ResourceURIs,  **kwargs_)
        self.sequence = _cast(int, sequence)
        self.sequence_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GatheringAgentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GatheringAgentType.subclass:
            return GatheringAgentType.subclass(*args_, **kwargs_)
        else:
            return GatheringAgentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_sequence(self):
        return self.sequence
    def set_sequence(self, sequence):
        self.sequence = sequence
    def hasContent_(self):
        if (
            super(GatheringAgentType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='GatheringAgentType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GatheringAgentType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GatheringAgentType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GatheringAgentType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='GatheringAgentType'):
        super(GatheringAgentType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GatheringAgentType')
        if self.sequence is not None and 'sequence' not in already_processed:
            already_processed.add('sequence')
            outfile.write(' sequence="%s"' % self.gds_format_integer(self.sequence, input_name='sequence'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='GatheringAgentType', fromsubclass_=False, pretty_print=True):
        super(GatheringAgentType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sequence', node)
        if value is not None and 'sequence' not in already_processed:
            already_processed.add('sequence')
            self.sequence = self.gds_parse_integer(value, node, 'sequence')
        super(GatheringAgentType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(GatheringAgentType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class GatheringAgentType


class PermitsType(GeneratedsSuper):
    """A container element for references to (or texts of) permits related to
    the gathering event."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('Permit', 'Permit', 1, 0, {'maxOccurs': 'unbounded', 'name': 'Permit', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/Permit', 'type': 'Permit'}, 3),
    ]
    subclass = None
    superclass = None
    def __init__(self, Permit=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Permit is None:
            self.Permit = []
        else:
            self.Permit = Permit
        self.Permit_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PermitsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PermitsType.subclass:
            return PermitsType.subclass(*args_, **kwargs_)
        else:
            return PermitsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Permit(self):
        return self.Permit
    def set_Permit(self, Permit):
        self.Permit = Permit
    def add_Permit(self, value):
        self.Permit.append(value)
    def insert_Permit_at(self, index, value):
        self.Permit.insert(index, value)
    def replace_Permit_at(self, index, value):
        self.Permit[index] = value
    def hasContent_(self):
        if (
            self.Permit
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='PermitsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PermitsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PermitsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PermitsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PermitsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='PermitsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Permit_ in self.Permit:
            namespaceprefix_ = self.Permit_nsprefix_ + ':' if (UseCapturedNS_ and self.Permit_nsprefix_) else ''
            Permit_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Permit', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Permit':
            obj_ = Permit.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Permit.append(obj_)
            obj_.original_tagname_ = 'Permit'
# end class PermitsType


class ProjectType(GeneratedsSuper):
    """Project information concerning the gathering event."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('Title', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'Title', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Project-Title', 'type': 'StringL'}, None),
        MemberSpec_('ResourceURIs', 'ResourceURIsType1', 0, 1, {'minOccurs': '0', 'name': 'ResourceURIs', 'type': 'ResourceURIsType1'}, None),
        MemberSpec_('WebsiteURL', 'xs:anyURI', 0, 1, {'minOccurs': '0', 'name': 'WebsiteURL', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Project-WebsiteURL', 'type': 'xs:anyURI'}, None),
        MemberSpec_('Contact', 'Contact', 0, 1, {'minOccurs': '0', 'name': 'Contact', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Project-Contact', 'type': 'Contact'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, Title=None, ResourceURIs=None, WebsiteURL=None, Contact=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Title = Title
        self.Title_nsprefix_ = None
        self.ResourceURIs = ResourceURIs
        self.ResourceURIs_nsprefix_ = None
        self.WebsiteURL = WebsiteURL
        self.WebsiteURL_nsprefix_ = None
        self.Contact = Contact
        self.Contact_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProjectType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProjectType.subclass:
            return ProjectType.subclass(*args_, **kwargs_)
        else:
            return ProjectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Title(self):
        return self.Title
    def set_Title(self, Title):
        self.Title = Title
    def get_ResourceURIs(self):
        return self.ResourceURIs
    def set_ResourceURIs(self, ResourceURIs):
        self.ResourceURIs = ResourceURIs
    def get_WebsiteURL(self):
        return self.WebsiteURL
    def set_WebsiteURL(self, WebsiteURL):
        self.WebsiteURL = WebsiteURL
    def get_Contact(self):
        return self.Contact
    def set_Contact(self, Contact):
        self.Contact = Contact
    def hasContent_(self):
        if (
            self.Title is not None or
            self.ResourceURIs is not None or
            self.WebsiteURL is not None or
            self.Contact is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='ProjectType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ProjectType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ProjectType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ProjectType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ProjectType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='ProjectType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Title is not None:
            namespaceprefix_ = self.Title_nsprefix_ + ':' if (UseCapturedNS_ and self.Title_nsprefix_) else ''
            self.Title.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Title', pretty_print=pretty_print)
        if self.ResourceURIs is not None:
            namespaceprefix_ = self.ResourceURIs_nsprefix_ + ':' if (UseCapturedNS_ and self.ResourceURIs_nsprefix_) else ''
            self.ResourceURIs.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ResourceURIs', pretty_print=pretty_print)
        if self.WebsiteURL is not None:
            namespaceprefix_ = self.WebsiteURL_nsprefix_ + ':' if (UseCapturedNS_ and self.WebsiteURL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sWebsiteURL>%s</%sWebsiteURL>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.WebsiteURL), input_name='WebsiteURL')), namespaceprefix_ , eol_))
        if self.Contact is not None:
            namespaceprefix_ = self.Contact_nsprefix_ + ':' if (UseCapturedNS_ and self.Contact_nsprefix_) else ''
            self.Contact.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Contact', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Title':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Title = obj_
            obj_.original_tagname_ = 'Title'
        elif nodeName_ == 'ResourceURIs':
            obj_ = ResourceURIsType1.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ResourceURIs = obj_
            obj_.original_tagname_ = 'ResourceURIs'
        elif nodeName_ == 'WebsiteURL':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'WebsiteURL')
            value_ = self.gds_validate_string(value_, node, 'WebsiteURL')
            self.WebsiteURL = value_
            self.WebsiteURL_nsprefix_ = child_.prefix
        elif nodeName_ == 'Contact':
            class_obj_ = self.get_class_obj_(child_, Contact)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Contact = obj_
            obj_.original_tagname_ = 'Contact'
# end class ProjectType


class ResourceURIsType1(GeneratedsSuper):
    """Preferably resolvable URIs of the association."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('ResourceURI', 'xs:anyURI', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'ResourceURI', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Project-ResourceURI', 'type': 'xs:anyURI'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, ResourceURI=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ResourceURI is None:
            self.ResourceURI = []
        else:
            self.ResourceURI = ResourceURI
        self.ResourceURI_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ResourceURIsType1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ResourceURIsType1.subclass:
            return ResourceURIsType1.subclass(*args_, **kwargs_)
        else:
            return ResourceURIsType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ResourceURI(self):
        return self.ResourceURI
    def set_ResourceURI(self, ResourceURI):
        self.ResourceURI = ResourceURI
    def add_ResourceURI(self, value):
        self.ResourceURI.append(value)
    def insert_ResourceURI_at(self, index, value):
        self.ResourceURI.insert(index, value)
    def replace_ResourceURI_at(self, index, value):
        self.ResourceURI[index] = value
    def hasContent_(self):
        if (
            self.ResourceURI
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='ResourceURIsType1', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ResourceURIsType1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ResourceURIsType1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ResourceURIsType1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ResourceURIsType1'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='ResourceURIsType1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ResourceURI_ in self.ResourceURI:
            namespaceprefix_ = self.ResourceURI_nsprefix_ + ':' if (UseCapturedNS_ and self.ResourceURI_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sResourceURI>%s</%sResourceURI>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(ResourceURI_), input_name='ResourceURI')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ResourceURI':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ResourceURI')
            value_ = self.gds_validate_string(value_, node, 'ResourceURI')
            self.ResourceURI.append(value_)
            self.ResourceURI_nsprefix_ = child_.prefix
# end class ResourceURIsType1


class NamedAreasType(GeneratedsSuper):
    """Atomized place names as applied to the collection or observation site;
    with possibility for hierarchical structuring and categorization."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('NamedArea', 'NamedArea', 1, 0, {'maxOccurs': 'unbounded', 'name': 'NamedArea', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/NamedArea', 'type': 'NamedAreaType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, NamedArea=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if NamedArea is None:
            self.NamedArea = []
        else:
            self.NamedArea = NamedArea
        self.NamedArea_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NamedAreasType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NamedAreasType.subclass:
            return NamedAreasType.subclass(*args_, **kwargs_)
        else:
            return NamedAreasType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_NamedArea(self):
        return self.NamedArea
    def set_NamedArea(self, NamedArea):
        self.NamedArea = NamedArea
    def add_NamedArea(self, value):
        self.NamedArea.append(value)
    def insert_NamedArea_at(self, index, value):
        self.NamedArea.insert(index, value)
    def replace_NamedArea_at(self, index, value):
        self.NamedArea[index] = value
    def hasContent_(self):
        if (
            self.NamedArea
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='NamedAreasType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NamedAreasType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NamedAreasType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NamedAreasType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NamedAreasType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='NamedAreasType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for NamedArea_ in self.NamedArea:
            namespaceprefix_ = self.NamedArea_nsprefix_ + ':' if (UseCapturedNS_ and self.NamedArea_nsprefix_) else ''
            NamedArea_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NamedArea', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'NamedArea':
            obj_ = NamedAreaType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NamedArea.append(obj_)
            obj_.original_tagname_ = 'NamedArea'
# end class NamedAreasType


class NamedAreaType(NamedArea):
    """Atomized place name with possibility for hierarchical structuring.
    Attribute for sequence."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('sequence', 'xs:int', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = NamedArea
    def __init__(self, AreaClass=None, Name=None, CodeStandard=None, Code=None, Reference=None, sequence=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(NamedAreaType, self).__init__(AreaClass, Name, CodeStandard, Code, Reference,  **kwargs_)
        self.sequence = _cast(int, sequence)
        self.sequence_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NamedAreaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NamedAreaType.subclass:
            return NamedAreaType.subclass(*args_, **kwargs_)
        else:
            return NamedAreaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_sequence(self):
        return self.sequence
    def set_sequence(self, sequence):
        self.sequence = sequence
    def hasContent_(self):
        if (
            super(NamedAreaType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='NamedAreaType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NamedAreaType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NamedAreaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NamedAreaType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NamedAreaType'):
        super(NamedAreaType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NamedAreaType')
        if self.sequence is not None and 'sequence' not in already_processed:
            already_processed.add('sequence')
            outfile.write(' sequence="%s"' % self.gds_format_integer(self.sequence, input_name='sequence'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='NamedAreaType', fromsubclass_=False, pretty_print=True):
        super(NamedAreaType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sequence', node)
        if value is not None and 'sequence' not in already_processed:
            already_processed.add('sequence')
            self.sequence = self.gds_parse_integer(value, node, 'sequence')
        super(NamedAreaType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(NamedAreaType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class NamedAreaType


class NamedPlaceRelationsType(GeneratedsSuper):
    """Specified relationship to a named place that does not directly apply to
    the site of collection or observation, e. g. 10 Km South of Mytown."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('NamedPlaceRelation', 'NamedPlaceRelationType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'NamedPlaceRelation', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/NamedPlaceRelation', 'type': 'NamedPlaceRelationType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, NamedPlaceRelation=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if NamedPlaceRelation is None:
            self.NamedPlaceRelation = []
        else:
            self.NamedPlaceRelation = NamedPlaceRelation
        self.NamedPlaceRelation_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NamedPlaceRelationsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NamedPlaceRelationsType.subclass:
            return NamedPlaceRelationsType.subclass(*args_, **kwargs_)
        else:
            return NamedPlaceRelationsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_NamedPlaceRelation(self):
        return self.NamedPlaceRelation
    def set_NamedPlaceRelation(self, NamedPlaceRelation):
        self.NamedPlaceRelation = NamedPlaceRelation
    def add_NamedPlaceRelation(self, value):
        self.NamedPlaceRelation.append(value)
    def insert_NamedPlaceRelation_at(self, index, value):
        self.NamedPlaceRelation.insert(index, value)
    def replace_NamedPlaceRelation_at(self, index, value):
        self.NamedPlaceRelation[index] = value
    def hasContent_(self):
        if (
            self.NamedPlaceRelation
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='NamedPlaceRelationsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NamedPlaceRelationsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NamedPlaceRelationsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NamedPlaceRelationsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NamedPlaceRelationsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='NamedPlaceRelationsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for NamedPlaceRelation_ in self.NamedPlaceRelation:
            namespaceprefix_ = self.NamedPlaceRelation_nsprefix_ + ':' if (UseCapturedNS_ and self.NamedPlaceRelation_nsprefix_) else ''
            NamedPlaceRelation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NamedPlaceRelation', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'NamedPlaceRelation':
            obj_ = NamedPlaceRelationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NamedPlaceRelation.append(obj_)
            obj_.original_tagname_ = 'NamedPlaceRelation'
# end class NamedPlaceRelationsType


class NamedPlaceRelationType(GeneratedsSuper):
    """The relationship of the gathering site with a different place."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('NearbyPlaceName', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'NearbyPlaceName', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/nearbyPlaceName', 'type': 'StringL'}, None),
        MemberSpec_('NearbyPlaceRelation', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'NearbyPlaceRelation', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/nearbyPlaceRelation', 'type': 'StringL'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, NearbyPlaceName=None, NearbyPlaceRelation=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.NearbyPlaceName = NearbyPlaceName
        self.NearbyPlaceName_nsprefix_ = None
        self.NearbyPlaceRelation = NearbyPlaceRelation
        self.NearbyPlaceRelation_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NamedPlaceRelationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NamedPlaceRelationType.subclass:
            return NamedPlaceRelationType.subclass(*args_, **kwargs_)
        else:
            return NamedPlaceRelationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_NearbyPlaceName(self):
        return self.NearbyPlaceName
    def set_NearbyPlaceName(self, NearbyPlaceName):
        self.NearbyPlaceName = NearbyPlaceName
    def get_NearbyPlaceRelation(self):
        return self.NearbyPlaceRelation
    def set_NearbyPlaceRelation(self, NearbyPlaceRelation):
        self.NearbyPlaceRelation = NearbyPlaceRelation
    def hasContent_(self):
        if (
            self.NearbyPlaceName is not None or
            self.NearbyPlaceRelation is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='NamedPlaceRelationType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NamedPlaceRelationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NamedPlaceRelationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NamedPlaceRelationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NamedPlaceRelationType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='NamedPlaceRelationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.NearbyPlaceName is not None:
            namespaceprefix_ = self.NearbyPlaceName_nsprefix_ + ':' if (UseCapturedNS_ and self.NearbyPlaceName_nsprefix_) else ''
            self.NearbyPlaceName.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NearbyPlaceName', pretty_print=pretty_print)
        if self.NearbyPlaceRelation is not None:
            namespaceprefix_ = self.NearbyPlaceRelation_nsprefix_ + ':' if (UseCapturedNS_ and self.NearbyPlaceRelation_nsprefix_) else ''
            self.NearbyPlaceRelation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NearbyPlaceRelation', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'NearbyPlaceName':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NearbyPlaceName = obj_
            obj_.original_tagname_ = 'NearbyPlaceName'
        elif nodeName_ == 'NearbyPlaceRelation':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NearbyPlaceRelation = obj_
            obj_.original_tagname_ = 'NearbyPlaceRelation'
# end class NamedPlaceRelationType


class CoordinateSetsType(GeneratedsSuper):
    """Container for multiple sets of coordinates indicating the site of
    collection or observation."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('CoordinateSet', 'CoordinateSetType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'CoordinateSet', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/Coordinates', 'type': 'CoordinateSetType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, CoordinateSet=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if CoordinateSet is None:
            self.CoordinateSet = []
        else:
            self.CoordinateSet = CoordinateSet
        self.CoordinateSet_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CoordinateSetsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CoordinateSetsType.subclass:
            return CoordinateSetsType.subclass(*args_, **kwargs_)
        else:
            return CoordinateSetsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CoordinateSet(self):
        return self.CoordinateSet
    def set_CoordinateSet(self, CoordinateSet):
        self.CoordinateSet = CoordinateSet
    def add_CoordinateSet(self, value):
        self.CoordinateSet.append(value)
    def insert_CoordinateSet_at(self, index, value):
        self.CoordinateSet.insert(index, value)
    def replace_CoordinateSet_at(self, index, value):
        self.CoordinateSet[index] = value
    def hasContent_(self):
        if (
            self.CoordinateSet
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='CoordinateSetsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CoordinateSetsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CoordinateSetsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CoordinateSetsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CoordinateSetsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='CoordinateSetsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for CoordinateSet_ in self.CoordinateSet:
            namespaceprefix_ = self.CoordinateSet_nsprefix_ + ':' if (UseCapturedNS_ and self.CoordinateSet_nsprefix_) else ''
            CoordinateSet_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CoordinateSet', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CoordinateSet':
            obj_ = CoordinateSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CoordinateSet.append(obj_)
            obj_.original_tagname_ = 'CoordinateSet'
# end class CoordinateSetsType


class CoordinateSetType(GeneratedsSuper):
    """Attributes for Original data and for begin and end of sequence .
    Composite element to allow recording multiple coordinates or same
    coordinate in different systems"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('original', 'xs:boolean', 0, 1, {'use': 'optional'}),
        MemberSpec_('begin', 'xs:boolean', 0, 1, {'use': 'optional'}),
        MemberSpec_('end', 'xs:boolean', 0, 1, {'use': 'optional'}),
        MemberSpec_('Method', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'Method', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Coordinates-Method', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('References', 'ReferencesType', 0, 1, {'minOccurs': '0', 'name': 'References', 'type': 'ReferencesType'}, None),
        MemberSpec_('VerificationStatus', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'VerificationStatus', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/verificationStatus', 'type': 'xs:string'}, None),
        MemberSpec_('Notes', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'Notes', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Coordinates-Notes', 'type': 'xs:string'}, None),
        MemberSpec_('CoordinatesUTM', 'CoordinatesUTMType', 0, 1, {'minOccurs': '0', 'name': 'CoordinatesUTM', 'type': 'CoordinatesUTMType'}, None),
        MemberSpec_('CoordinatesGrid', 'CoordinatesGridType', 0, 1, {'minOccurs': '0', 'name': 'CoordinatesGrid', 'type': 'CoordinatesGridType'}, None),
        MemberSpec_('CoordinatesLatLong', 'CoordinatesLatLongType', 0, 1, {'minOccurs': '0', 'name': 'CoordinatesLatLong', 'type': 'CoordinatesLatLongType'}, None),
        MemberSpec_('EPSGID', 'xs:integer', 0, 1, {'minOccurs': '0', 'name': 'EPSGID', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/epsgID', 'type': 'xs:integer'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, original=None, begin=None, end=None, Method=None, References=None, VerificationStatus=None, Notes=None, CoordinatesUTM=None, CoordinatesGrid=None, CoordinatesLatLong=None, EPSGID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.original = _cast(bool, original)
        self.original_nsprefix_ = None
        self.begin = _cast(bool, begin)
        self.begin_nsprefix_ = None
        self.end = _cast(bool, end)
        self.end_nsprefix_ = None
        self.Method = Method
        self.validate_String(self.Method)
        self.Method_nsprefix_ = None
        self.References = References
        self.References_nsprefix_ = None
        self.VerificationStatus = VerificationStatus
        self.VerificationStatus_nsprefix_ = None
        self.Notes = Notes
        self.Notes_nsprefix_ = None
        self.CoordinatesUTM = CoordinatesUTM
        self.CoordinatesUTM_nsprefix_ = None
        self.CoordinatesGrid = CoordinatesGrid
        self.CoordinatesGrid_nsprefix_ = None
        self.CoordinatesLatLong = CoordinatesLatLong
        self.CoordinatesLatLong_nsprefix_ = None
        self.EPSGID = EPSGID
        self.EPSGID_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CoordinateSetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CoordinateSetType.subclass:
            return CoordinateSetType.subclass(*args_, **kwargs_)
        else:
            return CoordinateSetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Method(self):
        return self.Method
    def set_Method(self, Method):
        self.Method = Method
    def get_References(self):
        return self.References
    def set_References(self, References):
        self.References = References
    def get_VerificationStatus(self):
        return self.VerificationStatus
    def set_VerificationStatus(self, VerificationStatus):
        self.VerificationStatus = VerificationStatus
    def get_Notes(self):
        return self.Notes
    def set_Notes(self, Notes):
        self.Notes = Notes
    def get_CoordinatesUTM(self):
        return self.CoordinatesUTM
    def set_CoordinatesUTM(self, CoordinatesUTM):
        self.CoordinatesUTM = CoordinatesUTM
    def get_CoordinatesGrid(self):
        return self.CoordinatesGrid
    def set_CoordinatesGrid(self, CoordinatesGrid):
        self.CoordinatesGrid = CoordinatesGrid
    def get_CoordinatesLatLong(self):
        return self.CoordinatesLatLong
    def set_CoordinatesLatLong(self, CoordinatesLatLong):
        self.CoordinatesLatLong = CoordinatesLatLong
    def get_EPSGID(self):
        return self.EPSGID
    def set_EPSGID(self, EPSGID):
        self.EPSGID = EPSGID
    def get_original(self):
        return self.original
    def set_original(self, original):
        self.original = original
    def get_begin(self):
        return self.begin
    def set_begin(self, begin):
        self.begin = begin
    def get_end(self):
        return self.end
    def set_end(self, end):
        self.end = end
    def validate_String(self, value):
        result = True
        # Validate type String, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on String' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.Method is not None or
            self.References is not None or
            self.VerificationStatus is not None or
            self.Notes is not None or
            self.CoordinatesUTM is not None or
            self.CoordinatesGrid is not None or
            self.CoordinatesLatLong is not None or
            self.EPSGID is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='CoordinateSetType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CoordinateSetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CoordinateSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CoordinateSetType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CoordinateSetType'):
        if self.original is not None and 'original' not in already_processed:
            already_processed.add('original')
            outfile.write(' original="%s"' % self.gds_format_boolean(self.original, input_name='original'))
        if self.begin is not None and 'begin' not in already_processed:
            already_processed.add('begin')
            outfile.write(' begin="%s"' % self.gds_format_boolean(self.begin, input_name='begin'))
        if self.end is not None and 'end' not in already_processed:
            already_processed.add('end')
            outfile.write(' end="%s"' % self.gds_format_boolean(self.end, input_name='end'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='CoordinateSetType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Method is not None:
            namespaceprefix_ = self.Method_nsprefix_ + ':' if (UseCapturedNS_ and self.Method_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMethod>%s</%sMethod>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Method), input_name='Method')), namespaceprefix_ , eol_))
        if self.References is not None:
            namespaceprefix_ = self.References_nsprefix_ + ':' if (UseCapturedNS_ and self.References_nsprefix_) else ''
            self.References.export(outfile, level, namespaceprefix_, namespacedef_='', name_='References', pretty_print=pretty_print)
        if self.VerificationStatus is not None:
            namespaceprefix_ = self.VerificationStatus_nsprefix_ + ':' if (UseCapturedNS_ and self.VerificationStatus_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVerificationStatus>%s</%sVerificationStatus>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.VerificationStatus), input_name='VerificationStatus')), namespaceprefix_ , eol_))
        if self.Notes is not None:
            namespaceprefix_ = self.Notes_nsprefix_ + ':' if (UseCapturedNS_ and self.Notes_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNotes>%s</%sNotes>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Notes), input_name='Notes')), namespaceprefix_ , eol_))
        if self.CoordinatesUTM is not None:
            namespaceprefix_ = self.CoordinatesUTM_nsprefix_ + ':' if (UseCapturedNS_ and self.CoordinatesUTM_nsprefix_) else ''
            self.CoordinatesUTM.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CoordinatesUTM', pretty_print=pretty_print)
        if self.CoordinatesGrid is not None:
            namespaceprefix_ = self.CoordinatesGrid_nsprefix_ + ':' if (UseCapturedNS_ and self.CoordinatesGrid_nsprefix_) else ''
            self.CoordinatesGrid.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CoordinatesGrid', pretty_print=pretty_print)
        if self.CoordinatesLatLong is not None:
            namespaceprefix_ = self.CoordinatesLatLong_nsprefix_ + ':' if (UseCapturedNS_ and self.CoordinatesLatLong_nsprefix_) else ''
            self.CoordinatesLatLong.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CoordinatesLatLong', pretty_print=pretty_print)
        if self.EPSGID is not None:
            namespaceprefix_ = self.EPSGID_nsprefix_ + ':' if (UseCapturedNS_ and self.EPSGID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEPSGID>%s</%sEPSGID>%s' % (namespaceprefix_ , self.gds_format_integer(self.EPSGID, input_name='EPSGID'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('original', node)
        if value is not None and 'original' not in already_processed:
            already_processed.add('original')
            if value in ('true', '1'):
                self.original = True
            elif value in ('false', '0'):
                self.original = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('begin', node)
        if value is not None and 'begin' not in already_processed:
            already_processed.add('begin')
            if value in ('true', '1'):
                self.begin = True
            elif value in ('false', '0'):
                self.begin = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('end', node)
        if value is not None and 'end' not in already_processed:
            already_processed.add('end')
            if value in ('true', '1'):
                self.end = True
            elif value in ('false', '0'):
                self.end = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Method':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Method')
            value_ = self.gds_validate_string(value_, node, 'Method')
            self.Method = value_
            self.Method_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.Method)
        elif nodeName_ == 'References':
            obj_ = ReferencesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.References = obj_
            obj_.original_tagname_ = 'References'
        elif nodeName_ == 'VerificationStatus':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'VerificationStatus')
            value_ = self.gds_validate_string(value_, node, 'VerificationStatus')
            self.VerificationStatus = value_
            self.VerificationStatus_nsprefix_ = child_.prefix
        elif nodeName_ == 'Notes':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Notes')
            value_ = self.gds_validate_string(value_, node, 'Notes')
            self.Notes = value_
            self.Notes_nsprefix_ = child_.prefix
        elif nodeName_ == 'CoordinatesUTM':
            obj_ = CoordinatesUTMType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CoordinatesUTM = obj_
            obj_.original_tagname_ = 'CoordinatesUTM'
        elif nodeName_ == 'CoordinatesGrid':
            obj_ = CoordinatesGridType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CoordinatesGrid = obj_
            obj_.original_tagname_ = 'CoordinatesGrid'
        elif nodeName_ == 'CoordinatesLatLong':
            obj_ = CoordinatesLatLongType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CoordinatesLatLong = obj_
            obj_.original_tagname_ = 'CoordinatesLatLong'
        elif nodeName_ == 'EPSGID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'EPSGID')
            ival_ = self.gds_validate_integer(ival_, node, 'EPSGID')
            self.EPSGID = ival_
            self.EPSGID_nsprefix_ = child_.prefix
# end class CoordinateSetType


class ReferencesType(GeneratedsSuper):
    """[DwC Geospatial Extension v. 1.4:] A list of maps, gazetteers or other
    resources used to georeference the locality. The content of this
    concept is meant to be specific enough to allow anyone in the future to
    use the same resource to georeference the same locality. Example: "USGS
    1:24000 Florence Montana Quad"."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('Reference', 'Reference', 1, 0, {'maxOccurs': 'unbounded', 'name': 'Reference', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Coordinates-Reference', 'type': 'Reference'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, Reference=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Reference is None:
            self.Reference = []
        else:
            self.Reference = Reference
        self.Reference_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReferencesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReferencesType.subclass:
            return ReferencesType.subclass(*args_, **kwargs_)
        else:
            return ReferencesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Reference(self):
        return self.Reference
    def set_Reference(self, Reference):
        self.Reference = Reference
    def add_Reference(self, value):
        self.Reference.append(value)
    def insert_Reference_at(self, index, value):
        self.Reference.insert(index, value)
    def replace_Reference_at(self, index, value):
        self.Reference[index] = value
    def hasContent_(self):
        if (
            self.Reference
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='ReferencesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReferencesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReferencesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ReferencesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ReferencesType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='ReferencesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Reference_ in self.Reference:
            namespaceprefix_ = self.Reference_nsprefix_ + ':' if (UseCapturedNS_ and self.Reference_nsprefix_) else ''
            Reference_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Reference', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Reference':
            obj_ = Reference.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Reference.append(obj_)
            obj_.original_tagname_ = 'Reference'
# end class ReferencesType


class CoordinatesUTMType(GeneratedsSuper):
    """A container for coordinates expressed for the Universal Transverse
    Mercator projection."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('UTMZone', 'xs:integer', 0, 1, {'minOccurs': '0', 'name': 'UTMZone', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/utmZone', 'type': 'xs:integer'}, None),
        MemberSpec_('UTMSubzone', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'UTMSubzone', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/utmSubzone', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('UTMNS', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'UTMNS', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/utmNS', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('UTMZoneFull', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'UTMZoneFull', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/utmZoneFull', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('UTMEasting', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'UTMEasting', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/utmEasting', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('UTMNorthing', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'UTMNorthing', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/utmNorthing', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('UTMDatum', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'UTMDatum', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/utmDatum', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('UTMText', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'UTMText', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/utmText', 'type': 'xs:normalizedString'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, UTMZone=None, UTMSubzone=None, UTMNS=None, UTMZoneFull=None, UTMEasting=None, UTMNorthing=None, UTMDatum=None, UTMText=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.UTMZone = UTMZone
        self.UTMZone_nsprefix_ = None
        self.UTMSubzone = UTMSubzone
        self.validate_String(self.UTMSubzone)
        self.UTMSubzone_nsprefix_ = None
        self.UTMNS = UTMNS
        self.validate_String(self.UTMNS)
        self.UTMNS_nsprefix_ = None
        self.UTMZoneFull = UTMZoneFull
        self.validate_String(self.UTMZoneFull)
        self.UTMZoneFull_nsprefix_ = None
        self.UTMEasting = UTMEasting
        self.validate_String(self.UTMEasting)
        self.UTMEasting_nsprefix_ = None
        self.UTMNorthing = UTMNorthing
        self.validate_String(self.UTMNorthing)
        self.UTMNorthing_nsprefix_ = None
        self.UTMDatum = UTMDatum
        self.validate_String(self.UTMDatum)
        self.UTMDatum_nsprefix_ = None
        self.UTMText = UTMText
        self.validate_String(self.UTMText)
        self.UTMText_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CoordinatesUTMType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CoordinatesUTMType.subclass:
            return CoordinatesUTMType.subclass(*args_, **kwargs_)
        else:
            return CoordinatesUTMType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_UTMZone(self):
        return self.UTMZone
    def set_UTMZone(self, UTMZone):
        self.UTMZone = UTMZone
    def get_UTMSubzone(self):
        return self.UTMSubzone
    def set_UTMSubzone(self, UTMSubzone):
        self.UTMSubzone = UTMSubzone
    def get_UTMNS(self):
        return self.UTMNS
    def set_UTMNS(self, UTMNS):
        self.UTMNS = UTMNS
    def get_UTMZoneFull(self):
        return self.UTMZoneFull
    def set_UTMZoneFull(self, UTMZoneFull):
        self.UTMZoneFull = UTMZoneFull
    def get_UTMEasting(self):
        return self.UTMEasting
    def set_UTMEasting(self, UTMEasting):
        self.UTMEasting = UTMEasting
    def get_UTMNorthing(self):
        return self.UTMNorthing
    def set_UTMNorthing(self, UTMNorthing):
        self.UTMNorthing = UTMNorthing
    def get_UTMDatum(self):
        return self.UTMDatum
    def set_UTMDatum(self, UTMDatum):
        self.UTMDatum = UTMDatum
    def get_UTMText(self):
        return self.UTMText
    def set_UTMText(self, UTMText):
        self.UTMText = UTMText
    def validate_String(self, value):
        result = True
        # Validate type String, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on String' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.UTMZone is not None or
            self.UTMSubzone is not None or
            self.UTMNS is not None or
            self.UTMZoneFull is not None or
            self.UTMEasting is not None or
            self.UTMNorthing is not None or
            self.UTMDatum is not None or
            self.UTMText is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='CoordinatesUTMType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CoordinatesUTMType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CoordinatesUTMType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CoordinatesUTMType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CoordinatesUTMType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='CoordinatesUTMType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.UTMZone is not None:
            namespaceprefix_ = self.UTMZone_nsprefix_ + ':' if (UseCapturedNS_ and self.UTMZone_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUTMZone>%s</%sUTMZone>%s' % (namespaceprefix_ , self.gds_format_integer(self.UTMZone, input_name='UTMZone'), namespaceprefix_ , eol_))
        if self.UTMSubzone is not None:
            namespaceprefix_ = self.UTMSubzone_nsprefix_ + ':' if (UseCapturedNS_ and self.UTMSubzone_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUTMSubzone>%s</%sUTMSubzone>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.UTMSubzone), input_name='UTMSubzone')), namespaceprefix_ , eol_))
        if self.UTMNS is not None:
            namespaceprefix_ = self.UTMNS_nsprefix_ + ':' if (UseCapturedNS_ and self.UTMNS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUTMNS>%s</%sUTMNS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.UTMNS), input_name='UTMNS')), namespaceprefix_ , eol_))
        if self.UTMZoneFull is not None:
            namespaceprefix_ = self.UTMZoneFull_nsprefix_ + ':' if (UseCapturedNS_ and self.UTMZoneFull_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUTMZoneFull>%s</%sUTMZoneFull>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.UTMZoneFull), input_name='UTMZoneFull')), namespaceprefix_ , eol_))
        if self.UTMEasting is not None:
            namespaceprefix_ = self.UTMEasting_nsprefix_ + ':' if (UseCapturedNS_ and self.UTMEasting_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUTMEasting>%s</%sUTMEasting>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.UTMEasting), input_name='UTMEasting')), namespaceprefix_ , eol_))
        if self.UTMNorthing is not None:
            namespaceprefix_ = self.UTMNorthing_nsprefix_ + ':' if (UseCapturedNS_ and self.UTMNorthing_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUTMNorthing>%s</%sUTMNorthing>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.UTMNorthing), input_name='UTMNorthing')), namespaceprefix_ , eol_))
        if self.UTMDatum is not None:
            namespaceprefix_ = self.UTMDatum_nsprefix_ + ':' if (UseCapturedNS_ and self.UTMDatum_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUTMDatum>%s</%sUTMDatum>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.UTMDatum), input_name='UTMDatum')), namespaceprefix_ , eol_))
        if self.UTMText is not None:
            namespaceprefix_ = self.UTMText_nsprefix_ + ':' if (UseCapturedNS_ and self.UTMText_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUTMText>%s</%sUTMText>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.UTMText), input_name='UTMText')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'UTMZone' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'UTMZone')
            ival_ = self.gds_validate_integer(ival_, node, 'UTMZone')
            self.UTMZone = ival_
            self.UTMZone_nsprefix_ = child_.prefix
        elif nodeName_ == 'UTMSubzone':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'UTMSubzone')
            value_ = self.gds_validate_string(value_, node, 'UTMSubzone')
            self.UTMSubzone = value_
            self.UTMSubzone_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.UTMSubzone)
        elif nodeName_ == 'UTMNS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'UTMNS')
            value_ = self.gds_validate_string(value_, node, 'UTMNS')
            self.UTMNS = value_
            self.UTMNS_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.UTMNS)
        elif nodeName_ == 'UTMZoneFull':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'UTMZoneFull')
            value_ = self.gds_validate_string(value_, node, 'UTMZoneFull')
            self.UTMZoneFull = value_
            self.UTMZoneFull_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.UTMZoneFull)
        elif nodeName_ == 'UTMEasting':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'UTMEasting')
            value_ = self.gds_validate_string(value_, node, 'UTMEasting')
            self.UTMEasting = value_
            self.UTMEasting_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.UTMEasting)
        elif nodeName_ == 'UTMNorthing':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'UTMNorthing')
            value_ = self.gds_validate_string(value_, node, 'UTMNorthing')
            self.UTMNorthing = value_
            self.UTMNorthing_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.UTMNorthing)
        elif nodeName_ == 'UTMDatum':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'UTMDatum')
            value_ = self.gds_validate_string(value_, node, 'UTMDatum')
            self.UTMDatum = value_
            self.UTMDatum_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.UTMDatum)
        elif nodeName_ == 'UTMText':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'UTMText')
            value_ = self.gds_validate_string(value_, node, 'UTMText')
            self.UTMText = value_
            self.UTMText_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.UTMText)
# end class CoordinatesUTMType


class CoordinatesGridType(GeneratedsSuper):
    """Geospatial coordinates recorded using a grid system"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('GridCellSystem', ['String', 'xs:normalizedString'], 0, 0, {'name': 'GridCellSystem', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/gridCellSystem', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('GridCellCode', ['String', 'xs:normalizedString'], 0, 0, {'name': 'GridCellCode', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/gridCellCode', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('GridQualifier', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'GridQualifier', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/gridQualifier', 'type': 'xs:normalizedString'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, GridCellSystem=None, GridCellCode=None, GridQualifier=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.GridCellSystem = GridCellSystem
        self.validate_String(self.GridCellSystem)
        self.GridCellSystem_nsprefix_ = None
        self.GridCellCode = GridCellCode
        self.validate_String(self.GridCellCode)
        self.GridCellCode_nsprefix_ = None
        self.GridQualifier = GridQualifier
        self.validate_String(self.GridQualifier)
        self.GridQualifier_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CoordinatesGridType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CoordinatesGridType.subclass:
            return CoordinatesGridType.subclass(*args_, **kwargs_)
        else:
            return CoordinatesGridType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_GridCellSystem(self):
        return self.GridCellSystem
    def set_GridCellSystem(self, GridCellSystem):
        self.GridCellSystem = GridCellSystem
    def get_GridCellCode(self):
        return self.GridCellCode
    def set_GridCellCode(self, GridCellCode):
        self.GridCellCode = GridCellCode
    def get_GridQualifier(self):
        return self.GridQualifier
    def set_GridQualifier(self, GridQualifier):
        self.GridQualifier = GridQualifier
    def validate_String(self, value):
        result = True
        # Validate type String, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on String' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.GridCellSystem is not None or
            self.GridCellCode is not None or
            self.GridQualifier is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='CoordinatesGridType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CoordinatesGridType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CoordinatesGridType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CoordinatesGridType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CoordinatesGridType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='CoordinatesGridType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.GridCellSystem is not None:
            namespaceprefix_ = self.GridCellSystem_nsprefix_ + ':' if (UseCapturedNS_ and self.GridCellSystem_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGridCellSystem>%s</%sGridCellSystem>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.GridCellSystem), input_name='GridCellSystem')), namespaceprefix_ , eol_))
        if self.GridCellCode is not None:
            namespaceprefix_ = self.GridCellCode_nsprefix_ + ':' if (UseCapturedNS_ and self.GridCellCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGridCellCode>%s</%sGridCellCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.GridCellCode), input_name='GridCellCode')), namespaceprefix_ , eol_))
        if self.GridQualifier is not None:
            namespaceprefix_ = self.GridQualifier_nsprefix_ + ':' if (UseCapturedNS_ and self.GridQualifier_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGridQualifier>%s</%sGridQualifier>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.GridQualifier), input_name='GridQualifier')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'GridCellSystem':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'GridCellSystem')
            value_ = self.gds_validate_string(value_, node, 'GridCellSystem')
            self.GridCellSystem = value_
            self.GridCellSystem_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.GridCellSystem)
        elif nodeName_ == 'GridCellCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'GridCellCode')
            value_ = self.gds_validate_string(value_, node, 'GridCellCode')
            self.GridCellCode = value_
            self.GridCellCode_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.GridCellCode)
        elif nodeName_ == 'GridQualifier':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'GridQualifier')
            value_ = self.gds_validate_string(value_, node, 'GridQualifier')
            self.GridQualifier = value_
            self.GridQualifier_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.GridQualifier)
# end class CoordinatesGridType


class CoordinatesLatLongType(GeneratedsSuper):
    """Element that allows the recording of the latitude and longitude of a
    recording or collecting position."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('LongitudeDecimal', ['decimalLongitudeDataType', 'xs:double'], 0, 1, {'minOccurs': '0', 'name': 'LongitudeDecimal', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/longitudeDecimal', 'type': 'xs:double'}, None),
        MemberSpec_('VerbatimLongitude', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'VerbatimLongitude', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/longitudeText', 'type': 'xs:string'}, None),
        MemberSpec_('LatitudeDecimal', ['decimalLatitudeDataType', 'xs:double'], 0, 1, {'minOccurs': '0', 'name': 'LatitudeDecimal', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/latitudeDecimal', 'type': 'xs:double'}, None),
        MemberSpec_('VerbatimLatitude', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'VerbatimLatitude', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/latitudeText', 'type': 'xs:string'}, None),
        MemberSpec_('SpatialDatum', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'SpatialDatum', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/spatialDatum', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('Accuracy', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'Accuracy', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Coordinates-Accuracy', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('ErrorDistanceInMeters', 'xs:decimal', 0, 1, {'minOccurs': '0', 'name': 'ErrorDistanceInMeters', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/errorDistanceInMeters', 'type': 'xs:decimal'}, None),
        MemberSpec_('ErrorMethod', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'ErrorMethod', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/errorMethod', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('PointRadiusSpatialFit', ['spatialFitDataType', 'xs:NMTOKEN'], 0, 1, {'minOccurs': '0', 'name': 'PointRadiusSpatialFit', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/pointRadiusSpatialFit', 'type': 'xs:NMTOKEN'}, None),
        MemberSpec_('CoordinatesText', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'CoordinatesText', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/CoordinatesText', 'type': 'xs:normalizedString'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, LongitudeDecimal=None, VerbatimLongitude=None, LatitudeDecimal=None, VerbatimLatitude=None, SpatialDatum=None, Accuracy=None, ErrorDistanceInMeters=None, ErrorMethod=None, PointRadiusSpatialFit=None, CoordinatesText=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.LongitudeDecimal = LongitudeDecimal
        self.validate_decimalLongitudeDataType(self.LongitudeDecimal)
        self.LongitudeDecimal_nsprefix_ = None
        self.VerbatimLongitude = VerbatimLongitude
        self.VerbatimLongitude_nsprefix_ = None
        self.LatitudeDecimal = LatitudeDecimal
        self.validate_decimalLatitudeDataType(self.LatitudeDecimal)
        self.LatitudeDecimal_nsprefix_ = None
        self.VerbatimLatitude = VerbatimLatitude
        self.VerbatimLatitude_nsprefix_ = None
        self.SpatialDatum = SpatialDatum
        self.validate_String(self.SpatialDatum)
        self.SpatialDatum_nsprefix_ = None
        self.Accuracy = Accuracy
        self.validate_String(self.Accuracy)
        self.Accuracy_nsprefix_ = None
        self.ErrorDistanceInMeters = ErrorDistanceInMeters
        self.ErrorDistanceInMeters_nsprefix_ = None
        self.ErrorMethod = ErrorMethod
        self.validate_String(self.ErrorMethod)
        self.ErrorMethod_nsprefix_ = None
        self.PointRadiusSpatialFit = PointRadiusSpatialFit
        self.validate_spatialFitDataType(self.PointRadiusSpatialFit)
        self.PointRadiusSpatialFit_nsprefix_ = None
        self.CoordinatesText = CoordinatesText
        self.validate_String(self.CoordinatesText)
        self.CoordinatesText_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CoordinatesLatLongType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CoordinatesLatLongType.subclass:
            return CoordinatesLatLongType.subclass(*args_, **kwargs_)
        else:
            return CoordinatesLatLongType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_LongitudeDecimal(self):
        return self.LongitudeDecimal
    def set_LongitudeDecimal(self, LongitudeDecimal):
        self.LongitudeDecimal = LongitudeDecimal
    def get_VerbatimLongitude(self):
        return self.VerbatimLongitude
    def set_VerbatimLongitude(self, VerbatimLongitude):
        self.VerbatimLongitude = VerbatimLongitude
    def get_LatitudeDecimal(self):
        return self.LatitudeDecimal
    def set_LatitudeDecimal(self, LatitudeDecimal):
        self.LatitudeDecimal = LatitudeDecimal
    def get_VerbatimLatitude(self):
        return self.VerbatimLatitude
    def set_VerbatimLatitude(self, VerbatimLatitude):
        self.VerbatimLatitude = VerbatimLatitude
    def get_SpatialDatum(self):
        return self.SpatialDatum
    def set_SpatialDatum(self, SpatialDatum):
        self.SpatialDatum = SpatialDatum
    def get_Accuracy(self):
        return self.Accuracy
    def set_Accuracy(self, Accuracy):
        self.Accuracy = Accuracy
    def get_ErrorDistanceInMeters(self):
        return self.ErrorDistanceInMeters
    def set_ErrorDistanceInMeters(self, ErrorDistanceInMeters):
        self.ErrorDistanceInMeters = ErrorDistanceInMeters
    def get_ErrorMethod(self):
        return self.ErrorMethod
    def set_ErrorMethod(self, ErrorMethod):
        self.ErrorMethod = ErrorMethod
    def get_PointRadiusSpatialFit(self):
        return self.PointRadiusSpatialFit
    def set_PointRadiusSpatialFit(self, PointRadiusSpatialFit):
        self.PointRadiusSpatialFit = PointRadiusSpatialFit
    def get_CoordinatesText(self):
        return self.CoordinatesText
    def set_CoordinatesText(self, CoordinatesText):
        self.CoordinatesText = CoordinatesText
    def validate_decimalLongitudeDataType(self, value):
        result = True
        # Validate type decimalLongitudeDataType, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            if value < -180:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on decimalLongitudeDataType' % {"value": value, "lineno": lineno} )
                result = False
            if value > 180:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on decimalLongitudeDataType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_decimalLatitudeDataType(self, value):
        result = True
        # Validate type decimalLatitudeDataType, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            if value < -90:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on decimalLatitudeDataType' % {"value": value, "lineno": lineno} )
                result = False
            if value > 90:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on decimalLatitudeDataType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_String(self, value):
        result = True
        # Validate type String, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on String' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_spatialFitDataType(self, value):
        result = True
        # Validate type spatialFitDataType, a restriction on xs:NMTOKEN.
        pass
        return result
    def hasContent_(self):
        if (
            self.LongitudeDecimal is not None or
            self.VerbatimLongitude is not None or
            self.LatitudeDecimal is not None or
            self.VerbatimLatitude is not None or
            self.SpatialDatum is not None or
            self.Accuracy is not None or
            self.ErrorDistanceInMeters is not None or
            self.ErrorMethod is not None or
            self.PointRadiusSpatialFit is not None or
            self.CoordinatesText is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='CoordinatesLatLongType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CoordinatesLatLongType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CoordinatesLatLongType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CoordinatesLatLongType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CoordinatesLatLongType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='CoordinatesLatLongType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LongitudeDecimal is not None:
            namespaceprefix_ = self.LongitudeDecimal_nsprefix_ + ':' if (UseCapturedNS_ and self.LongitudeDecimal_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLongitudeDecimal>%s</%sLongitudeDecimal>%s' % (namespaceprefix_ , self.gds_format_double(self.LongitudeDecimal, input_name='LongitudeDecimal'), namespaceprefix_ , eol_))
        if self.VerbatimLongitude is not None:
            namespaceprefix_ = self.VerbatimLongitude_nsprefix_ + ':' if (UseCapturedNS_ and self.VerbatimLongitude_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVerbatimLongitude>%s</%sVerbatimLongitude>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.VerbatimLongitude), input_name='VerbatimLongitude')), namespaceprefix_ , eol_))
        if self.LatitudeDecimal is not None:
            namespaceprefix_ = self.LatitudeDecimal_nsprefix_ + ':' if (UseCapturedNS_ and self.LatitudeDecimal_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLatitudeDecimal>%s</%sLatitudeDecimal>%s' % (namespaceprefix_ , self.gds_format_double(self.LatitudeDecimal, input_name='LatitudeDecimal'), namespaceprefix_ , eol_))
        if self.VerbatimLatitude is not None:
            namespaceprefix_ = self.VerbatimLatitude_nsprefix_ + ':' if (UseCapturedNS_ and self.VerbatimLatitude_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVerbatimLatitude>%s</%sVerbatimLatitude>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.VerbatimLatitude), input_name='VerbatimLatitude')), namespaceprefix_ , eol_))
        if self.SpatialDatum is not None:
            namespaceprefix_ = self.SpatialDatum_nsprefix_ + ':' if (UseCapturedNS_ and self.SpatialDatum_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSpatialDatum>%s</%sSpatialDatum>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SpatialDatum), input_name='SpatialDatum')), namespaceprefix_ , eol_))
        if self.Accuracy is not None:
            namespaceprefix_ = self.Accuracy_nsprefix_ + ':' if (UseCapturedNS_ and self.Accuracy_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAccuracy>%s</%sAccuracy>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Accuracy), input_name='Accuracy')), namespaceprefix_ , eol_))
        if self.ErrorDistanceInMeters is not None:
            namespaceprefix_ = self.ErrorDistanceInMeters_nsprefix_ + ':' if (UseCapturedNS_ and self.ErrorDistanceInMeters_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sErrorDistanceInMeters>%s</%sErrorDistanceInMeters>%s' % (namespaceprefix_ , self.gds_format_decimal(self.ErrorDistanceInMeters, input_name='ErrorDistanceInMeters'), namespaceprefix_ , eol_))
        if self.ErrorMethod is not None:
            namespaceprefix_ = self.ErrorMethod_nsprefix_ + ':' if (UseCapturedNS_ and self.ErrorMethod_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sErrorMethod>%s</%sErrorMethod>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ErrorMethod), input_name='ErrorMethod')), namespaceprefix_ , eol_))
        if self.PointRadiusSpatialFit is not None:
            namespaceprefix_ = self.PointRadiusSpatialFit_nsprefix_ + ':' if (UseCapturedNS_ and self.PointRadiusSpatialFit_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPointRadiusSpatialFit>%s</%sPointRadiusSpatialFit>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PointRadiusSpatialFit), input_name='PointRadiusSpatialFit')), namespaceprefix_ , eol_))
        if self.CoordinatesText is not None:
            namespaceprefix_ = self.CoordinatesText_nsprefix_ + ':' if (UseCapturedNS_ and self.CoordinatesText_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCoordinatesText>%s</%sCoordinatesText>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CoordinatesText), input_name='CoordinatesText')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'LongitudeDecimal' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_double(sval_, node, 'LongitudeDecimal')
            fval_ = self.gds_validate_double(fval_, node, 'LongitudeDecimal')
            self.LongitudeDecimal = fval_
            self.LongitudeDecimal_nsprefix_ = child_.prefix
            # validate type decimalLongitudeDataType
            self.validate_decimalLongitudeDataType(self.LongitudeDecimal)
        elif nodeName_ == 'VerbatimLongitude':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'VerbatimLongitude')
            value_ = self.gds_validate_string(value_, node, 'VerbatimLongitude')
            self.VerbatimLongitude = value_
            self.VerbatimLongitude_nsprefix_ = child_.prefix
        elif nodeName_ == 'LatitudeDecimal' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_double(sval_, node, 'LatitudeDecimal')
            fval_ = self.gds_validate_double(fval_, node, 'LatitudeDecimal')
            self.LatitudeDecimal = fval_
            self.LatitudeDecimal_nsprefix_ = child_.prefix
            # validate type decimalLatitudeDataType
            self.validate_decimalLatitudeDataType(self.LatitudeDecimal)
        elif nodeName_ == 'VerbatimLatitude':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'VerbatimLatitude')
            value_ = self.gds_validate_string(value_, node, 'VerbatimLatitude')
            self.VerbatimLatitude = value_
            self.VerbatimLatitude_nsprefix_ = child_.prefix
        elif nodeName_ == 'SpatialDatum':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SpatialDatum')
            value_ = self.gds_validate_string(value_, node, 'SpatialDatum')
            self.SpatialDatum = value_
            self.SpatialDatum_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.SpatialDatum)
        elif nodeName_ == 'Accuracy':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Accuracy')
            value_ = self.gds_validate_string(value_, node, 'Accuracy')
            self.Accuracy = value_
            self.Accuracy_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.Accuracy)
        elif nodeName_ == 'ErrorDistanceInMeters' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_decimal(sval_, node, 'ErrorDistanceInMeters')
            fval_ = self.gds_validate_decimal(fval_, node, 'ErrorDistanceInMeters')
            self.ErrorDistanceInMeters = fval_
            self.ErrorDistanceInMeters_nsprefix_ = child_.prefix
        elif nodeName_ == 'ErrorMethod':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ErrorMethod')
            value_ = self.gds_validate_string(value_, node, 'ErrorMethod')
            self.ErrorMethod = value_
            self.ErrorMethod_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.ErrorMethod)
        elif nodeName_ == 'PointRadiusSpatialFit':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PointRadiusSpatialFit')
            value_ = self.gds_validate_string(value_, node, 'PointRadiusSpatialFit')
            self.PointRadiusSpatialFit = value_
            self.PointRadiusSpatialFit_nsprefix_ = child_.prefix
            # validate type spatialFitDataType
            self.validate_spatialFitDataType(self.PointRadiusSpatialFit)
        elif nodeName_ == 'CoordinatesText':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CoordinatesText')
            value_ = self.gds_validate_string(value_, node, 'CoordinatesText')
            self.CoordinatesText = value_
            self.CoordinatesText_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.CoordinatesText)
# end class CoordinatesLatLongType


class OtherMeasurementsOrFactsType(GeneratedsSuper):
    """Further measurements or facts taken at the collection locality at the
    time of collection, e.g. (water-) temperature, slope, weather
    conditions, etc."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('OtherMeasurementOrFact', 'MeasurementOrFact', 1, 0, {'maxOccurs': 'unbounded', 'name': 'OtherMeasurementOrFact', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Gathering-MeasurementOrFact', 'type': 'MeasurementOrFact'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, OtherMeasurementOrFact=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if OtherMeasurementOrFact is None:
            self.OtherMeasurementOrFact = []
        else:
            self.OtherMeasurementOrFact = OtherMeasurementOrFact
        self.OtherMeasurementOrFact_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OtherMeasurementsOrFactsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OtherMeasurementsOrFactsType.subclass:
            return OtherMeasurementsOrFactsType.subclass(*args_, **kwargs_)
        else:
            return OtherMeasurementsOrFactsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_OtherMeasurementOrFact(self):
        return self.OtherMeasurementOrFact
    def set_OtherMeasurementOrFact(self, OtherMeasurementOrFact):
        self.OtherMeasurementOrFact = OtherMeasurementOrFact
    def add_OtherMeasurementOrFact(self, value):
        self.OtherMeasurementOrFact.append(value)
    def insert_OtherMeasurementOrFact_at(self, index, value):
        self.OtherMeasurementOrFact.insert(index, value)
    def replace_OtherMeasurementOrFact_at(self, index, value):
        self.OtherMeasurementOrFact[index] = value
    def hasContent_(self):
        if (
            self.OtherMeasurementOrFact
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='OtherMeasurementsOrFactsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OtherMeasurementsOrFactsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OtherMeasurementsOrFactsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='OtherMeasurementsOrFactsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='OtherMeasurementsOrFactsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='OtherMeasurementsOrFactsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for OtherMeasurementOrFact_ in self.OtherMeasurementOrFact:
            namespaceprefix_ = self.OtherMeasurementOrFact_nsprefix_ + ':' if (UseCapturedNS_ and self.OtherMeasurementOrFact_nsprefix_) else ''
            OtherMeasurementOrFact_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='OtherMeasurementOrFact', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'OtherMeasurementOrFact':
            obj_ = MeasurementOrFact.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OtherMeasurementOrFact.append(obj_)
            obj_.original_tagname_ = 'OtherMeasurementOrFact'
# end class OtherMeasurementsOrFactsType


class MultimediaObjectsType(GeneratedsSuper):
    """Multimedia objects related to the gathering site"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('MultimediaObject', 'MultimediaObject', 1, 0, {'maxOccurs': 'unbounded', 'name': 'MultimediaObject', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Gathering-MultimediaObject', 'type': 'MultimediaObject'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, MultimediaObject=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if MultimediaObject is None:
            self.MultimediaObject = []
        else:
            self.MultimediaObject = MultimediaObject
        self.MultimediaObject_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MultimediaObjectsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MultimediaObjectsType.subclass:
            return MultimediaObjectsType.subclass(*args_, **kwargs_)
        else:
            return MultimediaObjectsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_MultimediaObject(self):
        return self.MultimediaObject
    def set_MultimediaObject(self, MultimediaObject):
        self.MultimediaObject = MultimediaObject
    def add_MultimediaObject(self, value):
        self.MultimediaObject.append(value)
    def insert_MultimediaObject_at(self, index, value):
        self.MultimediaObject.insert(index, value)
    def replace_MultimediaObject_at(self, index, value):
        self.MultimediaObject[index] = value
    def hasContent_(self):
        if (
            self.MultimediaObject
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='MultimediaObjectsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MultimediaObjectsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MultimediaObjectsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MultimediaObjectsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MultimediaObjectsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='MultimediaObjectsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for MultimediaObject_ in self.MultimediaObject:
            namespaceprefix_ = self.MultimediaObject_nsprefix_ + ':' if (UseCapturedNS_ and self.MultimediaObject_nsprefix_) else ''
            MultimediaObject_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MultimediaObject', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'MultimediaObject':
            obj_ = MultimediaObject.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MultimediaObject.append(obj_)
            obj_.original_tagname_ = 'MultimediaObject'
# end class MultimediaObjectsType


class BiotopeType(GeneratedsSuper):
    """An element for citing biotope type terms (e.g. classification terms) and
    measurements (e.g. vegetation height, salinity, slope) related to the
    unit's gathering site"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('ClassificationScheme', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'ClassificationScheme', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/classificationScheme', 'type': 'StringL'}, None),
        MemberSpec_('Name', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'Name', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Biotope-Name', 'type': 'StringL'}, None),
        MemberSpec_('Text', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'Text', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Biotope-Text', 'type': 'StringL'}, None),
        MemberSpec_('MeasurementsOrFacts', 'MeasurementsOrFactsType', 0, 1, {'minOccurs': '0', 'name': 'MeasurementsOrFacts', 'type': 'MeasurementsOrFactsType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, ClassificationScheme=None, Name=None, Text=None, MeasurementsOrFacts=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ClassificationScheme = ClassificationScheme
        self.ClassificationScheme_nsprefix_ = None
        self.Name = Name
        self.Name_nsprefix_ = None
        self.Text = Text
        self.Text_nsprefix_ = None
        self.MeasurementsOrFacts = MeasurementsOrFacts
        self.MeasurementsOrFacts_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BiotopeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BiotopeType.subclass:
            return BiotopeType.subclass(*args_, **kwargs_)
        else:
            return BiotopeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ClassificationScheme(self):
        return self.ClassificationScheme
    def set_ClassificationScheme(self, ClassificationScheme):
        self.ClassificationScheme = ClassificationScheme
    def get_Name(self):
        return self.Name
    def set_Name(self, Name):
        self.Name = Name
    def get_Text(self):
        return self.Text
    def set_Text(self, Text):
        self.Text = Text
    def get_MeasurementsOrFacts(self):
        return self.MeasurementsOrFacts
    def set_MeasurementsOrFacts(self, MeasurementsOrFacts):
        self.MeasurementsOrFacts = MeasurementsOrFacts
    def hasContent_(self):
        if (
            self.ClassificationScheme is not None or
            self.Name is not None or
            self.Text is not None or
            self.MeasurementsOrFacts is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='BiotopeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BiotopeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BiotopeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BiotopeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BiotopeType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='BiotopeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ClassificationScheme is not None:
            namespaceprefix_ = self.ClassificationScheme_nsprefix_ + ':' if (UseCapturedNS_ and self.ClassificationScheme_nsprefix_) else ''
            self.ClassificationScheme.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ClassificationScheme', pretty_print=pretty_print)
        if self.Name is not None:
            namespaceprefix_ = self.Name_nsprefix_ + ':' if (UseCapturedNS_ and self.Name_nsprefix_) else ''
            self.Name.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Name', pretty_print=pretty_print)
        if self.Text is not None:
            namespaceprefix_ = self.Text_nsprefix_ + ':' if (UseCapturedNS_ and self.Text_nsprefix_) else ''
            self.Text.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Text', pretty_print=pretty_print)
        if self.MeasurementsOrFacts is not None:
            namespaceprefix_ = self.MeasurementsOrFacts_nsprefix_ + ':' if (UseCapturedNS_ and self.MeasurementsOrFacts_nsprefix_) else ''
            self.MeasurementsOrFacts.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MeasurementsOrFacts', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ClassificationScheme':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClassificationScheme = obj_
            obj_.original_tagname_ = 'ClassificationScheme'
        elif nodeName_ == 'Name':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Name = obj_
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'Text':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Text = obj_
            obj_.original_tagname_ = 'Text'
        elif nodeName_ == 'MeasurementsOrFacts':
            obj_ = MeasurementsOrFactsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MeasurementsOrFacts = obj_
            obj_.original_tagname_ = 'MeasurementsOrFacts'
# end class BiotopeType


class MeasurementsOrFactsType(GeneratedsSuper):
    """A container allowing to add any biotope-related measurement to the site
    description (please use the unbounded element for content)."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('MeasurementOrFact', 'MeasurementOrFact', 1, 0, {'maxOccurs': 'unbounded', 'name': 'MeasurementOrFact', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Biotope-MeasurementOrFact', 'type': 'MeasurementOrFact'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, MeasurementOrFact=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if MeasurementOrFact is None:
            self.MeasurementOrFact = []
        else:
            self.MeasurementOrFact = MeasurementOrFact
        self.MeasurementOrFact_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MeasurementsOrFactsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MeasurementsOrFactsType.subclass:
            return MeasurementsOrFactsType.subclass(*args_, **kwargs_)
        else:
            return MeasurementsOrFactsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_MeasurementOrFact(self):
        return self.MeasurementOrFact
    def set_MeasurementOrFact(self, MeasurementOrFact):
        self.MeasurementOrFact = MeasurementOrFact
    def add_MeasurementOrFact(self, value):
        self.MeasurementOrFact.append(value)
    def insert_MeasurementOrFact_at(self, index, value):
        self.MeasurementOrFact.insert(index, value)
    def replace_MeasurementOrFact_at(self, index, value):
        self.MeasurementOrFact[index] = value
    def hasContent_(self):
        if (
            self.MeasurementOrFact
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='MeasurementsOrFactsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MeasurementsOrFactsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MeasurementsOrFactsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MeasurementsOrFactsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MeasurementsOrFactsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='MeasurementsOrFactsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for MeasurementOrFact_ in self.MeasurementOrFact:
            namespaceprefix_ = self.MeasurementOrFact_nsprefix_ + ':' if (UseCapturedNS_ and self.MeasurementOrFact_nsprefix_) else ''
            MeasurementOrFact_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MeasurementOrFact', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'MeasurementOrFact':
            obj_ = MeasurementOrFact.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MeasurementOrFact.append(obj_)
            obj_.original_tagname_ = 'MeasurementOrFact'
# end class MeasurementsOrFactsType


class SynecologyType(GeneratedsSuper):
    """Relationship of the unit gathered with other taxa at the gathering
    site"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('Syntaxon', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'Syntaxon', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/syntaxon', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('Notes', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'Notes', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Synecology-Notes', 'type': 'StringL'}, None),
        MemberSpec_('AssociatedTaxa', 'AssociatedTaxaType', 0, 1, {'minOccurs': '0', 'name': 'AssociatedTaxa', 'type': 'AssociatedTaxaType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, Syntaxon=None, Notes=None, AssociatedTaxa=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Syntaxon = Syntaxon
        self.validate_String(self.Syntaxon)
        self.Syntaxon_nsprefix_ = None
        self.Notes = Notes
        self.Notes_nsprefix_ = None
        self.AssociatedTaxa = AssociatedTaxa
        self.AssociatedTaxa_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SynecologyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SynecologyType.subclass:
            return SynecologyType.subclass(*args_, **kwargs_)
        else:
            return SynecologyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Syntaxon(self):
        return self.Syntaxon
    def set_Syntaxon(self, Syntaxon):
        self.Syntaxon = Syntaxon
    def get_Notes(self):
        return self.Notes
    def set_Notes(self, Notes):
        self.Notes = Notes
    def get_AssociatedTaxa(self):
        return self.AssociatedTaxa
    def set_AssociatedTaxa(self, AssociatedTaxa):
        self.AssociatedTaxa = AssociatedTaxa
    def validate_String(self, value):
        result = True
        # Validate type String, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on String' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.Syntaxon is not None or
            self.Notes is not None or
            self.AssociatedTaxa is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='SynecologyType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SynecologyType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SynecologyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SynecologyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SynecologyType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='SynecologyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Syntaxon is not None:
            namespaceprefix_ = self.Syntaxon_nsprefix_ + ':' if (UseCapturedNS_ and self.Syntaxon_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSyntaxon>%s</%sSyntaxon>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Syntaxon), input_name='Syntaxon')), namespaceprefix_ , eol_))
        if self.Notes is not None:
            namespaceprefix_ = self.Notes_nsprefix_ + ':' if (UseCapturedNS_ and self.Notes_nsprefix_) else ''
            self.Notes.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Notes', pretty_print=pretty_print)
        if self.AssociatedTaxa is not None:
            namespaceprefix_ = self.AssociatedTaxa_nsprefix_ + ':' if (UseCapturedNS_ and self.AssociatedTaxa_nsprefix_) else ''
            self.AssociatedTaxa.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AssociatedTaxa', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Syntaxon':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Syntaxon')
            value_ = self.gds_validate_string(value_, node, 'Syntaxon')
            self.Syntaxon = value_
            self.Syntaxon_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.Syntaxon)
        elif nodeName_ == 'Notes':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Notes = obj_
            obj_.original_tagname_ = 'Notes'
        elif nodeName_ == 'AssociatedTaxa':
            obj_ = AssociatedTaxaType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AssociatedTaxa = obj_
            obj_.original_tagname_ = 'AssociatedTaxa'
# end class SynecologyType


class AssociatedTaxaType(GeneratedsSuper):
    """Other taxa observed at the gathering site"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('AssociatedTaxon', 'TaxonIdentified', 1, 0, {'maxOccurs': 'unbounded', 'name': 'AssociatedTaxon', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Synecology-AssociatedTaxon', 'type': 'TaxonIdentified'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, AssociatedTaxon=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if AssociatedTaxon is None:
            self.AssociatedTaxon = []
        else:
            self.AssociatedTaxon = AssociatedTaxon
        self.AssociatedTaxon_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AssociatedTaxaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AssociatedTaxaType.subclass:
            return AssociatedTaxaType.subclass(*args_, **kwargs_)
        else:
            return AssociatedTaxaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_AssociatedTaxon(self):
        return self.AssociatedTaxon
    def set_AssociatedTaxon(self, AssociatedTaxon):
        self.AssociatedTaxon = AssociatedTaxon
    def add_AssociatedTaxon(self, value):
        self.AssociatedTaxon.append(value)
    def insert_AssociatedTaxon_at(self, index, value):
        self.AssociatedTaxon.insert(index, value)
    def replace_AssociatedTaxon_at(self, index, value):
        self.AssociatedTaxon[index] = value
    def hasContent_(self):
        if (
            self.AssociatedTaxon
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='AssociatedTaxaType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AssociatedTaxaType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AssociatedTaxaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AssociatedTaxaType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AssociatedTaxaType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='AssociatedTaxaType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for AssociatedTaxon_ in self.AssociatedTaxon:
            namespaceprefix_ = self.AssociatedTaxon_nsprefix_ + ':' if (UseCapturedNS_ and self.AssociatedTaxon_nsprefix_) else ''
            AssociatedTaxon_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AssociatedTaxon', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'AssociatedTaxon':
            obj_ = TaxonIdentified.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AssociatedTaxon.append(obj_)
            obj_.original_tagname_ = 'AssociatedTaxon'
# end class AssociatedTaxaType


class ResultType(GeneratedsSuper):
    """The result of the identification, currently either a material
    (substrate) or a taxon name, but in the future to be extended to
    include other types of identifications used in natural history
    collections and surveys."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('TaxonIdentified', 'TaxonIdentified', 0, 1, {'minOccurs': '0', 'name': 'TaxonIdentified', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Identification-TaxonIdentified', 'type': 'TaxonIdentified'}, 4),
        MemberSpec_('MaterialIdentified', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'MaterialIdentified', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/identifiedMaterial', 'type': 'StringL'}, 4),
        MemberSpec_('Extension', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'Extension', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, TaxonIdentified=None, MaterialIdentified=None, Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.TaxonIdentified = TaxonIdentified
        self.TaxonIdentified_nsprefix_ = None
        self.MaterialIdentified = MaterialIdentified
        self.MaterialIdentified_nsprefix_ = None
        self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ResultType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ResultType.subclass:
            return ResultType.subclass(*args_, **kwargs_)
        else:
            return ResultType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_TaxonIdentified(self):
        return self.TaxonIdentified
    def set_TaxonIdentified(self, TaxonIdentified):
        self.TaxonIdentified = TaxonIdentified
    def get_MaterialIdentified(self):
        return self.MaterialIdentified
    def set_MaterialIdentified(self, MaterialIdentified):
        self.MaterialIdentified = MaterialIdentified
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def hasContent_(self):
        if (
            self.TaxonIdentified is not None or
            self.MaterialIdentified is not None or
            self.Extension is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='ResultType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ResultType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ResultType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ResultType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ResultType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='ResultType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TaxonIdentified is not None:
            namespaceprefix_ = self.TaxonIdentified_nsprefix_ + ':' if (UseCapturedNS_ and self.TaxonIdentified_nsprefix_) else ''
            self.TaxonIdentified.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TaxonIdentified', pretty_print=pretty_print)
        if self.MaterialIdentified is not None:
            namespaceprefix_ = self.MaterialIdentified_nsprefix_ + ':' if (UseCapturedNS_ and self.MaterialIdentified_nsprefix_) else ''
            self.MaterialIdentified.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MaterialIdentified', pretty_print=pretty_print)
        if self.Extension is not None:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sExtension>%s</%sExtension>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Extension), input_name='Extension')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'TaxonIdentified':
            obj_ = TaxonIdentified.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TaxonIdentified = obj_
            obj_.original_tagname_ = 'TaxonIdentified'
        elif nodeName_ == 'MaterialIdentified':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MaterialIdentified = obj_
            obj_.original_tagname_ = 'MaterialIdentified'
        elif nodeName_ == 'Extension':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Extension')
            value_ = self.gds_validate_string(value_, node, 'Extension')
            self.Extension = value_
            self.Extension_nsprefix_ = child_.prefix
# end class ResultType


class IdentifiersType(GeneratedsSuper):
    """A container element for several identifiers for this unit."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('sequence', 'xs:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('Identifier', 'Contact', 1, 0, {'maxOccurs': 'unbounded', 'name': 'Identifier', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Identifier', 'type': 'Contact'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, sequence=None, Identifier=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.sequence = _cast(int, sequence)
        self.sequence_nsprefix_ = None
        if Identifier is None:
            self.Identifier = []
        else:
            self.Identifier = Identifier
        self.Identifier_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IdentifiersType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IdentifiersType.subclass:
            return IdentifiersType.subclass(*args_, **kwargs_)
        else:
            return IdentifiersType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Identifier(self):
        return self.Identifier
    def set_Identifier(self, Identifier):
        self.Identifier = Identifier
    def add_Identifier(self, value):
        self.Identifier.append(value)
    def insert_Identifier_at(self, index, value):
        self.Identifier.insert(index, value)
    def replace_Identifier_at(self, index, value):
        self.Identifier[index] = value
    def get_sequence(self):
        return self.sequence
    def set_sequence(self, sequence):
        self.sequence = sequence
    def hasContent_(self):
        if (
            self.Identifier
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='IdentifiersType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IdentifiersType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IdentifiersType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IdentifiersType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IdentifiersType'):
        if self.sequence is not None and 'sequence' not in already_processed:
            already_processed.add('sequence')
            outfile.write(' sequence="%s"' % self.gds_format_integer(self.sequence, input_name='sequence'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='IdentifiersType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Identifier_ in self.Identifier:
            namespaceprefix_ = self.Identifier_nsprefix_ + ':' if (UseCapturedNS_ and self.Identifier_nsprefix_) else ''
            Identifier_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Identifier', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sequence', node)
        if value is not None and 'sequence' not in already_processed:
            already_processed.add('sequence')
            self.sequence = self.gds_parse_integer(value, node, 'sequence')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Identifier':
            class_obj_ = self.get_class_obj_(child_, Contact)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Identifier.append(obj_)
            obj_.original_tagname_ = 'Identifier'
# end class IdentifiersType


class ReferencesType2(GeneratedsSuper):
    """References that were used by the identifier to provide the
    identification (e.g. by means of providing a key or a description of a
    taxon). It circumscribes a particular taxon concept (also referred to
    as a potential taxon) for a given taxonomic name. Note: this is not the
    citation from which and identification was taken, see under
    Identifier/IdentificationSource."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('Reference', 'Reference', 1, 0, {'maxOccurs': 'unbounded', 'name': 'Reference', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Identification-Reference', 'type': 'Reference'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, Reference=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Reference is None:
            self.Reference = []
        else:
            self.Reference = Reference
        self.Reference_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReferencesType2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReferencesType2.subclass:
            return ReferencesType2.subclass(*args_, **kwargs_)
        else:
            return ReferencesType2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Reference(self):
        return self.Reference
    def set_Reference(self, Reference):
        self.Reference = Reference
    def add_Reference(self, value):
        self.Reference.append(value)
    def insert_Reference_at(self, index, value):
        self.Reference.insert(index, value)
    def replace_Reference_at(self, index, value):
        self.Reference[index] = value
    def hasContent_(self):
        if (
            self.Reference
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='ReferencesType2', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReferencesType2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReferencesType2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ReferencesType2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ReferencesType2'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='ReferencesType2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Reference_ in self.Reference:
            namespaceprefix_ = self.Reference_nsprefix_ + ':' if (UseCapturedNS_ and self.Reference_nsprefix_) else ''
            Reference_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Reference', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Reference':
            obj_ = Reference.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Reference.append(obj_)
            obj_.original_tagname_ = 'Reference'
# end class ReferencesType2


class ContentContactsType3(GeneratedsSuper):
    """Container element for one to many content contacts for the unit record.
    If present, overrides the equivalent ContentContact on the level of
    dataset."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('ContentContact', 'ContentContactType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'ContentContact', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Unit-ContentContact', 'type': 'ContentContactType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, ContentContact=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ContentContact is None:
            self.ContentContact = []
        else:
            self.ContentContact = ContentContact
        self.ContentContact_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContentContactsType3)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContentContactsType3.subclass:
            return ContentContactsType3.subclass(*args_, **kwargs_)
        else:
            return ContentContactsType3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ContentContact(self):
        return self.ContentContact
    def set_ContentContact(self, ContentContact):
        self.ContentContact = ContentContact
    def add_ContentContact(self, value):
        self.ContentContact.append(value)
    def insert_ContentContact_at(self, index, value):
        self.ContentContact.insert(index, value)
    def replace_ContentContact_at(self, index, value):
        self.ContentContact[index] = value
    def hasContent_(self):
        if (
            self.ContentContact
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='ContentContactsType3', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ContentContactsType3')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ContentContactsType3')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ContentContactsType3', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ContentContactsType3'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='ContentContactsType3', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ContentContact_ in self.ContentContact:
            namespaceprefix_ = self.ContentContact_nsprefix_ + ':' if (UseCapturedNS_ and self.ContentContact_nsprefix_) else ''
            ContentContact_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ContentContact', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ContentContact':
            obj_ = ContentContactType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ContentContact.append(obj_)
            obj_.original_tagname_ = 'ContentContact'
# end class ContentContactsType3


class ContentContactType(Contact):
    """Questions and feedback about data, or restrictions on use of the data
    should be directed to the contact given here. If present, overrides the
    equivalent ContentContact on the level of dataset."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('preferred', 'xs:boolean', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = Contact
    def __init__(self, UnformattedValue=None, Organization=None, Person=None, Roles=None, Addresses=None, TelephoneNumbers=None, EmailAddresses=None, WebsiteURL=None, ResourceURIs=None, preferred=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ContentContactType, self).__init__(UnformattedValue, Organization, Person, Roles, Addresses, TelephoneNumbers, EmailAddresses, WebsiteURL, ResourceURIs,  **kwargs_)
        self.preferred = _cast(bool, preferred)
        self.preferred_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContentContactType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContentContactType.subclass:
            return ContentContactType.subclass(*args_, **kwargs_)
        else:
            return ContentContactType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_preferred(self):
        return self.preferred
    def set_preferred(self, preferred):
        self.preferred = preferred
    def hasContent_(self):
        if (
            super(ContentContactType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ContentContactType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ContentContactType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ContentContactType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ContentContactType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ContentContactType'):
        super(ContentContactType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ContentContactType')
        if self.preferred is not None and 'preferred' not in already_processed:
            already_processed.add('preferred')
            outfile.write(' preferred="%s"' % self.gds_format_boolean(self.preferred, input_name='preferred'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ContentContactType', fromsubclass_=False, pretty_print=True):
        super(ContentContactType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('preferred', node)
        if value is not None and 'preferred' not in already_processed:
            already_processed.add('preferred')
            if value in ('true', '1'):
                self.preferred = True
            elif value in ('false', '0'):
                self.preferred = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(ContentContactType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ContentContactType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ContentContactType


class UnitReferencesType(GeneratedsSuper):
    """Container element for references citing the unit See SourceReference for
    the case that the record is based on a publication."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('UnitReference', 'Reference', 1, 0, {'maxOccurs': 'unbounded', 'name': 'UnitReference', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Unit-Reference', 'type': 'Reference'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, UnitReference=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if UnitReference is None:
            self.UnitReference = []
        else:
            self.UnitReference = UnitReference
        self.UnitReference_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UnitReferencesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UnitReferencesType.subclass:
            return UnitReferencesType.subclass(*args_, **kwargs_)
        else:
            return UnitReferencesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_UnitReference(self):
        return self.UnitReference
    def set_UnitReference(self, UnitReference):
        self.UnitReference = UnitReference
    def add_UnitReference(self, value):
        self.UnitReference.append(value)
    def insert_UnitReference_at(self, index, value):
        self.UnitReference.insert(index, value)
    def replace_UnitReference_at(self, index, value):
        self.UnitReference[index] = value
    def hasContent_(self):
        if (
            self.UnitReference
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='UnitReferencesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('UnitReferencesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UnitReferencesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='UnitReferencesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='UnitReferencesType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='UnitReferencesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for UnitReference_ in self.UnitReference:
            namespaceprefix_ = self.UnitReference_nsprefix_ + ':' if (UseCapturedNS_ and self.UnitReference_nsprefix_) else ''
            UnitReference_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='UnitReference', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'UnitReference':
            obj_ = Reference.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.UnitReference.append(obj_)
            obj_.original_tagname_ = 'UnitReference'
# end class UnitReferencesType


class IdentificationsType(GeneratedsSuper):
    """Container element for identification events, i.e. the circumstances and
    result of assigning a name to the unit."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('Identification', 'Identification', 1, 0, {'maxOccurs': 'unbounded', 'name': 'Identification', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Unit-Identification', 'type': 'Identification'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, Identification=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Identification is None:
            self.Identification = []
        else:
            self.Identification = Identification
        self.Identification_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IdentificationsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IdentificationsType.subclass:
            return IdentificationsType.subclass(*args_, **kwargs_)
        else:
            return IdentificationsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Identification(self):
        return self.Identification
    def set_Identification(self, Identification):
        self.Identification = Identification
    def add_Identification(self, value):
        self.Identification.append(value)
    def insert_Identification_at(self, index, value):
        self.Identification.insert(index, value)
    def replace_Identification_at(self, index, value):
        self.Identification[index] = value
    def hasContent_(self):
        if (
            self.Identification
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='IdentificationsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IdentificationsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IdentificationsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IdentificationsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IdentificationsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='IdentificationsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Identification_ in self.Identification:
            namespaceprefix_ = self.Identification_nsprefix_ + ':' if (UseCapturedNS_ and self.Identification_nsprefix_) else ''
            Identification_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Identification', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Identification':
            obj_ = Identification.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Identification.append(obj_)
            obj_.original_tagname_ = 'Identification'
# end class IdentificationsType


class SpecimenUnitType(GeneratedsSuper):
    """A Unit subtype containing data elements specific to specimens (living,
    fossil, or preserved)."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('Owner', 'Contact', 0, 1, {'minOccurs': '0', 'name': 'Owner', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/SpecimenUnit-Owner', 'type': 'Contact'}, None),
        MemberSpec_('LoanRestrictions', 'LoanRestrictionsType', 0, 1, {'minOccurs': '0', 'name': 'LoanRestrictions', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/LoanRestrictions', 'type': 'LoanRestrictionsType'}, None),
        MemberSpec_('Acquisition', 'AcquisitionType', 0, 1, {'minOccurs': '0', 'name': 'Acquisition', 'type': 'AcquisitionType'}, None),
        MemberSpec_('Accessions', 'AccessionsType', 0, 1, {'minOccurs': '0', 'name': 'Accessions', 'type': 'AccessionsType'}, None),
        MemberSpec_('Preparations', 'PreparationsType', 0, 1, {'minOccurs': '0', 'name': 'Preparations', 'type': 'PreparationsType'}, None),
        MemberSpec_('PreparationsText', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'PreparationsText', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/preparationsText', 'type': 'StringL'}, None),
        MemberSpec_('Preservations', 'PreservationsType', 0, 1, {'minOccurs': '0', 'name': 'Preservations', 'type': 'PreservationsType'}, None),
        MemberSpec_('Marks', 'MarksType', 0, 1, {'minOccurs': '0', 'name': 'Marks', 'type': 'MarksType'}, None),
        MemberSpec_('PreviousUnits', 'PreviousUnitsType', 0, 1, {'minOccurs': '0', 'name': 'PreviousUnits', 'type': 'PreviousUnitsType'}, None),
        MemberSpec_('PreviousUnitsText', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'PreviousUnitsText', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/previousUnitsText', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('NomenclaturalTypeDesignations', 'NomenclaturalTypeDesignationsType', 0, 1, {'minOccurs': '0', 'name': 'NomenclaturalTypeDesignations', 'type': 'NomenclaturalTypeDesignationsType'}, None),
        MemberSpec_('NomenclaturalTypeText', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'NomenclaturalTypeText', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/nomenclaturalTypeText', 'type': 'StringL'}, None),
        MemberSpec_('DuplicatesDistributedTo', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'DuplicatesDistributedTo', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/duplicatesDistributedTo', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('Disposition', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'Disposition', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/disposition', 'type': 'StringL'}, None),
        MemberSpec_('SpecimenMeasurementsOrFacts', 'SpecimenMeasurementsOrFactsType', 0, 1, {'minOccurs': '0', 'name': 'SpecimenMeasurementsOrFacts', 'type': 'SpecimenMeasurementsOrFactsType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, Owner=None, LoanRestrictions=None, Acquisition=None, Accessions=None, Preparations=None, PreparationsText=None, Preservations=None, Marks=None, PreviousUnits=None, PreviousUnitsText=None, NomenclaturalTypeDesignations=None, NomenclaturalTypeText=None, DuplicatesDistributedTo=None, Disposition=None, SpecimenMeasurementsOrFacts=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Owner = Owner
        self.Owner_nsprefix_ = None
        self.LoanRestrictions = LoanRestrictions
        self.LoanRestrictions_nsprefix_ = None
        self.Acquisition = Acquisition
        self.Acquisition_nsprefix_ = None
        self.Accessions = Accessions
        self.Accessions_nsprefix_ = None
        self.Preparations = Preparations
        self.Preparations_nsprefix_ = None
        self.PreparationsText = PreparationsText
        self.PreparationsText_nsprefix_ = None
        self.Preservations = Preservations
        self.Preservations_nsprefix_ = None
        self.Marks = Marks
        self.Marks_nsprefix_ = None
        self.PreviousUnits = PreviousUnits
        self.PreviousUnits_nsprefix_ = None
        self.PreviousUnitsText = PreviousUnitsText
        self.validate_String(self.PreviousUnitsText)
        self.PreviousUnitsText_nsprefix_ = None
        self.NomenclaturalTypeDesignations = NomenclaturalTypeDesignations
        self.NomenclaturalTypeDesignations_nsprefix_ = None
        self.NomenclaturalTypeText = NomenclaturalTypeText
        self.NomenclaturalTypeText_nsprefix_ = None
        self.DuplicatesDistributedTo = DuplicatesDistributedTo
        self.validate_String(self.DuplicatesDistributedTo)
        self.DuplicatesDistributedTo_nsprefix_ = None
        self.Disposition = Disposition
        self.Disposition_nsprefix_ = None
        self.SpecimenMeasurementsOrFacts = SpecimenMeasurementsOrFacts
        self.SpecimenMeasurementsOrFacts_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SpecimenUnitType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SpecimenUnitType.subclass:
            return SpecimenUnitType.subclass(*args_, **kwargs_)
        else:
            return SpecimenUnitType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Owner(self):
        return self.Owner
    def set_Owner(self, Owner):
        self.Owner = Owner
    def get_LoanRestrictions(self):
        return self.LoanRestrictions
    def set_LoanRestrictions(self, LoanRestrictions):
        self.LoanRestrictions = LoanRestrictions
    def get_Acquisition(self):
        return self.Acquisition
    def set_Acquisition(self, Acquisition):
        self.Acquisition = Acquisition
    def get_Accessions(self):
        return self.Accessions
    def set_Accessions(self, Accessions):
        self.Accessions = Accessions
    def get_Preparations(self):
        return self.Preparations
    def set_Preparations(self, Preparations):
        self.Preparations = Preparations
    def get_PreparationsText(self):
        return self.PreparationsText
    def set_PreparationsText(self, PreparationsText):
        self.PreparationsText = PreparationsText
    def get_Preservations(self):
        return self.Preservations
    def set_Preservations(self, Preservations):
        self.Preservations = Preservations
    def get_Marks(self):
        return self.Marks
    def set_Marks(self, Marks):
        self.Marks = Marks
    def get_PreviousUnits(self):
        return self.PreviousUnits
    def set_PreviousUnits(self, PreviousUnits):
        self.PreviousUnits = PreviousUnits
    def get_PreviousUnitsText(self):
        return self.PreviousUnitsText
    def set_PreviousUnitsText(self, PreviousUnitsText):
        self.PreviousUnitsText = PreviousUnitsText
    def get_NomenclaturalTypeDesignations(self):
        return self.NomenclaturalTypeDesignations
    def set_NomenclaturalTypeDesignations(self, NomenclaturalTypeDesignations):
        self.NomenclaturalTypeDesignations = NomenclaturalTypeDesignations
    def get_NomenclaturalTypeText(self):
        return self.NomenclaturalTypeText
    def set_NomenclaturalTypeText(self, NomenclaturalTypeText):
        self.NomenclaturalTypeText = NomenclaturalTypeText
    def get_DuplicatesDistributedTo(self):
        return self.DuplicatesDistributedTo
    def set_DuplicatesDistributedTo(self, DuplicatesDistributedTo):
        self.DuplicatesDistributedTo = DuplicatesDistributedTo
    def get_Disposition(self):
        return self.Disposition
    def set_Disposition(self, Disposition):
        self.Disposition = Disposition
    def get_SpecimenMeasurementsOrFacts(self):
        return self.SpecimenMeasurementsOrFacts
    def set_SpecimenMeasurementsOrFacts(self, SpecimenMeasurementsOrFacts):
        self.SpecimenMeasurementsOrFacts = SpecimenMeasurementsOrFacts
    def validate_String(self, value):
        result = True
        # Validate type String, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on String' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.Owner is not None or
            self.LoanRestrictions is not None or
            self.Acquisition is not None or
            self.Accessions is not None or
            self.Preparations is not None or
            self.PreparationsText is not None or
            self.Preservations is not None or
            self.Marks is not None or
            self.PreviousUnits is not None or
            self.PreviousUnitsText is not None or
            self.NomenclaturalTypeDesignations is not None or
            self.NomenclaturalTypeText is not None or
            self.DuplicatesDistributedTo is not None or
            self.Disposition is not None or
            self.SpecimenMeasurementsOrFacts is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='SpecimenUnitType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SpecimenUnitType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SpecimenUnitType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SpecimenUnitType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SpecimenUnitType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='SpecimenUnitType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Owner is not None:
            namespaceprefix_ = self.Owner_nsprefix_ + ':' if (UseCapturedNS_ and self.Owner_nsprefix_) else ''
            self.Owner.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Owner', pretty_print=pretty_print)
        if self.LoanRestrictions is not None:
            namespaceprefix_ = self.LoanRestrictions_nsprefix_ + ':' if (UseCapturedNS_ and self.LoanRestrictions_nsprefix_) else ''
            self.LoanRestrictions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LoanRestrictions', pretty_print=pretty_print)
        if self.Acquisition is not None:
            namespaceprefix_ = self.Acquisition_nsprefix_ + ':' if (UseCapturedNS_ and self.Acquisition_nsprefix_) else ''
            self.Acquisition.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Acquisition', pretty_print=pretty_print)
        if self.Accessions is not None:
            namespaceprefix_ = self.Accessions_nsprefix_ + ':' if (UseCapturedNS_ and self.Accessions_nsprefix_) else ''
            self.Accessions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Accessions', pretty_print=pretty_print)
        if self.Preparations is not None:
            namespaceprefix_ = self.Preparations_nsprefix_ + ':' if (UseCapturedNS_ and self.Preparations_nsprefix_) else ''
            self.Preparations.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Preparations', pretty_print=pretty_print)
        if self.PreparationsText is not None:
            namespaceprefix_ = self.PreparationsText_nsprefix_ + ':' if (UseCapturedNS_ and self.PreparationsText_nsprefix_) else ''
            self.PreparationsText.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PreparationsText', pretty_print=pretty_print)
        if self.Preservations is not None:
            namespaceprefix_ = self.Preservations_nsprefix_ + ':' if (UseCapturedNS_ and self.Preservations_nsprefix_) else ''
            self.Preservations.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Preservations', pretty_print=pretty_print)
        if self.Marks is not None:
            namespaceprefix_ = self.Marks_nsprefix_ + ':' if (UseCapturedNS_ and self.Marks_nsprefix_) else ''
            self.Marks.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Marks', pretty_print=pretty_print)
        if self.PreviousUnits is not None:
            namespaceprefix_ = self.PreviousUnits_nsprefix_ + ':' if (UseCapturedNS_ and self.PreviousUnits_nsprefix_) else ''
            self.PreviousUnits.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PreviousUnits', pretty_print=pretty_print)
        if self.PreviousUnitsText is not None:
            namespaceprefix_ = self.PreviousUnitsText_nsprefix_ + ':' if (UseCapturedNS_ and self.PreviousUnitsText_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPreviousUnitsText>%s</%sPreviousUnitsText>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PreviousUnitsText), input_name='PreviousUnitsText')), namespaceprefix_ , eol_))
        if self.NomenclaturalTypeDesignations is not None:
            namespaceprefix_ = self.NomenclaturalTypeDesignations_nsprefix_ + ':' if (UseCapturedNS_ and self.NomenclaturalTypeDesignations_nsprefix_) else ''
            self.NomenclaturalTypeDesignations.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NomenclaturalTypeDesignations', pretty_print=pretty_print)
        if self.NomenclaturalTypeText is not None:
            namespaceprefix_ = self.NomenclaturalTypeText_nsprefix_ + ':' if (UseCapturedNS_ and self.NomenclaturalTypeText_nsprefix_) else ''
            self.NomenclaturalTypeText.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NomenclaturalTypeText', pretty_print=pretty_print)
        if self.DuplicatesDistributedTo is not None:
            namespaceprefix_ = self.DuplicatesDistributedTo_nsprefix_ + ':' if (UseCapturedNS_ and self.DuplicatesDistributedTo_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDuplicatesDistributedTo>%s</%sDuplicatesDistributedTo>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DuplicatesDistributedTo), input_name='DuplicatesDistributedTo')), namespaceprefix_ , eol_))
        if self.Disposition is not None:
            namespaceprefix_ = self.Disposition_nsprefix_ + ':' if (UseCapturedNS_ and self.Disposition_nsprefix_) else ''
            self.Disposition.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Disposition', pretty_print=pretty_print)
        if self.SpecimenMeasurementsOrFacts is not None:
            namespaceprefix_ = self.SpecimenMeasurementsOrFacts_nsprefix_ + ':' if (UseCapturedNS_ and self.SpecimenMeasurementsOrFacts_nsprefix_) else ''
            self.SpecimenMeasurementsOrFacts.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SpecimenMeasurementsOrFacts', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Owner':
            class_obj_ = self.get_class_obj_(child_, Contact)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Owner = obj_
            obj_.original_tagname_ = 'Owner'
        elif nodeName_ == 'LoanRestrictions':
            obj_ = LoanRestrictionsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LoanRestrictions = obj_
            obj_.original_tagname_ = 'LoanRestrictions'
        elif nodeName_ == 'Acquisition':
            obj_ = AcquisitionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Acquisition = obj_
            obj_.original_tagname_ = 'Acquisition'
        elif nodeName_ == 'Accessions':
            obj_ = AccessionsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Accessions = obj_
            obj_.original_tagname_ = 'Accessions'
        elif nodeName_ == 'Preparations':
            obj_ = PreparationsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Preparations = obj_
            obj_.original_tagname_ = 'Preparations'
        elif nodeName_ == 'PreparationsText':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PreparationsText = obj_
            obj_.original_tagname_ = 'PreparationsText'
        elif nodeName_ == 'Preservations':
            obj_ = PreservationsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Preservations = obj_
            obj_.original_tagname_ = 'Preservations'
        elif nodeName_ == 'Marks':
            obj_ = MarksType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Marks = obj_
            obj_.original_tagname_ = 'Marks'
        elif nodeName_ == 'PreviousUnits':
            obj_ = PreviousUnitsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PreviousUnits = obj_
            obj_.original_tagname_ = 'PreviousUnits'
        elif nodeName_ == 'PreviousUnitsText':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PreviousUnitsText')
            value_ = self.gds_validate_string(value_, node, 'PreviousUnitsText')
            self.PreviousUnitsText = value_
            self.PreviousUnitsText_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.PreviousUnitsText)
        elif nodeName_ == 'NomenclaturalTypeDesignations':
            obj_ = NomenclaturalTypeDesignationsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NomenclaturalTypeDesignations = obj_
            obj_.original_tagname_ = 'NomenclaturalTypeDesignations'
        elif nodeName_ == 'NomenclaturalTypeText':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NomenclaturalTypeText = obj_
            obj_.original_tagname_ = 'NomenclaturalTypeText'
        elif nodeName_ == 'DuplicatesDistributedTo':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DuplicatesDistributedTo')
            value_ = self.gds_validate_string(value_, node, 'DuplicatesDistributedTo')
            self.DuplicatesDistributedTo = value_
            self.DuplicatesDistributedTo_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.DuplicatesDistributedTo)
        elif nodeName_ == 'Disposition':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Disposition = obj_
            obj_.original_tagname_ = 'Disposition'
        elif nodeName_ == 'SpecimenMeasurementsOrFacts':
            obj_ = SpecimenMeasurementsOrFactsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SpecimenMeasurementsOrFacts = obj_
            obj_.original_tagname_ = 'SpecimenMeasurementsOrFacts'
# end class SpecimenUnitType


class LoanRestrictionsType(GeneratedsSuper):
    """Restrictions for accessing or loaning the specimen or sample."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('BlockedUntil', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'BlockedUntil', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/BlockedUntil', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('Blocked', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'Blocked', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/blocked', 'type': 'xs:boolean'}, None),
        MemberSpec_('LoanConditions', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'LoanConditions', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/loanConditions', 'type': 'xs:normalizedString'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, BlockedUntil=None, Blocked=None, LoanConditions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.BlockedUntil = BlockedUntil
        self.validate_String(self.BlockedUntil)
        self.BlockedUntil_nsprefix_ = None
        self.Blocked = Blocked
        self.Blocked_nsprefix_ = None
        self.LoanConditions = LoanConditions
        self.validate_String(self.LoanConditions)
        self.LoanConditions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LoanRestrictionsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LoanRestrictionsType.subclass:
            return LoanRestrictionsType.subclass(*args_, **kwargs_)
        else:
            return LoanRestrictionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_BlockedUntil(self):
        return self.BlockedUntil
    def set_BlockedUntil(self, BlockedUntil):
        self.BlockedUntil = BlockedUntil
    def get_Blocked(self):
        return self.Blocked
    def set_Blocked(self, Blocked):
        self.Blocked = Blocked
    def get_LoanConditions(self):
        return self.LoanConditions
    def set_LoanConditions(self, LoanConditions):
        self.LoanConditions = LoanConditions
    def validate_String(self, value):
        result = True
        # Validate type String, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on String' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.BlockedUntil is not None or
            self.Blocked is not None or
            self.LoanConditions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='LoanRestrictionsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LoanRestrictionsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LoanRestrictionsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LoanRestrictionsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LoanRestrictionsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='LoanRestrictionsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.BlockedUntil is not None:
            namespaceprefix_ = self.BlockedUntil_nsprefix_ + ':' if (UseCapturedNS_ and self.BlockedUntil_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBlockedUntil>%s</%sBlockedUntil>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.BlockedUntil), input_name='BlockedUntil')), namespaceprefix_ , eol_))
        if self.Blocked is not None:
            namespaceprefix_ = self.Blocked_nsprefix_ + ':' if (UseCapturedNS_ and self.Blocked_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBlocked>%s</%sBlocked>%s' % (namespaceprefix_ , self.gds_format_boolean(self.Blocked, input_name='Blocked'), namespaceprefix_ , eol_))
        if self.LoanConditions is not None:
            namespaceprefix_ = self.LoanConditions_nsprefix_ + ':' if (UseCapturedNS_ and self.LoanConditions_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLoanConditions>%s</%sLoanConditions>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.LoanConditions), input_name='LoanConditions')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'BlockedUntil':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'BlockedUntil')
            value_ = self.gds_validate_string(value_, node, 'BlockedUntil')
            self.BlockedUntil = value_
            self.BlockedUntil_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.BlockedUntil)
        elif nodeName_ == 'Blocked':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'Blocked')
            ival_ = self.gds_validate_boolean(ival_, node, 'Blocked')
            self.Blocked = ival_
            self.Blocked_nsprefix_ = child_.prefix
        elif nodeName_ == 'LoanConditions':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'LoanConditions')
            value_ = self.gds_validate_string(value_, node, 'LoanConditions')
            self.LoanConditions = value_
            self.LoanConditions_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.LoanConditions)
# end class LoanRestrictionsType


class AcquisitionType(GeneratedsSuper):
    """Acquisition date, source and type."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('AcquisitionType', 'AcquisitionType', 0, 1, {'minOccurs': '0', 'name': 'AcquisitionType', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/acquisitionType', 'type': 'StringL'}, None),
        MemberSpec_('Date', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'Date', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Acquisition-Date', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('AcquiredFrom', 'Contact', 0, 1, {'minOccurs': '0', 'name': 'AcquiredFrom', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/AcquiredFrom', 'type': 'Contact'}, None),
        MemberSpec_('AcquisitionSourceText', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'AcquisitionSourceText', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/acquisitionSourceText', 'type': 'StringL'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, AcquisitionType_member=None, Date=None, AcquiredFrom=None, AcquisitionSourceText=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.AcquisitionType = AcquisitionType_member
        self.AcquisitionType_nsprefix_ = None
        self.Date = Date
        self.validate_String(self.Date)
        self.Date_nsprefix_ = None
        self.AcquiredFrom = AcquiredFrom
        self.AcquiredFrom_nsprefix_ = None
        self.AcquisitionSourceText = AcquisitionSourceText
        self.AcquisitionSourceText_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AcquisitionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AcquisitionType.subclass:
            return AcquisitionType.subclass(*args_, **kwargs_)
        else:
            return AcquisitionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_AcquisitionType(self):
        return self.AcquisitionType
    def set_AcquisitionType(self, AcquisitionType):
        self.AcquisitionType = AcquisitionType
    def get_Date(self):
        return self.Date
    def set_Date(self, Date):
        self.Date = Date
    def get_AcquiredFrom(self):
        return self.AcquiredFrom
    def set_AcquiredFrom(self, AcquiredFrom):
        self.AcquiredFrom = AcquiredFrom
    def get_AcquisitionSourceText(self):
        return self.AcquisitionSourceText
    def set_AcquisitionSourceText(self, AcquisitionSourceText):
        self.AcquisitionSourceText = AcquisitionSourceText
    def validate_String(self, value):
        result = True
        # Validate type String, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on String' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.AcquisitionType is not None or
            self.Date is not None or
            self.AcquiredFrom is not None or
            self.AcquisitionSourceText is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='AcquisitionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AcquisitionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AcquisitionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AcquisitionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AcquisitionType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='AcquisitionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AcquisitionType is not None:
            namespaceprefix_ = self.AcquisitionType_nsprefix_ + ':' if (UseCapturedNS_ and self.AcquisitionType_nsprefix_) else ''
            self.AcquisitionType.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AcquisitionType', pretty_print=pretty_print)
        if self.Date is not None:
            namespaceprefix_ = self.Date_nsprefix_ + ':' if (UseCapturedNS_ and self.Date_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDate>%s</%sDate>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Date), input_name='Date')), namespaceprefix_ , eol_))
        if self.AcquiredFrom is not None:
            namespaceprefix_ = self.AcquiredFrom_nsprefix_ + ':' if (UseCapturedNS_ and self.AcquiredFrom_nsprefix_) else ''
            self.AcquiredFrom.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AcquiredFrom', pretty_print=pretty_print)
        if self.AcquisitionSourceText is not None:
            namespaceprefix_ = self.AcquisitionSourceText_nsprefix_ + ':' if (UseCapturedNS_ and self.AcquisitionSourceText_nsprefix_) else ''
            self.AcquisitionSourceText.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AcquisitionSourceText', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'AcquisitionType':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AcquisitionType = obj_
            obj_.original_tagname_ = 'AcquisitionType'
        elif nodeName_ == 'Date':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Date')
            value_ = self.gds_validate_string(value_, node, 'Date')
            self.Date = value_
            self.Date_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.Date)
        elif nodeName_ == 'AcquiredFrom':
            class_obj_ = self.get_class_obj_(child_, Contact)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AcquiredFrom = obj_
            obj_.original_tagname_ = 'AcquiredFrom'
        elif nodeName_ == 'AcquisitionSourceText':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AcquisitionSourceText = obj_
            obj_.original_tagname_ = 'AcquisitionSourceText'
# end class AcquisitionType


class AccessionsType(GeneratedsSuper):
    """Accession details."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('Accession', 'AccessionType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'Accession', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/Accession', 'type': 'AccessionType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, Accession=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Accession is None:
            self.Accession = []
        else:
            self.Accession = Accession
        self.Accession_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AccessionsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AccessionsType.subclass:
            return AccessionsType.subclass(*args_, **kwargs_)
        else:
            return AccessionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Accession(self):
        return self.Accession
    def set_Accession(self, Accession):
        self.Accession = Accession
    def add_Accession(self, value):
        self.Accession.append(value)
    def insert_Accession_at(self, index, value):
        self.Accession.insert(index, value)
    def replace_Accession_at(self, index, value):
        self.Accession[index] = value
    def hasContent_(self):
        if (
            self.Accession
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='AccessionsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AccessionsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AccessionsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AccessionsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AccessionsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='AccessionsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Accession_ in self.Accession:
            namespaceprefix_ = self.Accession_nsprefix_ + ':' if (UseCapturedNS_ and self.Accession_nsprefix_) else ''
            Accession_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Accession', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Accession':
            obj_ = AccessionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Accession.append(obj_)
            obj_.original_tagname_ = 'Accession'
# end class AccessionsType


class AccessionType(GeneratedsSuper):
    """Triple to accommodate accession number in multiple catalogues."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('AccessionDate', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'AccessionDate', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Accession-Date', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('AccessionCatalogue', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'AccessionCatalogue', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/accessionCatalogue', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('AccessionNumber', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'AccessionNumber', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/accessionNumber', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('AccessionURI', 'xs:anyURI', 0, 1, {'minOccurs': '0', 'name': 'AccessionURI', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Accession-URI', 'type': 'xs:anyURI'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, AccessionDate=None, AccessionCatalogue=None, AccessionNumber=None, AccessionURI=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.AccessionDate = AccessionDate
        self.validate_String(self.AccessionDate)
        self.AccessionDate_nsprefix_ = None
        self.AccessionCatalogue = AccessionCatalogue
        self.validate_String(self.AccessionCatalogue)
        self.AccessionCatalogue_nsprefix_ = None
        self.AccessionNumber = AccessionNumber
        self.validate_String(self.AccessionNumber)
        self.AccessionNumber_nsprefix_ = None
        self.AccessionURI = AccessionURI
        self.AccessionURI_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AccessionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AccessionType.subclass:
            return AccessionType.subclass(*args_, **kwargs_)
        else:
            return AccessionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_AccessionDate(self):
        return self.AccessionDate
    def set_AccessionDate(self, AccessionDate):
        self.AccessionDate = AccessionDate
    def get_AccessionCatalogue(self):
        return self.AccessionCatalogue
    def set_AccessionCatalogue(self, AccessionCatalogue):
        self.AccessionCatalogue = AccessionCatalogue
    def get_AccessionNumber(self):
        return self.AccessionNumber
    def set_AccessionNumber(self, AccessionNumber):
        self.AccessionNumber = AccessionNumber
    def get_AccessionURI(self):
        return self.AccessionURI
    def set_AccessionURI(self, AccessionURI):
        self.AccessionURI = AccessionURI
    def validate_String(self, value):
        result = True
        # Validate type String, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on String' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.AccessionDate is not None or
            self.AccessionCatalogue is not None or
            self.AccessionNumber is not None or
            self.AccessionURI is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='AccessionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AccessionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AccessionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AccessionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AccessionType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='AccessionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AccessionDate is not None:
            namespaceprefix_ = self.AccessionDate_nsprefix_ + ':' if (UseCapturedNS_ and self.AccessionDate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAccessionDate>%s</%sAccessionDate>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.AccessionDate), input_name='AccessionDate')), namespaceprefix_ , eol_))
        if self.AccessionCatalogue is not None:
            namespaceprefix_ = self.AccessionCatalogue_nsprefix_ + ':' if (UseCapturedNS_ and self.AccessionCatalogue_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAccessionCatalogue>%s</%sAccessionCatalogue>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.AccessionCatalogue), input_name='AccessionCatalogue')), namespaceprefix_ , eol_))
        if self.AccessionNumber is not None:
            namespaceprefix_ = self.AccessionNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.AccessionNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAccessionNumber>%s</%sAccessionNumber>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.AccessionNumber), input_name='AccessionNumber')), namespaceprefix_ , eol_))
        if self.AccessionURI is not None:
            namespaceprefix_ = self.AccessionURI_nsprefix_ + ':' if (UseCapturedNS_ and self.AccessionURI_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAccessionURI>%s</%sAccessionURI>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.AccessionURI), input_name='AccessionURI')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'AccessionDate':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'AccessionDate')
            value_ = self.gds_validate_string(value_, node, 'AccessionDate')
            self.AccessionDate = value_
            self.AccessionDate_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.AccessionDate)
        elif nodeName_ == 'AccessionCatalogue':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'AccessionCatalogue')
            value_ = self.gds_validate_string(value_, node, 'AccessionCatalogue')
            self.AccessionCatalogue = value_
            self.AccessionCatalogue_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.AccessionCatalogue)
        elif nodeName_ == 'AccessionNumber':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'AccessionNumber')
            value_ = self.gds_validate_string(value_, node, 'AccessionNumber')
            self.AccessionNumber = value_
            self.AccessionNumber_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.AccessionNumber)
        elif nodeName_ == 'AccessionURI':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'AccessionURI')
            value_ = self.gds_validate_string(value_, node, 'AccessionURI')
            self.AccessionURI = value_
            self.AccessionURI_nsprefix_ = child_.prefix
# end class AccessionType


class PreparationsType(GeneratedsSuper):
    """Specimen preparation details, possibly a sequence of preparation
    steps"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('Preparation', 'PreparationType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'Preparation', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/Preparation', 'type': 'PreparationType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, Preparation=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Preparation is None:
            self.Preparation = []
        else:
            self.Preparation = Preparation
        self.Preparation_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PreparationsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PreparationsType.subclass:
            return PreparationsType.subclass(*args_, **kwargs_)
        else:
            return PreparationsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Preparation(self):
        return self.Preparation
    def set_Preparation(self, Preparation):
        self.Preparation = Preparation
    def add_Preparation(self, value):
        self.Preparation.append(value)
    def insert_Preparation_at(self, index, value):
        self.Preparation.insert(index, value)
    def replace_Preparation_at(self, index, value):
        self.Preparation[index] = value
    def hasContent_(self):
        if (
            self.Preparation
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='PreparationsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PreparationsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PreparationsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PreparationsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PreparationsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='PreparationsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Preparation_ in self.Preparation:
            namespaceprefix_ = self.Preparation_nsprefix_ + ':' if (UseCapturedNS_ and self.Preparation_nsprefix_) else ''
            Preparation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Preparation', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Preparation':
            obj_ = PreparationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Preparation.append(obj_)
            obj_.original_tagname_ = 'Preparation'
# end class PreparationsType


class PreparationType(GeneratedsSuper):
    """Specimen preparation details."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('sequence', 'xs:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('PreparationType', 'PreparationType', 0, 1, {'minOccurs': '0', 'name': 'PreparationType', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/preparationType', 'type': 'StringL'}, None),
        MemberSpec_('PreparationMethod', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'PreparationMethod', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/PreparationMethod', 'type': 'StringL'}, None),
        MemberSpec_('PreparationMaterials', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'PreparationMaterials', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/preparationMaterials', 'type': 'StringL'}, None),
        MemberSpec_('PreparationAgent', 'Contact', 0, 1, {'minOccurs': '0', 'name': 'PreparationAgent', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/PreparationAgent', 'type': 'Contact'}, None),
        MemberSpec_('PreparationDate', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'PreparationDate', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/PreparationDate', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('SampleSize', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'SampleSize', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/sampleSize', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('Sieving', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'Sieving', 'sawsdl:modelReference': 'http://gensc.org/ns/mixs/sieving', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('SampleDesignations', 'SampleDesignationsType', 0, 1, {'minOccurs': '0', 'name': 'SampleDesignations', 'type': 'SampleDesignationsType'}, None),
        MemberSpec_('References', 'ReferencesType4', 0, 1, {'minOccurs': '0', 'name': 'References', 'type': 'ReferencesType4'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, sequence=None, PreparationType_member=None, PreparationMethod=None, PreparationMaterials=None, PreparationAgent=None, PreparationDate=None, SampleSize=None, Sieving=None, SampleDesignations=None, References=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.sequence = _cast(int, sequence)
        self.sequence_nsprefix_ = None
        self.PreparationType = PreparationType_member
        self.PreparationType_nsprefix_ = None
        self.PreparationMethod = PreparationMethod
        self.PreparationMethod_nsprefix_ = None
        self.PreparationMaterials = PreparationMaterials
        self.PreparationMaterials_nsprefix_ = None
        self.PreparationAgent = PreparationAgent
        self.PreparationAgent_nsprefix_ = None
        self.PreparationDate = PreparationDate
        self.validate_String(self.PreparationDate)
        self.PreparationDate_nsprefix_ = None
        self.SampleSize = SampleSize
        self.validate_String(self.SampleSize)
        self.SampleSize_nsprefix_ = None
        self.Sieving = Sieving
        self.validate_String(self.Sieving)
        self.Sieving_nsprefix_ = None
        self.SampleDesignations = SampleDesignations
        self.SampleDesignations_nsprefix_ = None
        self.References = References
        self.References_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PreparationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PreparationType.subclass:
            return PreparationType.subclass(*args_, **kwargs_)
        else:
            return PreparationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_PreparationType(self):
        return self.PreparationType
    def set_PreparationType(self, PreparationType):
        self.PreparationType = PreparationType
    def get_PreparationMethod(self):
        return self.PreparationMethod
    def set_PreparationMethod(self, PreparationMethod):
        self.PreparationMethod = PreparationMethod
    def get_PreparationMaterials(self):
        return self.PreparationMaterials
    def set_PreparationMaterials(self, PreparationMaterials):
        self.PreparationMaterials = PreparationMaterials
    def get_PreparationAgent(self):
        return self.PreparationAgent
    def set_PreparationAgent(self, PreparationAgent):
        self.PreparationAgent = PreparationAgent
    def get_PreparationDate(self):
        return self.PreparationDate
    def set_PreparationDate(self, PreparationDate):
        self.PreparationDate = PreparationDate
    def get_SampleSize(self):
        return self.SampleSize
    def set_SampleSize(self, SampleSize):
        self.SampleSize = SampleSize
    def get_Sieving(self):
        return self.Sieving
    def set_Sieving(self, Sieving):
        self.Sieving = Sieving
    def get_SampleDesignations(self):
        return self.SampleDesignations
    def set_SampleDesignations(self, SampleDesignations):
        self.SampleDesignations = SampleDesignations
    def get_References(self):
        return self.References
    def set_References(self, References):
        self.References = References
    def get_sequence(self):
        return self.sequence
    def set_sequence(self, sequence):
        self.sequence = sequence
    def validate_String(self, value):
        result = True
        # Validate type String, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on String' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.PreparationType is not None or
            self.PreparationMethod is not None or
            self.PreparationMaterials is not None or
            self.PreparationAgent is not None or
            self.PreparationDate is not None or
            self.SampleSize is not None or
            self.Sieving is not None or
            self.SampleDesignations is not None or
            self.References is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='PreparationType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PreparationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PreparationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PreparationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PreparationType'):
        if self.sequence is not None and 'sequence' not in already_processed:
            already_processed.add('sequence')
            outfile.write(' sequence="%s"' % self.gds_format_integer(self.sequence, input_name='sequence'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='PreparationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PreparationType is not None:
            namespaceprefix_ = self.PreparationType_nsprefix_ + ':' if (UseCapturedNS_ and self.PreparationType_nsprefix_) else ''
            self.PreparationType.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PreparationType', pretty_print=pretty_print)
        if self.PreparationMethod is not None:
            namespaceprefix_ = self.PreparationMethod_nsprefix_ + ':' if (UseCapturedNS_ and self.PreparationMethod_nsprefix_) else ''
            self.PreparationMethod.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PreparationMethod', pretty_print=pretty_print)
        if self.PreparationMaterials is not None:
            namespaceprefix_ = self.PreparationMaterials_nsprefix_ + ':' if (UseCapturedNS_ and self.PreparationMaterials_nsprefix_) else ''
            self.PreparationMaterials.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PreparationMaterials', pretty_print=pretty_print)
        if self.PreparationAgent is not None:
            namespaceprefix_ = self.PreparationAgent_nsprefix_ + ':' if (UseCapturedNS_ and self.PreparationAgent_nsprefix_) else ''
            self.PreparationAgent.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PreparationAgent', pretty_print=pretty_print)
        if self.PreparationDate is not None:
            namespaceprefix_ = self.PreparationDate_nsprefix_ + ':' if (UseCapturedNS_ and self.PreparationDate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPreparationDate>%s</%sPreparationDate>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PreparationDate), input_name='PreparationDate')), namespaceprefix_ , eol_))
        if self.SampleSize is not None:
            namespaceprefix_ = self.SampleSize_nsprefix_ + ':' if (UseCapturedNS_ and self.SampleSize_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSampleSize>%s</%sSampleSize>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SampleSize), input_name='SampleSize')), namespaceprefix_ , eol_))
        if self.Sieving is not None:
            namespaceprefix_ = self.Sieving_nsprefix_ + ':' if (UseCapturedNS_ and self.Sieving_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSieving>%s</%sSieving>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Sieving), input_name='Sieving')), namespaceprefix_ , eol_))
        if self.SampleDesignations is not None:
            namespaceprefix_ = self.SampleDesignations_nsprefix_ + ':' if (UseCapturedNS_ and self.SampleDesignations_nsprefix_) else ''
            self.SampleDesignations.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SampleDesignations', pretty_print=pretty_print)
        if self.References is not None:
            namespaceprefix_ = self.References_nsprefix_ + ':' if (UseCapturedNS_ and self.References_nsprefix_) else ''
            self.References.export(outfile, level, namespaceprefix_, namespacedef_='', name_='References', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sequence', node)
        if value is not None and 'sequence' not in already_processed:
            already_processed.add('sequence')
            self.sequence = self.gds_parse_integer(value, node, 'sequence')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'PreparationType':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PreparationType = obj_
            obj_.original_tagname_ = 'PreparationType'
        elif nodeName_ == 'PreparationMethod':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PreparationMethod = obj_
            obj_.original_tagname_ = 'PreparationMethod'
        elif nodeName_ == 'PreparationMaterials':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PreparationMaterials = obj_
            obj_.original_tagname_ = 'PreparationMaterials'
        elif nodeName_ == 'PreparationAgent':
            class_obj_ = self.get_class_obj_(child_, Contact)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PreparationAgent = obj_
            obj_.original_tagname_ = 'PreparationAgent'
        elif nodeName_ == 'PreparationDate':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PreparationDate')
            value_ = self.gds_validate_string(value_, node, 'PreparationDate')
            self.PreparationDate = value_
            self.PreparationDate_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.PreparationDate)
        elif nodeName_ == 'SampleSize':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SampleSize')
            value_ = self.gds_validate_string(value_, node, 'SampleSize')
            self.SampleSize = value_
            self.SampleSize_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.SampleSize)
        elif nodeName_ == 'Sieving':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Sieving')
            value_ = self.gds_validate_string(value_, node, 'Sieving')
            self.Sieving = value_
            self.Sieving_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.Sieving)
        elif nodeName_ == 'SampleDesignations':
            obj_ = SampleDesignationsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SampleDesignations = obj_
            obj_.original_tagname_ = 'SampleDesignations'
        elif nodeName_ == 'References':
            obj_ = ReferencesType4.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.References = obj_
            obj_.original_tagname_ = 'References'
# end class PreparationType


class SampleDesignationsType(GeneratedsSuper):
    """Designated numbers or identifiers of sample, usually project numbers
    used in the lab."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('SampleDesignation', ['String', 'xs:normalizedString'], 1, 0, {'maxOccurs': 'unbounded', 'name': 'SampleDesignation', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/sampleDesignation', 'type': 'xs:normalizedString'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, SampleDesignation=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if SampleDesignation is None:
            self.SampleDesignation = []
        else:
            self.SampleDesignation = SampleDesignation
        self.SampleDesignation_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SampleDesignationsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SampleDesignationsType.subclass:
            return SampleDesignationsType.subclass(*args_, **kwargs_)
        else:
            return SampleDesignationsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_SampleDesignation(self):
        return self.SampleDesignation
    def set_SampleDesignation(self, SampleDesignation):
        self.SampleDesignation = SampleDesignation
    def add_SampleDesignation(self, value):
        self.SampleDesignation.append(value)
    def insert_SampleDesignation_at(self, index, value):
        self.SampleDesignation.insert(index, value)
    def replace_SampleDesignation_at(self, index, value):
        self.SampleDesignation[index] = value
    def validate_String(self, value):
        result = True
        # Validate type String, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on String' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.SampleDesignation
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='SampleDesignationsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SampleDesignationsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SampleDesignationsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SampleDesignationsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SampleDesignationsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='SampleDesignationsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SampleDesignation_ in self.SampleDesignation:
            namespaceprefix_ = self.SampleDesignation_nsprefix_ + ':' if (UseCapturedNS_ and self.SampleDesignation_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSampleDesignation>%s</%sSampleDesignation>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(SampleDesignation_), input_name='SampleDesignation')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'SampleDesignation':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SampleDesignation')
            value_ = self.gds_validate_string(value_, node, 'SampleDesignation')
            self.SampleDesignation.append(value_)
            self.SampleDesignation_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.SampleDesignation[-1])
# end class SampleDesignationsType


class ReferencesType4(GeneratedsSuper):
    """References for the preparation method"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('Reference', 'Reference', 1, 0, {'maxOccurs': 'unbounded', 'name': 'Reference', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Preparation-Reference', 'type': 'Reference'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, Reference=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Reference is None:
            self.Reference = []
        else:
            self.Reference = Reference
        self.Reference_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReferencesType4)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReferencesType4.subclass:
            return ReferencesType4.subclass(*args_, **kwargs_)
        else:
            return ReferencesType4(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Reference(self):
        return self.Reference
    def set_Reference(self, Reference):
        self.Reference = Reference
    def add_Reference(self, value):
        self.Reference.append(value)
    def insert_Reference_at(self, index, value):
        self.Reference.insert(index, value)
    def replace_Reference_at(self, index, value):
        self.Reference[index] = value
    def hasContent_(self):
        if (
            self.Reference
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='ReferencesType4', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReferencesType4')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReferencesType4')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ReferencesType4', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ReferencesType4'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='ReferencesType4', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Reference_ in self.Reference:
            namespaceprefix_ = self.Reference_nsprefix_ + ':' if (UseCapturedNS_ and self.Reference_nsprefix_) else ''
            Reference_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Reference', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Reference':
            obj_ = Reference.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Reference.append(obj_)
            obj_.original_tagname_ = 'Reference'
# end class ReferencesType4


class PreservationsType(GeneratedsSuper):
    """Specimen preservation details, possibly a sequence of preservation
    periods"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('Preservation', 'PreservationType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'Preservation', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/Preservation', 'type': 'PreservationType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, Preservation=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Preservation is None:
            self.Preservation = []
        else:
            self.Preservation = Preservation
        self.Preservation_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PreservationsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PreservationsType.subclass:
            return PreservationsType.subclass(*args_, **kwargs_)
        else:
            return PreservationsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Preservation(self):
        return self.Preservation
    def set_Preservation(self, Preservation):
        self.Preservation = Preservation
    def add_Preservation(self, value):
        self.Preservation.append(value)
    def insert_Preservation_at(self, index, value):
        self.Preservation.insert(index, value)
    def replace_Preservation_at(self, index, value):
        self.Preservation[index] = value
    def hasContent_(self):
        if (
            self.Preservation
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='PreservationsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PreservationsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PreservationsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PreservationsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PreservationsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='PreservationsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Preservation_ in self.Preservation:
            namespaceprefix_ = self.Preservation_nsprefix_ + ':' if (UseCapturedNS_ and self.Preservation_nsprefix_) else ''
            Preservation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Preservation', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Preservation':
            obj_ = PreservationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Preservation.append(obj_)
            obj_.original_tagname_ = 'Preservation'
# end class PreservationsType


class PreservationType(GeneratedsSuper):
    """A description of the preservation of the specimen."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('sequence', 'xs:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('PreservationType', 'PreservationType', 0, 1, {'minOccurs': '0', 'name': 'PreservationType', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/preservationType', 'type': 'StringL'}, None),
        MemberSpec_('PreservationTemperature', 'Temperature', 0, 1, {'minOccurs': '0', 'name': 'PreservationTemperature', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Preservation-Temperature', 'type': 'Temperature'}, None),
        MemberSpec_('PreservationDateBegin', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'PreservationDateBegin', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/PreservationDateBegin', 'type': 'xs:normalizedString'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, sequence=None, PreservationType_member=None, PreservationTemperature=None, PreservationDateBegin=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.sequence = _cast(int, sequence)
        self.sequence_nsprefix_ = None
        self.PreservationType = PreservationType_member
        self.PreservationType_nsprefix_ = None
        self.PreservationTemperature = PreservationTemperature
        self.PreservationTemperature_nsprefix_ = None
        self.PreservationDateBegin = PreservationDateBegin
        self.validate_String(self.PreservationDateBegin)
        self.PreservationDateBegin_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PreservationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PreservationType.subclass:
            return PreservationType.subclass(*args_, **kwargs_)
        else:
            return PreservationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_PreservationType(self):
        return self.PreservationType
    def set_PreservationType(self, PreservationType):
        self.PreservationType = PreservationType
    def get_PreservationTemperature(self):
        return self.PreservationTemperature
    def set_PreservationTemperature(self, PreservationTemperature):
        self.PreservationTemperature = PreservationTemperature
    def get_PreservationDateBegin(self):
        return self.PreservationDateBegin
    def set_PreservationDateBegin(self, PreservationDateBegin):
        self.PreservationDateBegin = PreservationDateBegin
    def get_sequence(self):
        return self.sequence
    def set_sequence(self, sequence):
        self.sequence = sequence
    def validate_String(self, value):
        result = True
        # Validate type String, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on String' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.PreservationType is not None or
            self.PreservationTemperature is not None or
            self.PreservationDateBegin is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='PreservationType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PreservationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PreservationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PreservationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PreservationType'):
        if self.sequence is not None and 'sequence' not in already_processed:
            already_processed.add('sequence')
            outfile.write(' sequence="%s"' % self.gds_format_integer(self.sequence, input_name='sequence'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='PreservationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PreservationType is not None:
            namespaceprefix_ = self.PreservationType_nsprefix_ + ':' if (UseCapturedNS_ and self.PreservationType_nsprefix_) else ''
            self.PreservationType.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PreservationType', pretty_print=pretty_print)
        if self.PreservationTemperature is not None:
            namespaceprefix_ = self.PreservationTemperature_nsprefix_ + ':' if (UseCapturedNS_ and self.PreservationTemperature_nsprefix_) else ''
            self.PreservationTemperature.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PreservationTemperature', pretty_print=pretty_print)
        if self.PreservationDateBegin is not None:
            namespaceprefix_ = self.PreservationDateBegin_nsprefix_ + ':' if (UseCapturedNS_ and self.PreservationDateBegin_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPreservationDateBegin>%s</%sPreservationDateBegin>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PreservationDateBegin), input_name='PreservationDateBegin')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sequence', node)
        if value is not None and 'sequence' not in already_processed:
            already_processed.add('sequence')
            self.sequence = self.gds_parse_integer(value, node, 'sequence')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'PreservationType':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PreservationType = obj_
            obj_.original_tagname_ = 'PreservationType'
        elif nodeName_ == 'PreservationTemperature':
            obj_ = Temperature.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PreservationTemperature = obj_
            obj_.original_tagname_ = 'PreservationTemperature'
        elif nodeName_ == 'PreservationDateBegin':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PreservationDateBegin')
            value_ = self.gds_validate_string(value_, node, 'PreservationDateBegin')
            self.PreservationDateBegin = value_
            self.PreservationDateBegin_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.PreservationDateBegin)
# end class PreservationType


class MarksType(GeneratedsSuper):
    """A container element for several labels or inscriptions associated with
    the unit."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('Mark', 'MarkType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'Mark', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/Mark', 'type': 'MarkType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, Mark=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Mark is None:
            self.Mark = []
        else:
            self.Mark = Mark
        self.Mark_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MarksType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MarksType.subclass:
            return MarksType.subclass(*args_, **kwargs_)
        else:
            return MarksType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Mark(self):
        return self.Mark
    def set_Mark(self, Mark):
        self.Mark = Mark
    def add_Mark(self, value):
        self.Mark.append(value)
    def insert_Mark_at(self, index, value):
        self.Mark.insert(index, value)
    def replace_Mark_at(self, index, value):
        self.Mark[index] = value
    def hasContent_(self):
        if (
            self.Mark
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='MarksType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MarksType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MarksType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MarksType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MarksType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='MarksType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Mark_ in self.Mark:
            namespaceprefix_ = self.Mark_nsprefix_ + ':' if (UseCapturedNS_ and self.Mark_nsprefix_) else ''
            Mark_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Mark', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Mark':
            obj_ = MarkType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Mark.append(obj_)
            obj_.original_tagname_ = 'Mark'
# end class MarksType


class MarkType(GeneratedsSuper):
    """Label(s), writing(s) or inscription(s)."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('MarkType', 'MarkType', 0, 1, {'minOccurs': '0', 'name': 'MarkType', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/markType', 'type': 'StringL'}, None),
        MemberSpec_('MarkText', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'MarkText', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/MarkText', 'type': 'StringL'}, None),
        MemberSpec_('PositionOnObject', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'PositionOnObject', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/positionOnObject', 'type': 'StringL'}, None),
        MemberSpec_('MarkAuthor', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'MarkAuthor', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/MarkAuthor', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('MarkComment', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'MarkComment', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Mark-Notes', 'type': 'StringL'}, None),
        MemberSpec_('Images', 'ImagesType', 0, 1, {'minOccurs': '0', 'name': 'Images', 'type': 'ImagesType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, MarkType_member=None, MarkText=None, PositionOnObject=None, MarkAuthor=None, MarkComment=None, Images=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.MarkType = MarkType_member
        self.MarkType_nsprefix_ = None
        self.MarkText = MarkText
        self.MarkText_nsprefix_ = None
        self.PositionOnObject = PositionOnObject
        self.PositionOnObject_nsprefix_ = None
        self.MarkAuthor = MarkAuthor
        self.validate_String(self.MarkAuthor)
        self.MarkAuthor_nsprefix_ = None
        self.MarkComment = MarkComment
        self.MarkComment_nsprefix_ = None
        self.Images = Images
        self.Images_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MarkType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MarkType.subclass:
            return MarkType.subclass(*args_, **kwargs_)
        else:
            return MarkType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_MarkType(self):
        return self.MarkType
    def set_MarkType(self, MarkType):
        self.MarkType = MarkType
    def get_MarkText(self):
        return self.MarkText
    def set_MarkText(self, MarkText):
        self.MarkText = MarkText
    def get_PositionOnObject(self):
        return self.PositionOnObject
    def set_PositionOnObject(self, PositionOnObject):
        self.PositionOnObject = PositionOnObject
    def get_MarkAuthor(self):
        return self.MarkAuthor
    def set_MarkAuthor(self, MarkAuthor):
        self.MarkAuthor = MarkAuthor
    def get_MarkComment(self):
        return self.MarkComment
    def set_MarkComment(self, MarkComment):
        self.MarkComment = MarkComment
    def get_Images(self):
        return self.Images
    def set_Images(self, Images):
        self.Images = Images
    def validate_String(self, value):
        result = True
        # Validate type String, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on String' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.MarkType is not None or
            self.MarkText is not None or
            self.PositionOnObject is not None or
            self.MarkAuthor is not None or
            self.MarkComment is not None or
            self.Images is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='MarkType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MarkType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MarkType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MarkType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MarkType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='MarkType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MarkType is not None:
            namespaceprefix_ = self.MarkType_nsprefix_ + ':' if (UseCapturedNS_ and self.MarkType_nsprefix_) else ''
            self.MarkType.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MarkType', pretty_print=pretty_print)
        if self.MarkText is not None:
            namespaceprefix_ = self.MarkText_nsprefix_ + ':' if (UseCapturedNS_ and self.MarkText_nsprefix_) else ''
            self.MarkText.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MarkText', pretty_print=pretty_print)
        if self.PositionOnObject is not None:
            namespaceprefix_ = self.PositionOnObject_nsprefix_ + ':' if (UseCapturedNS_ and self.PositionOnObject_nsprefix_) else ''
            self.PositionOnObject.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PositionOnObject', pretty_print=pretty_print)
        if self.MarkAuthor is not None:
            namespaceprefix_ = self.MarkAuthor_nsprefix_ + ':' if (UseCapturedNS_ and self.MarkAuthor_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMarkAuthor>%s</%sMarkAuthor>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.MarkAuthor), input_name='MarkAuthor')), namespaceprefix_ , eol_))
        if self.MarkComment is not None:
            namespaceprefix_ = self.MarkComment_nsprefix_ + ':' if (UseCapturedNS_ and self.MarkComment_nsprefix_) else ''
            self.MarkComment.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MarkComment', pretty_print=pretty_print)
        if self.Images is not None:
            namespaceprefix_ = self.Images_nsprefix_ + ':' if (UseCapturedNS_ and self.Images_nsprefix_) else ''
            self.Images.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Images', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'MarkType':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MarkType = obj_
            obj_.original_tagname_ = 'MarkType'
        elif nodeName_ == 'MarkText':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MarkText = obj_
            obj_.original_tagname_ = 'MarkText'
        elif nodeName_ == 'PositionOnObject':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PositionOnObject = obj_
            obj_.original_tagname_ = 'PositionOnObject'
        elif nodeName_ == 'MarkAuthor':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'MarkAuthor')
            value_ = self.gds_validate_string(value_, node, 'MarkAuthor')
            self.MarkAuthor = value_
            self.MarkAuthor_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.MarkAuthor)
        elif nodeName_ == 'MarkComment':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MarkComment = obj_
            obj_.original_tagname_ = 'MarkComment'
        elif nodeName_ == 'Images':
            obj_ = ImagesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Images = obj_
            obj_.original_tagname_ = 'Images'
# end class MarkType


class ImagesType(GeneratedsSuper):
    """References to an image or images of the label, writing or
    inscription."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('ImageID', ['String', 'xs:normalizedString'], 1, 0, {'maxOccurs': 'unbounded', 'name': 'ImageID', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Mark-ImageID', 'type': 'xs:normalizedString'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, ImageID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ImageID is None:
            self.ImageID = []
        else:
            self.ImageID = ImageID
        self.ImageID_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ImagesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ImagesType.subclass:
            return ImagesType.subclass(*args_, **kwargs_)
        else:
            return ImagesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ImageID(self):
        return self.ImageID
    def set_ImageID(self, ImageID):
        self.ImageID = ImageID
    def add_ImageID(self, value):
        self.ImageID.append(value)
    def insert_ImageID_at(self, index, value):
        self.ImageID.insert(index, value)
    def replace_ImageID_at(self, index, value):
        self.ImageID[index] = value
    def validate_String(self, value):
        result = True
        # Validate type String, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on String' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.ImageID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='ImagesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ImagesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ImagesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ImagesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ImagesType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='ImagesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ImageID_ in self.ImageID:
            namespaceprefix_ = self.ImageID_nsprefix_ + ':' if (UseCapturedNS_ and self.ImageID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sImageID>%s</%sImageID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(ImageID_), input_name='ImageID')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ImageID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ImageID')
            value_ = self.gds_validate_string(value_, node, 'ImageID')
            self.ImageID.append(value_)
            self.ImageID_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.ImageID[-1])
# end class ImagesType


class PreviousUnitsType(GeneratedsSuper):
    """A container element for several previous identifiers and locations for
    this unit."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('PreviousUnit', 'PreviousUnitType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'PreviousUnit', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/PreviousUnit', 'type': 'PreviousUnitType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, PreviousUnit=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if PreviousUnit is None:
            self.PreviousUnit = []
        else:
            self.PreviousUnit = PreviousUnit
        self.PreviousUnit_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PreviousUnitsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PreviousUnitsType.subclass:
            return PreviousUnitsType.subclass(*args_, **kwargs_)
        else:
            return PreviousUnitsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_PreviousUnit(self):
        return self.PreviousUnit
    def set_PreviousUnit(self, PreviousUnit):
        self.PreviousUnit = PreviousUnit
    def add_PreviousUnit(self, value):
        self.PreviousUnit.append(value)
    def insert_PreviousUnit_at(self, index, value):
        self.PreviousUnit.insert(index, value)
    def replace_PreviousUnit_at(self, index, value):
        self.PreviousUnit[index] = value
    def hasContent_(self):
        if (
            self.PreviousUnit
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='PreviousUnitsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PreviousUnitsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PreviousUnitsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PreviousUnitsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PreviousUnitsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='PreviousUnitsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for PreviousUnit_ in self.PreviousUnit:
            namespaceprefix_ = self.PreviousUnit_nsprefix_ + ':' if (UseCapturedNS_ and self.PreviousUnit_nsprefix_) else ''
            PreviousUnit_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PreviousUnit', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'PreviousUnit':
            obj_ = PreviousUnitType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PreviousUnit.append(obj_)
            obj_.original_tagname_ = 'PreviousUnit'
# end class PreviousUnitsType


class PreviousUnitType(GeneratedsSuper):
    """A container for past identifiers and locations for this specimen."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('sequence', 'xs:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('PreviousUnitGUID', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'PreviousUnitGUID', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/PreviousUnitGUID', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('PreviousSourceInstitutionID', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'PreviousSourceInstitutionID', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/PreviousSourceInstitutionID', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('PreviousSourceID', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'PreviousSourceID', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/PreviousSourceID', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('PreviousUnitID', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'PreviousUnitID', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/PreviousUnitID', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('Date', 'DateTime', 0, 1, {'minOccurs': '0', 'name': 'Date', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/PreviousUnit-Date', 'type': 'DateTime'}, None),
        MemberSpec_('Notes', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'Notes', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/PreviousUnit-Notes', 'type': 'StringL'}, None),
        MemberSpec_('PreviousUnitText', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'PreviousUnitText', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/previousUnitText', 'type': 'StringL'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, sequence=None, PreviousUnitGUID=None, PreviousSourceInstitutionID=None, PreviousSourceID=None, PreviousUnitID=None, Date=None, Notes=None, PreviousUnitText=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.sequence = _cast(int, sequence)
        self.sequence_nsprefix_ = None
        self.PreviousUnitGUID = PreviousUnitGUID
        self.validate_String(self.PreviousUnitGUID)
        self.PreviousUnitGUID_nsprefix_ = None
        self.PreviousSourceInstitutionID = PreviousSourceInstitutionID
        self.validate_String(self.PreviousSourceInstitutionID)
        self.PreviousSourceInstitutionID_nsprefix_ = None
        self.PreviousSourceID = PreviousSourceID
        self.validate_String(self.PreviousSourceID)
        self.PreviousSourceID_nsprefix_ = None
        self.PreviousUnitID = PreviousUnitID
        self.validate_String(self.PreviousUnitID)
        self.PreviousUnitID_nsprefix_ = None
        self.Date = Date
        self.Date_nsprefix_ = None
        self.Notes = Notes
        self.Notes_nsprefix_ = None
        self.PreviousUnitText = PreviousUnitText
        self.PreviousUnitText_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PreviousUnitType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PreviousUnitType.subclass:
            return PreviousUnitType.subclass(*args_, **kwargs_)
        else:
            return PreviousUnitType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_PreviousUnitGUID(self):
        return self.PreviousUnitGUID
    def set_PreviousUnitGUID(self, PreviousUnitGUID):
        self.PreviousUnitGUID = PreviousUnitGUID
    def get_PreviousSourceInstitutionID(self):
        return self.PreviousSourceInstitutionID
    def set_PreviousSourceInstitutionID(self, PreviousSourceInstitutionID):
        self.PreviousSourceInstitutionID = PreviousSourceInstitutionID
    def get_PreviousSourceID(self):
        return self.PreviousSourceID
    def set_PreviousSourceID(self, PreviousSourceID):
        self.PreviousSourceID = PreviousSourceID
    def get_PreviousUnitID(self):
        return self.PreviousUnitID
    def set_PreviousUnitID(self, PreviousUnitID):
        self.PreviousUnitID = PreviousUnitID
    def get_Date(self):
        return self.Date
    def set_Date(self, Date):
        self.Date = Date
    def get_Notes(self):
        return self.Notes
    def set_Notes(self, Notes):
        self.Notes = Notes
    def get_PreviousUnitText(self):
        return self.PreviousUnitText
    def set_PreviousUnitText(self, PreviousUnitText):
        self.PreviousUnitText = PreviousUnitText
    def get_sequence(self):
        return self.sequence
    def set_sequence(self, sequence):
        self.sequence = sequence
    def validate_String(self, value):
        result = True
        # Validate type String, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on String' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.PreviousUnitGUID is not None or
            self.PreviousSourceInstitutionID is not None or
            self.PreviousSourceID is not None or
            self.PreviousUnitID is not None or
            self.Date is not None or
            self.Notes is not None or
            self.PreviousUnitText is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='PreviousUnitType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PreviousUnitType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PreviousUnitType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PreviousUnitType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PreviousUnitType'):
        if self.sequence is not None and 'sequence' not in already_processed:
            already_processed.add('sequence')
            outfile.write(' sequence="%s"' % self.gds_format_integer(self.sequence, input_name='sequence'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='PreviousUnitType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PreviousUnitGUID is not None:
            namespaceprefix_ = self.PreviousUnitGUID_nsprefix_ + ':' if (UseCapturedNS_ and self.PreviousUnitGUID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPreviousUnitGUID>%s</%sPreviousUnitGUID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PreviousUnitGUID), input_name='PreviousUnitGUID')), namespaceprefix_ , eol_))
        if self.PreviousSourceInstitutionID is not None:
            namespaceprefix_ = self.PreviousSourceInstitutionID_nsprefix_ + ':' if (UseCapturedNS_ and self.PreviousSourceInstitutionID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPreviousSourceInstitutionID>%s</%sPreviousSourceInstitutionID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PreviousSourceInstitutionID), input_name='PreviousSourceInstitutionID')), namespaceprefix_ , eol_))
        if self.PreviousSourceID is not None:
            namespaceprefix_ = self.PreviousSourceID_nsprefix_ + ':' if (UseCapturedNS_ and self.PreviousSourceID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPreviousSourceID>%s</%sPreviousSourceID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PreviousSourceID), input_name='PreviousSourceID')), namespaceprefix_ , eol_))
        if self.PreviousUnitID is not None:
            namespaceprefix_ = self.PreviousUnitID_nsprefix_ + ':' if (UseCapturedNS_ and self.PreviousUnitID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPreviousUnitID>%s</%sPreviousUnitID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PreviousUnitID), input_name='PreviousUnitID')), namespaceprefix_ , eol_))
        if self.Date is not None:
            namespaceprefix_ = self.Date_nsprefix_ + ':' if (UseCapturedNS_ and self.Date_nsprefix_) else ''
            self.Date.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Date', pretty_print=pretty_print)
        if self.Notes is not None:
            namespaceprefix_ = self.Notes_nsprefix_ + ':' if (UseCapturedNS_ and self.Notes_nsprefix_) else ''
            self.Notes.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Notes', pretty_print=pretty_print)
        if self.PreviousUnitText is not None:
            namespaceprefix_ = self.PreviousUnitText_nsprefix_ + ':' if (UseCapturedNS_ and self.PreviousUnitText_nsprefix_) else ''
            self.PreviousUnitText.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PreviousUnitText', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sequence', node)
        if value is not None and 'sequence' not in already_processed:
            already_processed.add('sequence')
            self.sequence = self.gds_parse_integer(value, node, 'sequence')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'PreviousUnitGUID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PreviousUnitGUID')
            value_ = self.gds_validate_string(value_, node, 'PreviousUnitGUID')
            self.PreviousUnitGUID = value_
            self.PreviousUnitGUID_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.PreviousUnitGUID)
        elif nodeName_ == 'PreviousSourceInstitutionID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PreviousSourceInstitutionID')
            value_ = self.gds_validate_string(value_, node, 'PreviousSourceInstitutionID')
            self.PreviousSourceInstitutionID = value_
            self.PreviousSourceInstitutionID_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.PreviousSourceInstitutionID)
        elif nodeName_ == 'PreviousSourceID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PreviousSourceID')
            value_ = self.gds_validate_string(value_, node, 'PreviousSourceID')
            self.PreviousSourceID = value_
            self.PreviousSourceID_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.PreviousSourceID)
        elif nodeName_ == 'PreviousUnitID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PreviousUnitID')
            value_ = self.gds_validate_string(value_, node, 'PreviousUnitID')
            self.PreviousUnitID = value_
            self.PreviousUnitID_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.PreviousUnitID)
        elif nodeName_ == 'Date':
            obj_ = DateTime.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Date = obj_
            obj_.original_tagname_ = 'Date'
        elif nodeName_ == 'Notes':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Notes = obj_
            obj_.original_tagname_ = 'Notes'
        elif nodeName_ == 'PreviousUnitText':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PreviousUnitText = obj_
            obj_.original_tagname_ = 'PreviousUnitText'
# end class PreviousUnitType


class NomenclaturalTypeDesignationsType(GeneratedsSuper):
    """A container element for several nomenclatural type designations."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('NomenclaturalTypeDesignation', 'NomenclaturalTypeDesignationType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'NomenclaturalTypeDesignation', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/NomenclaturalTypeDesignation', 'type': 'NomenclaturalTypeDesignationType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, NomenclaturalTypeDesignation=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if NomenclaturalTypeDesignation is None:
            self.NomenclaturalTypeDesignation = []
        else:
            self.NomenclaturalTypeDesignation = NomenclaturalTypeDesignation
        self.NomenclaturalTypeDesignation_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NomenclaturalTypeDesignationsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NomenclaturalTypeDesignationsType.subclass:
            return NomenclaturalTypeDesignationsType.subclass(*args_, **kwargs_)
        else:
            return NomenclaturalTypeDesignationsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_NomenclaturalTypeDesignation(self):
        return self.NomenclaturalTypeDesignation
    def set_NomenclaturalTypeDesignation(self, NomenclaturalTypeDesignation):
        self.NomenclaturalTypeDesignation = NomenclaturalTypeDesignation
    def add_NomenclaturalTypeDesignation(self, value):
        self.NomenclaturalTypeDesignation.append(value)
    def insert_NomenclaturalTypeDesignation_at(self, index, value):
        self.NomenclaturalTypeDesignation.insert(index, value)
    def replace_NomenclaturalTypeDesignation_at(self, index, value):
        self.NomenclaturalTypeDesignation[index] = value
    def hasContent_(self):
        if (
            self.NomenclaturalTypeDesignation
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='NomenclaturalTypeDesignationsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NomenclaturalTypeDesignationsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NomenclaturalTypeDesignationsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NomenclaturalTypeDesignationsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NomenclaturalTypeDesignationsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='NomenclaturalTypeDesignationsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for NomenclaturalTypeDesignation_ in self.NomenclaturalTypeDesignation:
            namespaceprefix_ = self.NomenclaturalTypeDesignation_nsprefix_ + ':' if (UseCapturedNS_ and self.NomenclaturalTypeDesignation_nsprefix_) else ''
            NomenclaturalTypeDesignation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NomenclaturalTypeDesignation', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'NomenclaturalTypeDesignation':
            obj_ = NomenclaturalTypeDesignationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NomenclaturalTypeDesignation.append(obj_)
            obj_.original_tagname_ = 'NomenclaturalTypeDesignation'
# end class NomenclaturalTypeDesignationsType


class NomenclaturalTypeDesignationType(GeneratedsSuper):
    """Information on the type status of the specimen."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('TypifiedName', 'ScientificName', 0, 1, {'minOccurs': '0', 'name': 'TypifiedName', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/TypifiedName', 'type': 'ScientificName'}, None),
        MemberSpec_('NomenclaturalReference', 'Reference', 0, 1, {'minOccurs': '0', 'name': 'NomenclaturalReference', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/NomenclaturalTypeDesignation-Reference', 'type': 'Reference'}, None),
        MemberSpec_('TypeStatus', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'TypeStatus', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/typeStatus', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('CodeAssessment', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'CodeAssessment', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/codeAssessment', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('DoubtfulFlag', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'DoubtfulFlag', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/doubtfulFlag', 'type': 'xs:boolean'}, None),
        MemberSpec_('Verifier', 'PersonName', 0, 1, {'minOccurs': '0', 'name': 'Verifier', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Verifier', 'type': 'PersonName'}, None),
        MemberSpec_('VerificationDate', 'xs:date', 0, 1, {'minOccurs': '0', 'name': 'VerificationDate', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/VerificationDate', 'type': 'xs:date'}, None),
        MemberSpec_('VerificationNotes', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'VerificationNotes', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/VerificationNotes', 'type': 'StringL'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, TypifiedName=None, NomenclaturalReference=None, TypeStatus=None, CodeAssessment=None, DoubtfulFlag=None, Verifier=None, VerificationDate=None, VerificationNotes=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.TypifiedName = TypifiedName
        self.TypifiedName_nsprefix_ = None
        self.NomenclaturalReference = NomenclaturalReference
        self.NomenclaturalReference_nsprefix_ = None
        self.TypeStatus = TypeStatus
        self.validate_String(self.TypeStatus)
        self.TypeStatus_nsprefix_ = None
        self.CodeAssessment = CodeAssessment
        self.validate_String(self.CodeAssessment)
        self.CodeAssessment_nsprefix_ = None
        self.DoubtfulFlag = DoubtfulFlag
        self.DoubtfulFlag_nsprefix_ = None
        self.Verifier = Verifier
        self.Verifier_nsprefix_ = None
        if isinstance(VerificationDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(VerificationDate, '%Y-%m-%d').date()
        else:
            initvalue_ = VerificationDate
        self.VerificationDate = initvalue_
        self.VerificationDate_nsprefix_ = None
        self.VerificationNotes = VerificationNotes
        self.VerificationNotes_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NomenclaturalTypeDesignationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NomenclaturalTypeDesignationType.subclass:
            return NomenclaturalTypeDesignationType.subclass(*args_, **kwargs_)
        else:
            return NomenclaturalTypeDesignationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_TypifiedName(self):
        return self.TypifiedName
    def set_TypifiedName(self, TypifiedName):
        self.TypifiedName = TypifiedName
    def get_NomenclaturalReference(self):
        return self.NomenclaturalReference
    def set_NomenclaturalReference(self, NomenclaturalReference):
        self.NomenclaturalReference = NomenclaturalReference
    def get_TypeStatus(self):
        return self.TypeStatus
    def set_TypeStatus(self, TypeStatus):
        self.TypeStatus = TypeStatus
    def get_CodeAssessment(self):
        return self.CodeAssessment
    def set_CodeAssessment(self, CodeAssessment):
        self.CodeAssessment = CodeAssessment
    def get_DoubtfulFlag(self):
        return self.DoubtfulFlag
    def set_DoubtfulFlag(self, DoubtfulFlag):
        self.DoubtfulFlag = DoubtfulFlag
    def get_Verifier(self):
        return self.Verifier
    def set_Verifier(self, Verifier):
        self.Verifier = Verifier
    def get_VerificationDate(self):
        return self.VerificationDate
    def set_VerificationDate(self, VerificationDate):
        self.VerificationDate = VerificationDate
    def get_VerificationNotes(self):
        return self.VerificationNotes
    def set_VerificationNotes(self, VerificationNotes):
        self.VerificationNotes = VerificationNotes
    def validate_String(self, value):
        result = True
        # Validate type String, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on String' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.TypifiedName is not None or
            self.NomenclaturalReference is not None or
            self.TypeStatus is not None or
            self.CodeAssessment is not None or
            self.DoubtfulFlag is not None or
            self.Verifier is not None or
            self.VerificationDate is not None or
            self.VerificationNotes is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='NomenclaturalTypeDesignationType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NomenclaturalTypeDesignationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NomenclaturalTypeDesignationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NomenclaturalTypeDesignationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NomenclaturalTypeDesignationType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='NomenclaturalTypeDesignationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TypifiedName is not None:
            namespaceprefix_ = self.TypifiedName_nsprefix_ + ':' if (UseCapturedNS_ and self.TypifiedName_nsprefix_) else ''
            self.TypifiedName.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TypifiedName', pretty_print=pretty_print)
        if self.NomenclaturalReference is not None:
            namespaceprefix_ = self.NomenclaturalReference_nsprefix_ + ':' if (UseCapturedNS_ and self.NomenclaturalReference_nsprefix_) else ''
            self.NomenclaturalReference.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NomenclaturalReference', pretty_print=pretty_print)
        if self.TypeStatus is not None:
            namespaceprefix_ = self.TypeStatus_nsprefix_ + ':' if (UseCapturedNS_ and self.TypeStatus_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTypeStatus>%s</%sTypeStatus>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TypeStatus), input_name='TypeStatus')), namespaceprefix_ , eol_))
        if self.CodeAssessment is not None:
            namespaceprefix_ = self.CodeAssessment_nsprefix_ + ':' if (UseCapturedNS_ and self.CodeAssessment_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCodeAssessment>%s</%sCodeAssessment>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CodeAssessment), input_name='CodeAssessment')), namespaceprefix_ , eol_))
        if self.DoubtfulFlag is not None:
            namespaceprefix_ = self.DoubtfulFlag_nsprefix_ + ':' if (UseCapturedNS_ and self.DoubtfulFlag_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDoubtfulFlag>%s</%sDoubtfulFlag>%s' % (namespaceprefix_ , self.gds_format_boolean(self.DoubtfulFlag, input_name='DoubtfulFlag'), namespaceprefix_ , eol_))
        if self.Verifier is not None:
            namespaceprefix_ = self.Verifier_nsprefix_ + ':' if (UseCapturedNS_ and self.Verifier_nsprefix_) else ''
            self.Verifier.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Verifier', pretty_print=pretty_print)
        if self.VerificationDate is not None:
            namespaceprefix_ = self.VerificationDate_nsprefix_ + ':' if (UseCapturedNS_ and self.VerificationDate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVerificationDate>%s</%sVerificationDate>%s' % (namespaceprefix_ , self.gds_format_date(self.VerificationDate, input_name='VerificationDate'), namespaceprefix_ , eol_))
        if self.VerificationNotes is not None:
            namespaceprefix_ = self.VerificationNotes_nsprefix_ + ':' if (UseCapturedNS_ and self.VerificationNotes_nsprefix_) else ''
            self.VerificationNotes.export(outfile, level, namespaceprefix_, namespacedef_='', name_='VerificationNotes', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'TypifiedName':
            class_obj_ = self.get_class_obj_(child_, ScientificName)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TypifiedName = obj_
            obj_.original_tagname_ = 'TypifiedName'
        elif nodeName_ == 'NomenclaturalReference':
            obj_ = Reference.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NomenclaturalReference = obj_
            obj_.original_tagname_ = 'NomenclaturalReference'
        elif nodeName_ == 'TypeStatus':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TypeStatus')
            value_ = self.gds_validate_string(value_, node, 'TypeStatus')
            self.TypeStatus = value_
            self.TypeStatus_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.TypeStatus)
        elif nodeName_ == 'CodeAssessment':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CodeAssessment')
            value_ = self.gds_validate_string(value_, node, 'CodeAssessment')
            self.CodeAssessment = value_
            self.CodeAssessment_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.CodeAssessment)
        elif nodeName_ == 'DoubtfulFlag':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'DoubtfulFlag')
            ival_ = self.gds_validate_boolean(ival_, node, 'DoubtfulFlag')
            self.DoubtfulFlag = ival_
            self.DoubtfulFlag_nsprefix_ = child_.prefix
        elif nodeName_ == 'Verifier':
            obj_ = PersonName.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Verifier = obj_
            obj_.original_tagname_ = 'Verifier'
        elif nodeName_ == 'VerificationDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.VerificationDate = dval_
            self.VerificationDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'VerificationNotes':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VerificationNotes = obj_
            obj_.original_tagname_ = 'VerificationNotes'
# end class NomenclaturalTypeDesignationType


class SpecimenMeasurementsOrFactsType(GeneratedsSuper):
    """Further measurements or facts related to the specimen, e.g. morphometric
    parameters."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('SpecimenMeasurementOrFact', 'MeasurementOrFact', 1, 0, {'maxOccurs': 'unbounded', 'name': 'SpecimenMeasurementOrFact', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/SpecimenUnit-MeasurementOrFact', 'type': 'MeasurementOrFact'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, SpecimenMeasurementOrFact=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if SpecimenMeasurementOrFact is None:
            self.SpecimenMeasurementOrFact = []
        else:
            self.SpecimenMeasurementOrFact = SpecimenMeasurementOrFact
        self.SpecimenMeasurementOrFact_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SpecimenMeasurementsOrFactsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SpecimenMeasurementsOrFactsType.subclass:
            return SpecimenMeasurementsOrFactsType.subclass(*args_, **kwargs_)
        else:
            return SpecimenMeasurementsOrFactsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_SpecimenMeasurementOrFact(self):
        return self.SpecimenMeasurementOrFact
    def set_SpecimenMeasurementOrFact(self, SpecimenMeasurementOrFact):
        self.SpecimenMeasurementOrFact = SpecimenMeasurementOrFact
    def add_SpecimenMeasurementOrFact(self, value):
        self.SpecimenMeasurementOrFact.append(value)
    def insert_SpecimenMeasurementOrFact_at(self, index, value):
        self.SpecimenMeasurementOrFact.insert(index, value)
    def replace_SpecimenMeasurementOrFact_at(self, index, value):
        self.SpecimenMeasurementOrFact[index] = value
    def hasContent_(self):
        if (
            self.SpecimenMeasurementOrFact
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='SpecimenMeasurementsOrFactsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SpecimenMeasurementsOrFactsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SpecimenMeasurementsOrFactsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SpecimenMeasurementsOrFactsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SpecimenMeasurementsOrFactsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='SpecimenMeasurementsOrFactsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SpecimenMeasurementOrFact_ in self.SpecimenMeasurementOrFact:
            namespaceprefix_ = self.SpecimenMeasurementOrFact_nsprefix_ + ':' if (UseCapturedNS_ and self.SpecimenMeasurementOrFact_nsprefix_) else ''
            SpecimenMeasurementOrFact_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SpecimenMeasurementOrFact', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'SpecimenMeasurementOrFact':
            obj_ = MeasurementOrFact.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SpecimenMeasurementOrFact.append(obj_)
            obj_.original_tagname_ = 'SpecimenMeasurementOrFact'
# end class SpecimenMeasurementsOrFactsType


class ObservationUnitType(GeneratedsSuper):
    """Data elements specific to observation (recording) units. Note that most
    observation data items are site related and thus covered under
    Gathering."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('ObservationUnitIDs', 'ObservationUnitIDsType', 0, 1, {'minOccurs': '0', 'name': 'ObservationUnitIDs', 'type': 'ObservationUnitIDsType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, ObservationUnitIDs=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ObservationUnitIDs = ObservationUnitIDs
        self.ObservationUnitIDs_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ObservationUnitType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ObservationUnitType.subclass:
            return ObservationUnitType.subclass(*args_, **kwargs_)
        else:
            return ObservationUnitType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ObservationUnitIDs(self):
        return self.ObservationUnitIDs
    def set_ObservationUnitIDs(self, ObservationUnitIDs):
        self.ObservationUnitIDs = ObservationUnitIDs
    def hasContent_(self):
        if (
            self.ObservationUnitIDs is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='ObservationUnitType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ObservationUnitType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ObservationUnitType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ObservationUnitType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ObservationUnitType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='ObservationUnitType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ObservationUnitIDs is not None:
            namespaceprefix_ = self.ObservationUnitIDs_nsprefix_ + ':' if (UseCapturedNS_ and self.ObservationUnitIDs_nsprefix_) else ''
            self.ObservationUnitIDs.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ObservationUnitIDs', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ObservationUnitIDs':
            obj_ = ObservationUnitIDsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ObservationUnitIDs = obj_
            obj_.original_tagname_ = 'ObservationUnitIDs'
# end class ObservationUnitType


class ObservationUnitIDsType(GeneratedsSuper):
    """A container element with several observation unit identifiers."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('ObservationUnitID', 'StringP', 1, 0, {'maxOccurs': 'unbounded', 'name': 'ObservationUnitID', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/observationUnitID', 'type': 'StringP'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, ObservationUnitID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ObservationUnitID is None:
            self.ObservationUnitID = []
        else:
            self.ObservationUnitID = ObservationUnitID
        self.ObservationUnitID_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ObservationUnitIDsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ObservationUnitIDsType.subclass:
            return ObservationUnitIDsType.subclass(*args_, **kwargs_)
        else:
            return ObservationUnitIDsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ObservationUnitID(self):
        return self.ObservationUnitID
    def set_ObservationUnitID(self, ObservationUnitID):
        self.ObservationUnitID = ObservationUnitID
    def add_ObservationUnitID(self, value):
        self.ObservationUnitID.append(value)
    def insert_ObservationUnitID_at(self, index, value):
        self.ObservationUnitID.insert(index, value)
    def replace_ObservationUnitID_at(self, index, value):
        self.ObservationUnitID[index] = value
    def hasContent_(self):
        if (
            self.ObservationUnitID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='ObservationUnitIDsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ObservationUnitIDsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ObservationUnitIDsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ObservationUnitIDsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ObservationUnitIDsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='ObservationUnitIDsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ObservationUnitID_ in self.ObservationUnitID:
            namespaceprefix_ = self.ObservationUnitID_nsprefix_ + ':' if (UseCapturedNS_ and self.ObservationUnitID_nsprefix_) else ''
            ObservationUnitID_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ObservationUnitID', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ObservationUnitID':
            obj_ = StringP.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ObservationUnitID.append(obj_)
            obj_.original_tagname_ = 'ObservationUnitID'
# end class ObservationUnitIDsType


class MultimediaObjectsType5(GeneratedsSuper):
    """Multimedia objects such as images, movies, etc. relating to (or forming)
    the unit. Note that RecordBasis should be set accordingly if the
    multimedia object actually is the unit in the collection (e.g.
    collections of images taken in the field, sound recordings, etc.)."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('MultimediaObject', 'MultimediaObject', 1, 0, {'maxOccurs': 'unbounded', 'name': 'MultimediaObject', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Unit-MultimediaObject', 'type': 'MultimediaObject'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, MultimediaObject=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if MultimediaObject is None:
            self.MultimediaObject = []
        else:
            self.MultimediaObject = MultimediaObject
        self.MultimediaObject_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MultimediaObjectsType5)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MultimediaObjectsType5.subclass:
            return MultimediaObjectsType5.subclass(*args_, **kwargs_)
        else:
            return MultimediaObjectsType5(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_MultimediaObject(self):
        return self.MultimediaObject
    def set_MultimediaObject(self, MultimediaObject):
        self.MultimediaObject = MultimediaObject
    def add_MultimediaObject(self, value):
        self.MultimediaObject.append(value)
    def insert_MultimediaObject_at(self, index, value):
        self.MultimediaObject.insert(index, value)
    def replace_MultimediaObject_at(self, index, value):
        self.MultimediaObject[index] = value
    def hasContent_(self):
        if (
            self.MultimediaObject
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='MultimediaObjectsType5', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MultimediaObjectsType5')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MultimediaObjectsType5')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MultimediaObjectsType5', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MultimediaObjectsType5'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='MultimediaObjectsType5', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for MultimediaObject_ in self.MultimediaObject:
            namespaceprefix_ = self.MultimediaObject_nsprefix_ + ':' if (UseCapturedNS_ and self.MultimediaObject_nsprefix_) else ''
            MultimediaObject_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MultimediaObject', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'MultimediaObject':
            obj_ = MultimediaObject.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MultimediaObject.append(obj_)
            obj_.original_tagname_ = 'MultimediaObject'
# end class MultimediaObjectsType5


class AssociationsType(GeneratedsSuper):
    """Relationships of this unit with other unit for which a record in ABCD
    conformant dataset(s) exists."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('Association', 'AssociationType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'Association', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/Association', 'type': 'AssociationType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, Association=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Association is None:
            self.Association = []
        else:
            self.Association = Association
        self.Association_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AssociationsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AssociationsType.subclass:
            return AssociationsType.subclass(*args_, **kwargs_)
        else:
            return AssociationsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Association(self):
        return self.Association
    def set_Association(self, Association):
        self.Association = Association
    def add_Association(self, value):
        self.Association.append(value)
    def insert_Association_at(self, index, value):
        self.Association.insert(index, value)
    def replace_Association_at(self, index, value):
        self.Association[index] = value
    def hasContent_(self):
        if (
            self.Association
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='AssociationsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AssociationsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AssociationsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AssociationsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AssociationsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='AssociationsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Association_ in self.Association:
            namespaceprefix_ = self.Association_nsprefix_ + ':' if (UseCapturedNS_ and self.Association_nsprefix_) else ''
            Association_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Association', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Association':
            obj_ = AssociationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Association.append(obj_)
            obj_.original_tagname_ = 'Association'
# end class AssociationsType


class AssociationType(GeneratedsSuper):
    """A binary relationship or association of units."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('GUID', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'GUID', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Association-GUID', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('ID', ['String', 'xs:normalizedString'], 0, 0, {'name': 'ID', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Association-ID', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('SourceID', ['String', 'xs:normalizedString'], 0, 0, {'name': 'SourceID', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Association-SourceID', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('SourceInstitutionID', ['String', 'xs:normalizedString'], 0, 0, {'name': 'SourceInstitutionID', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Association-SourceInstitutionID', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('KindOfUnit', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'KindOfUnit', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Association-KindOfUnit', 'type': 'StringL'}, None),
        MemberSpec_('AssociationType', 'AssociationType', 0, 0, {'name': 'AssociationType', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/associationType', 'type': 'StringL'}, None),
        MemberSpec_('DirectAccessURL', 'xs:anyURI', 0, 1, {'minOccurs': '0', 'name': 'DirectAccessURL', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Association-DirectAccessURL', 'type': 'xs:anyURI'}, None),
        MemberSpec_('Notes', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'Notes', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Association-Notes', 'type': 'StringL'}, None),
        MemberSpec_('ResourceURIs', 'ResourceURIsType6', 0, 1, {'minOccurs': '0', 'name': 'ResourceURIs', 'type': 'ResourceURIsType6'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, GUID=None, ID=None, SourceID=None, SourceInstitutionID=None, KindOfUnit=None, AssociationType_member=None, DirectAccessURL=None, Notes=None, ResourceURIs=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.GUID = GUID
        self.validate_String(self.GUID)
        self.GUID_nsprefix_ = None
        self.ID = ID
        self.validate_String(self.ID)
        self.ID_nsprefix_ = None
        self.SourceID = SourceID
        self.validate_String(self.SourceID)
        self.SourceID_nsprefix_ = None
        self.SourceInstitutionID = SourceInstitutionID
        self.validate_String(self.SourceInstitutionID)
        self.SourceInstitutionID_nsprefix_ = None
        self.KindOfUnit = KindOfUnit
        self.KindOfUnit_nsprefix_ = None
        self.AssociationType = AssociationType_member
        self.AssociationType_nsprefix_ = None
        self.DirectAccessURL = DirectAccessURL
        self.DirectAccessURL_nsprefix_ = None
        self.Notes = Notes
        self.Notes_nsprefix_ = None
        self.ResourceURIs = ResourceURIs
        self.ResourceURIs_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AssociationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AssociationType.subclass:
            return AssociationType.subclass(*args_, **kwargs_)
        else:
            return AssociationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_GUID(self):
        return self.GUID
    def set_GUID(self, GUID):
        self.GUID = GUID
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_SourceID(self):
        return self.SourceID
    def set_SourceID(self, SourceID):
        self.SourceID = SourceID
    def get_SourceInstitutionID(self):
        return self.SourceInstitutionID
    def set_SourceInstitutionID(self, SourceInstitutionID):
        self.SourceInstitutionID = SourceInstitutionID
    def get_KindOfUnit(self):
        return self.KindOfUnit
    def set_KindOfUnit(self, KindOfUnit):
        self.KindOfUnit = KindOfUnit
    def get_AssociationType(self):
        return self.AssociationType
    def set_AssociationType(self, AssociationType):
        self.AssociationType = AssociationType
    def get_DirectAccessURL(self):
        return self.DirectAccessURL
    def set_DirectAccessURL(self, DirectAccessURL):
        self.DirectAccessURL = DirectAccessURL
    def get_Notes(self):
        return self.Notes
    def set_Notes(self, Notes):
        self.Notes = Notes
    def get_ResourceURIs(self):
        return self.ResourceURIs
    def set_ResourceURIs(self, ResourceURIs):
        self.ResourceURIs = ResourceURIs
    def validate_String(self, value):
        result = True
        # Validate type String, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on String' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.GUID is not None or
            self.ID is not None or
            self.SourceID is not None or
            self.SourceInstitutionID is not None or
            self.KindOfUnit is not None or
            self.AssociationType is not None or
            self.DirectAccessURL is not None or
            self.Notes is not None or
            self.ResourceURIs is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='AssociationType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AssociationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AssociationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AssociationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AssociationType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='AssociationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.GUID is not None:
            namespaceprefix_ = self.GUID_nsprefix_ + ':' if (UseCapturedNS_ and self.GUID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGUID>%s</%sGUID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.GUID), input_name='GUID')), namespaceprefix_ , eol_))
        if self.ID is not None:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ID), input_name='ID')), namespaceprefix_ , eol_))
        if self.SourceID is not None:
            namespaceprefix_ = self.SourceID_nsprefix_ + ':' if (UseCapturedNS_ and self.SourceID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSourceID>%s</%sSourceID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SourceID), input_name='SourceID')), namespaceprefix_ , eol_))
        if self.SourceInstitutionID is not None:
            namespaceprefix_ = self.SourceInstitutionID_nsprefix_ + ':' if (UseCapturedNS_ and self.SourceInstitutionID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSourceInstitutionID>%s</%sSourceInstitutionID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SourceInstitutionID), input_name='SourceInstitutionID')), namespaceprefix_ , eol_))
        if self.KindOfUnit is not None:
            namespaceprefix_ = self.KindOfUnit_nsprefix_ + ':' if (UseCapturedNS_ and self.KindOfUnit_nsprefix_) else ''
            self.KindOfUnit.export(outfile, level, namespaceprefix_, namespacedef_='', name_='KindOfUnit', pretty_print=pretty_print)
        if self.AssociationType is not None:
            namespaceprefix_ = self.AssociationType_nsprefix_ + ':' if (UseCapturedNS_ and self.AssociationType_nsprefix_) else ''
            self.AssociationType.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AssociationType', pretty_print=pretty_print)
        if self.DirectAccessURL is not None:
            namespaceprefix_ = self.DirectAccessURL_nsprefix_ + ':' if (UseCapturedNS_ and self.DirectAccessURL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDirectAccessURL>%s</%sDirectAccessURL>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DirectAccessURL), input_name='DirectAccessURL')), namespaceprefix_ , eol_))
        if self.Notes is not None:
            namespaceprefix_ = self.Notes_nsprefix_ + ':' if (UseCapturedNS_ and self.Notes_nsprefix_) else ''
            self.Notes.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Notes', pretty_print=pretty_print)
        if self.ResourceURIs is not None:
            namespaceprefix_ = self.ResourceURIs_nsprefix_ + ':' if (UseCapturedNS_ and self.ResourceURIs_nsprefix_) else ''
            self.ResourceURIs.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ResourceURIs', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'GUID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'GUID')
            value_ = self.gds_validate_string(value_, node, 'GUID')
            self.GUID = value_
            self.GUID_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.GUID)
        elif nodeName_ == 'ID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ID')
            value_ = self.gds_validate_string(value_, node, 'ID')
            self.ID = value_
            self.ID_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.ID)
        elif nodeName_ == 'SourceID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SourceID')
            value_ = self.gds_validate_string(value_, node, 'SourceID')
            self.SourceID = value_
            self.SourceID_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.SourceID)
        elif nodeName_ == 'SourceInstitutionID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SourceInstitutionID')
            value_ = self.gds_validate_string(value_, node, 'SourceInstitutionID')
            self.SourceInstitutionID = value_
            self.SourceInstitutionID_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.SourceInstitutionID)
        elif nodeName_ == 'KindOfUnit':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.KindOfUnit = obj_
            obj_.original_tagname_ = 'KindOfUnit'
        elif nodeName_ == 'AssociationType':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AssociationType = obj_
            obj_.original_tagname_ = 'AssociationType'
        elif nodeName_ == 'DirectAccessURL':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DirectAccessURL')
            value_ = self.gds_validate_string(value_, node, 'DirectAccessURL')
            self.DirectAccessURL = value_
            self.DirectAccessURL_nsprefix_ = child_.prefix
        elif nodeName_ == 'Notes':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Notes = obj_
            obj_.original_tagname_ = 'Notes'
        elif nodeName_ == 'ResourceURIs':
            obj_ = ResourceURIsType6.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ResourceURIs = obj_
            obj_.original_tagname_ = 'ResourceURIs'
# end class AssociationType


class ResourceURIsType6(GeneratedsSuper):
    """Preferably resolvable URIs of the association."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('ResourceURI', 'xs:anyURI', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'ResourceURI', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Association-ResourceURI', 'type': 'xs:anyURI'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, ResourceURI=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ResourceURI is None:
            self.ResourceURI = []
        else:
            self.ResourceURI = ResourceURI
        self.ResourceURI_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ResourceURIsType6)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ResourceURIsType6.subclass:
            return ResourceURIsType6.subclass(*args_, **kwargs_)
        else:
            return ResourceURIsType6(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ResourceURI(self):
        return self.ResourceURI
    def set_ResourceURI(self, ResourceURI):
        self.ResourceURI = ResourceURI
    def add_ResourceURI(self, value):
        self.ResourceURI.append(value)
    def insert_ResourceURI_at(self, index, value):
        self.ResourceURI.insert(index, value)
    def replace_ResourceURI_at(self, index, value):
        self.ResourceURI[index] = value
    def hasContent_(self):
        if (
            self.ResourceURI
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='ResourceURIsType6', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ResourceURIsType6')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ResourceURIsType6')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ResourceURIsType6', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ResourceURIsType6'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='ResourceURIsType6', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ResourceURI_ in self.ResourceURI:
            namespaceprefix_ = self.ResourceURI_nsprefix_ + ':' if (UseCapturedNS_ and self.ResourceURI_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sResourceURI>%s</%sResourceURI>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(ResourceURI_), input_name='ResourceURI')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ResourceURI':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ResourceURI')
            value_ = self.gds_validate_string(value_, node, 'ResourceURI')
            self.ResourceURI.append(value_)
            self.ResourceURI_nsprefix_ = child_.prefix
# end class ResourceURIsType6


class AssemblagesType(GeneratedsSuper):
    """A container for groupings of this unit with other units for which a
    record exists in this dataset by means of an additional ID."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('Assemblage', 'AssemblageType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'Assemblage', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/Assemblage', 'type': 'AssemblageType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, Assemblage=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Assemblage is None:
            self.Assemblage = []
        else:
            self.Assemblage = Assemblage
        self.Assemblage_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AssemblagesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AssemblagesType.subclass:
            return AssemblagesType.subclass(*args_, **kwargs_)
        else:
            return AssemblagesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Assemblage(self):
        return self.Assemblage
    def set_Assemblage(self, Assemblage):
        self.Assemblage = Assemblage
    def add_Assemblage(self, value):
        self.Assemblage.append(value)
    def insert_Assemblage_at(self, index, value):
        self.Assemblage.insert(index, value)
    def replace_Assemblage_at(self, index, value):
        self.Assemblage[index] = value
    def hasContent_(self):
        if (
            self.Assemblage
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='AssemblagesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AssemblagesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AssemblagesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AssemblagesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AssemblagesType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='AssemblagesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Assemblage_ in self.Assemblage:
            namespaceprefix_ = self.Assemblage_nsprefix_ + ':' if (UseCapturedNS_ and self.Assemblage_nsprefix_) else ''
            Assemblage_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Assemblage', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Assemblage':
            obj_ = AssemblageType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Assemblage.append(obj_)
            obj_.original_tagname_ = 'Assemblage'
# end class AssemblagesType


class AssemblageType(GeneratedsSuper):
    """A unit assemblage handles symmetric relationships between several
    units."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('ID', ['String', 'xs:normalizedString'], 0, 0, {'name': 'ID', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Assemblage-ID', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('AssemblageName', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'AssemblageName', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Assemblage-Name', 'type': 'StringL'}, None),
        MemberSpec_('ResourceURIs', 'ResourceURIsType7', 0, 1, {'minOccurs': '0', 'name': 'ResourceURIs', 'type': 'ResourceURIsType7'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, ID=None, AssemblageName=None, ResourceURIs=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = ID
        self.validate_String(self.ID)
        self.ID_nsprefix_ = None
        self.AssemblageName = AssemblageName
        self.AssemblageName_nsprefix_ = None
        self.ResourceURIs = ResourceURIs
        self.ResourceURIs_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AssemblageType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AssemblageType.subclass:
            return AssemblageType.subclass(*args_, **kwargs_)
        else:
            return AssemblageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_AssemblageName(self):
        return self.AssemblageName
    def set_AssemblageName(self, AssemblageName):
        self.AssemblageName = AssemblageName
    def get_ResourceURIs(self):
        return self.ResourceURIs
    def set_ResourceURIs(self, ResourceURIs):
        self.ResourceURIs = ResourceURIs
    def validate_String(self, value):
        result = True
        # Validate type String, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on String' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.ID is not None or
            self.AssemblageName is not None or
            self.ResourceURIs is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='AssemblageType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AssemblageType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AssemblageType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AssemblageType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AssemblageType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='AssemblageType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ID), input_name='ID')), namespaceprefix_ , eol_))
        if self.AssemblageName is not None:
            namespaceprefix_ = self.AssemblageName_nsprefix_ + ':' if (UseCapturedNS_ and self.AssemblageName_nsprefix_) else ''
            self.AssemblageName.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AssemblageName', pretty_print=pretty_print)
        if self.ResourceURIs is not None:
            namespaceprefix_ = self.ResourceURIs_nsprefix_ + ':' if (UseCapturedNS_ and self.ResourceURIs_nsprefix_) else ''
            self.ResourceURIs.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ResourceURIs', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ID')
            value_ = self.gds_validate_string(value_, node, 'ID')
            self.ID = value_
            self.ID_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.ID)
        elif nodeName_ == 'AssemblageName':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AssemblageName = obj_
            obj_.original_tagname_ = 'AssemblageName'
        elif nodeName_ == 'ResourceURIs':
            obj_ = ResourceURIsType7.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ResourceURIs = obj_
            obj_.original_tagname_ = 'ResourceURIs'
# end class AssemblageType


class ResourceURIsType7(GeneratedsSuper):
    """Preferably resolvable URIs of the assemblage."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('ResourceURI', 'xs:anyURI', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'ResourceURI', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Assemblage-ResourceURI', 'type': 'xs:anyURI'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, ResourceURI=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ResourceURI is None:
            self.ResourceURI = []
        else:
            self.ResourceURI = ResourceURI
        self.ResourceURI_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ResourceURIsType7)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ResourceURIsType7.subclass:
            return ResourceURIsType7.subclass(*args_, **kwargs_)
        else:
            return ResourceURIsType7(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ResourceURI(self):
        return self.ResourceURI
    def set_ResourceURI(self, ResourceURI):
        self.ResourceURI = ResourceURI
    def add_ResourceURI(self, value):
        self.ResourceURI.append(value)
    def insert_ResourceURI_at(self, index, value):
        self.ResourceURI.insert(index, value)
    def replace_ResourceURI_at(self, index, value):
        self.ResourceURI[index] = value
    def hasContent_(self):
        if (
            self.ResourceURI
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='ResourceURIsType7', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ResourceURIsType7')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ResourceURIsType7')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ResourceURIsType7', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ResourceURIsType7'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='ResourceURIsType7', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ResourceURI_ in self.ResourceURI:
            namespaceprefix_ = self.ResourceURI_nsprefix_ + ':' if (UseCapturedNS_ and self.ResourceURI_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sResourceURI>%s</%sResourceURI>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(ResourceURI_), input_name='ResourceURI')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ResourceURI':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ResourceURI')
            value_ = self.gds_validate_string(value_, node, 'ResourceURI')
            self.ResourceURI.append(value_)
            self.ResourceURI_nsprefix_ = child_.prefix
# end class ResourceURIsType7


class NamedCollectionsOrSurveysType(GeneratedsSuper):
    """Unit may belong to one or several collections or survey projects which
    have distinctive names and do not correspond to the SourceName. Note
    that this element refers to the name accepted by the specimen or data
    holding institution, this may or may not be different from the project
    name given under Gathering."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('NamedCollectionOrSurvey', 'StringL', 1, 0, {'maxOccurs': 'unbounded', 'name': 'NamedCollectionOrSurvey', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/namedCollectionOrSurvey', 'type': 'StringL'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, NamedCollectionOrSurvey=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if NamedCollectionOrSurvey is None:
            self.NamedCollectionOrSurvey = []
        else:
            self.NamedCollectionOrSurvey = NamedCollectionOrSurvey
        self.NamedCollectionOrSurvey_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NamedCollectionsOrSurveysType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NamedCollectionsOrSurveysType.subclass:
            return NamedCollectionsOrSurveysType.subclass(*args_, **kwargs_)
        else:
            return NamedCollectionsOrSurveysType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_NamedCollectionOrSurvey(self):
        return self.NamedCollectionOrSurvey
    def set_NamedCollectionOrSurvey(self, NamedCollectionOrSurvey):
        self.NamedCollectionOrSurvey = NamedCollectionOrSurvey
    def add_NamedCollectionOrSurvey(self, value):
        self.NamedCollectionOrSurvey.append(value)
    def insert_NamedCollectionOrSurvey_at(self, index, value):
        self.NamedCollectionOrSurvey.insert(index, value)
    def replace_NamedCollectionOrSurvey_at(self, index, value):
        self.NamedCollectionOrSurvey[index] = value
    def hasContent_(self):
        if (
            self.NamedCollectionOrSurvey
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='NamedCollectionsOrSurveysType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NamedCollectionsOrSurveysType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NamedCollectionsOrSurveysType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NamedCollectionsOrSurveysType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NamedCollectionsOrSurveysType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='NamedCollectionsOrSurveysType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for NamedCollectionOrSurvey_ in self.NamedCollectionOrSurvey:
            namespaceprefix_ = self.NamedCollectionOrSurvey_nsprefix_ + ':' if (UseCapturedNS_ and self.NamedCollectionOrSurvey_nsprefix_) else ''
            NamedCollectionOrSurvey_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NamedCollectionOrSurvey', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'NamedCollectionOrSurvey':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NamedCollectionOrSurvey.append(obj_)
            obj_.original_tagname_ = 'NamedCollectionOrSurvey'
# end class NamedCollectionsOrSurveysType


class FieldNumbersType(GeneratedsSuper):
    """The numbers or other identifiers assigned to this Unit by different
    collectors (Gathering Agents). Commonly referred to as "Collectors
    Field Number"."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('FieldNumber', 'FieldNumberType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'FieldNumber', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/FieldNumber', 'type': 'FieldNumberType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, FieldNumber=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if FieldNumber is None:
            self.FieldNumber = []
        else:
            self.FieldNumber = FieldNumber
        self.FieldNumber_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FieldNumbersType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FieldNumbersType.subclass:
            return FieldNumbersType.subclass(*args_, **kwargs_)
        else:
            return FieldNumbersType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_FieldNumber(self):
        return self.FieldNumber
    def set_FieldNumber(self, FieldNumber):
        self.FieldNumber = FieldNumber
    def add_FieldNumber(self, value):
        self.FieldNumber.append(value)
    def insert_FieldNumber_at(self, index, value):
        self.FieldNumber.insert(index, value)
    def replace_FieldNumber_at(self, index, value):
        self.FieldNumber[index] = value
    def hasContent_(self):
        if (
            self.FieldNumber
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='FieldNumbersType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FieldNumbersType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FieldNumbersType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FieldNumbersType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FieldNumbersType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='FieldNumbersType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for FieldNumber_ in self.FieldNumber:
            namespaceprefix_ = self.FieldNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.FieldNumber_nsprefix_) else ''
            FieldNumber_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='FieldNumber', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'FieldNumber':
            obj_ = FieldNumberType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.FieldNumber.append(obj_)
            obj_.original_tagname_ = 'FieldNumber'
# end class FieldNumbersType


class FieldNumberType(GeneratedsSuper):
    """The number or other identifier assigned to a Unit by a collector
    (Gathering Agent). Commonly referred to as "Collectors Field
    Number"."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('ID', ['String', 'xs:normalizedString'], 0, 0, {'name': 'ID', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/FieldNumber-ID', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('CollectorName', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'CollectorName', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/FieldNumber-CollectorName', 'type': 'xs:normalizedString'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, ID=None, CollectorName=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ID = ID
        self.validate_String(self.ID)
        self.ID_nsprefix_ = None
        self.CollectorName = CollectorName
        self.validate_String(self.CollectorName)
        self.CollectorName_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FieldNumberType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FieldNumberType.subclass:
            return FieldNumberType.subclass(*args_, **kwargs_)
        else:
            return FieldNumberType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_CollectorName(self):
        return self.CollectorName
    def set_CollectorName(self, CollectorName):
        self.CollectorName = CollectorName
    def validate_String(self, value):
        result = True
        # Validate type String, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on String' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.ID is not None or
            self.CollectorName is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='FieldNumberType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FieldNumberType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FieldNumberType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FieldNumberType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FieldNumberType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='FieldNumberType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ID), input_name='ID')), namespaceprefix_ , eol_))
        if self.CollectorName is not None:
            namespaceprefix_ = self.CollectorName_nsprefix_ + ':' if (UseCapturedNS_ and self.CollectorName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCollectorName>%s</%sCollectorName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CollectorName), input_name='CollectorName')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ID')
            value_ = self.gds_validate_string(value_, node, 'ID')
            self.ID = value_
            self.ID_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.ID)
        elif nodeName_ == 'CollectorName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CollectorName')
            value_ = self.gds_validate_string(value_, node, 'CollectorName')
            self.CollectorName = value_
            self.CollectorName_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.CollectorName)
# end class FieldNumberType


class FieldNotesReferencesType(GeneratedsSuper):
    """References where corresponding Field Notes are published."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('FieldNotesReference', 'Reference', 1, 0, {'maxOccurs': 'unbounded', 'name': 'FieldNotesReference', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/FieldNotesReference', 'type': 'Reference'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, FieldNotesReference=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if FieldNotesReference is None:
            self.FieldNotesReference = []
        else:
            self.FieldNotesReference = FieldNotesReference
        self.FieldNotesReference_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FieldNotesReferencesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FieldNotesReferencesType.subclass:
            return FieldNotesReferencesType.subclass(*args_, **kwargs_)
        else:
            return FieldNotesReferencesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_FieldNotesReference(self):
        return self.FieldNotesReference
    def set_FieldNotesReference(self, FieldNotesReference):
        self.FieldNotesReference = FieldNotesReference
    def add_FieldNotesReference(self, value):
        self.FieldNotesReference.append(value)
    def insert_FieldNotesReference_at(self, index, value):
        self.FieldNotesReference.insert(index, value)
    def replace_FieldNotesReference_at(self, index, value):
        self.FieldNotesReference[index] = value
    def hasContent_(self):
        if (
            self.FieldNotesReference
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='FieldNotesReferencesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FieldNotesReferencesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FieldNotesReferencesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FieldNotesReferencesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FieldNotesReferencesType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='FieldNotesReferencesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for FieldNotesReference_ in self.FieldNotesReference:
            namespaceprefix_ = self.FieldNotesReference_nsprefix_ + ':' if (UseCapturedNS_ and self.FieldNotesReference_nsprefix_) else ''
            FieldNotesReference_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='FieldNotesReference', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'FieldNotesReference':
            obj_ = Reference.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.FieldNotesReference.append(obj_)
            obj_.original_tagname_ = 'FieldNotesReference'
# end class FieldNotesReferencesType


class MeasurementsOrFactsType8(GeneratedsSuper):
    """A container for quantitative and categorical measurements (including
    observations) referring to the unit, e.g. counts, size measurements,
    colours, etc."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('MeasurementOrFact', 'MeasurementOrFact', 1, 0, {'maxOccurs': 'unbounded', 'name': 'MeasurementOrFact', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Unit-MeasurementOrFact', 'type': 'MeasurementOrFact'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, MeasurementOrFact=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if MeasurementOrFact is None:
            self.MeasurementOrFact = []
        else:
            self.MeasurementOrFact = MeasurementOrFact
        self.MeasurementOrFact_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MeasurementsOrFactsType8)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MeasurementsOrFactsType8.subclass:
            return MeasurementsOrFactsType8.subclass(*args_, **kwargs_)
        else:
            return MeasurementsOrFactsType8(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_MeasurementOrFact(self):
        return self.MeasurementOrFact
    def set_MeasurementOrFact(self, MeasurementOrFact):
        self.MeasurementOrFact = MeasurementOrFact
    def add_MeasurementOrFact(self, value):
        self.MeasurementOrFact.append(value)
    def insert_MeasurementOrFact_at(self, index, value):
        self.MeasurementOrFact.insert(index, value)
    def replace_MeasurementOrFact_at(self, index, value):
        self.MeasurementOrFact[index] = value
    def hasContent_(self):
        if (
            self.MeasurementOrFact
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='MeasurementsOrFactsType8', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MeasurementsOrFactsType8')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MeasurementsOrFactsType8')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MeasurementsOrFactsType8', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MeasurementsOrFactsType8'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='MeasurementsOrFactsType8', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for MeasurementOrFact_ in self.MeasurementOrFact:
            namespaceprefix_ = self.MeasurementOrFact_nsprefix_ + ':' if (UseCapturedNS_ and self.MeasurementOrFact_nsprefix_) else ''
            MeasurementOrFact_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MeasurementOrFact', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'MeasurementOrFact':
            obj_ = MeasurementOrFact.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MeasurementOrFact.append(obj_)
            obj_.original_tagname_ = 'MeasurementOrFact'
# end class MeasurementsOrFactsType8


class SequencesType(GeneratedsSuper):
    """Container for metadata on sequences derived from this unit."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('Sequence', 'Sequence', 1, 0, {'maxOccurs': 'unbounded', 'name': 'Sequence', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/Sequence', 'type': 'Sequence'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, Sequence=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Sequence is None:
            self.Sequence = []
        else:
            self.Sequence = Sequence
        self.Sequence_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SequencesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SequencesType.subclass:
            return SequencesType.subclass(*args_, **kwargs_)
        else:
            return SequencesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Sequence(self):
        return self.Sequence
    def set_Sequence(self, Sequence):
        self.Sequence = Sequence
    def add_Sequence(self, value):
        self.Sequence.append(value)
    def insert_Sequence_at(self, index, value):
        self.Sequence.insert(index, value)
    def replace_Sequence_at(self, index, value):
        self.Sequence[index] = value
    def hasContent_(self):
        if (
            self.Sequence
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='SequencesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SequencesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SequencesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SequencesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SequencesType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='SequencesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Sequence_ in self.Sequence:
            namespaceprefix_ = self.Sequence_nsprefix_ + ':' if (UseCapturedNS_ and self.Sequence_nsprefix_) else ''
            Sequence_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Sequence', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Sequence':
            obj_ = Sequence.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Sequence.append(obj_)
            obj_.original_tagname_ = 'Sequence'
# end class SequencesType


class AnnotationsType(GeneratedsSuper):
    """Annotations in electronic form not (yet) added to the structured unit
    record."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('Annotation', 'AnnotationType', 0, 0, {'name': 'Annotation', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/Annotation', 'type': 'AnnotationType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, Annotation=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Annotation = Annotation
        self.Annotation_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AnnotationsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AnnotationsType.subclass:
            return AnnotationsType.subclass(*args_, **kwargs_)
        else:
            return AnnotationsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Annotation(self):
        return self.Annotation
    def set_Annotation(self, Annotation):
        self.Annotation = Annotation
    def hasContent_(self):
        if (
            self.Annotation is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='AnnotationsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AnnotationsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AnnotationsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AnnotationsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AnnotationsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='AnnotationsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Annotation is not None:
            namespaceprefix_ = self.Annotation_nsprefix_ + ':' if (UseCapturedNS_ and self.Annotation_nsprefix_) else ''
            self.Annotation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Annotation', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Annotation':
            obj_ = AnnotationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Annotation = obj_
            obj_.original_tagname_ = 'Annotation'
# end class AnnotationsType


class AnnotationType(GeneratedsSuper):
    """A structure for electronic annotations of the unit."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('Text', 'StringL', 0, 0, {'name': 'Text', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Annotation-Text', 'type': 'StringL'}, None),
        MemberSpec_('Annotator', 'Contact', 0, 1, {'minOccurs': '0', 'name': 'Annotator', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Annotator', 'type': 'Contact'}, None),
        MemberSpec_('Date', 'DateTime', 0, 1, {'minOccurs': '0', 'name': 'Date', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Annotation-Date', 'type': 'DateTime'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, Text=None, Annotator=None, Date=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Text = Text
        self.Text_nsprefix_ = None
        self.Annotator = Annotator
        self.Annotator_nsprefix_ = None
        self.Date = Date
        self.Date_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AnnotationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AnnotationType.subclass:
            return AnnotationType.subclass(*args_, **kwargs_)
        else:
            return AnnotationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Text(self):
        return self.Text
    def set_Text(self, Text):
        self.Text = Text
    def get_Annotator(self):
        return self.Annotator
    def set_Annotator(self, Annotator):
        self.Annotator = Annotator
    def get_Date(self):
        return self.Date
    def set_Date(self, Date):
        self.Date = Date
    def hasContent_(self):
        if (
            self.Text is not None or
            self.Annotator is not None or
            self.Date is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='AnnotationType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AnnotationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AnnotationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AnnotationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AnnotationType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='AnnotationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Text is not None:
            namespaceprefix_ = self.Text_nsprefix_ + ':' if (UseCapturedNS_ and self.Text_nsprefix_) else ''
            self.Text.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Text', pretty_print=pretty_print)
        if self.Annotator is not None:
            namespaceprefix_ = self.Annotator_nsprefix_ + ':' if (UseCapturedNS_ and self.Annotator_nsprefix_) else ''
            self.Annotator.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Annotator', pretty_print=pretty_print)
        if self.Date is not None:
            namespaceprefix_ = self.Date_nsprefix_ + ':' if (UseCapturedNS_ and self.Date_nsprefix_) else ''
            self.Date.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Date', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Text':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Text = obj_
            obj_.original_tagname_ = 'Text'
        elif nodeName_ == 'Annotator':
            class_obj_ = self.get_class_obj_(child_, Contact)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Annotator = obj_
            obj_.original_tagname_ = 'Annotator'
        elif nodeName_ == 'Date':
            obj_ = DateTime.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Date = obj_
            obj_.original_tagname_ = 'Date'
# end class AnnotationType


class UnitExtensionsType(GeneratedsSuper):
    """A container element to allow extensions to add additional data to the
    unit."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('UnitExtension', 'xs:string', 1, 0, {'maxOccurs': 'unbounded', 'name': 'UnitExtension', 'type': 'xs:string'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, UnitExtension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if UnitExtension is None:
            self.UnitExtension = []
        else:
            self.UnitExtension = UnitExtension
        self.UnitExtension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UnitExtensionsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UnitExtensionsType.subclass:
            return UnitExtensionsType.subclass(*args_, **kwargs_)
        else:
            return UnitExtensionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_UnitExtension(self):
        return self.UnitExtension
    def set_UnitExtension(self, UnitExtension):
        self.UnitExtension = UnitExtension
    def add_UnitExtension(self, value):
        self.UnitExtension.append(value)
    def insert_UnitExtension_at(self, index, value):
        self.UnitExtension.insert(index, value)
    def replace_UnitExtension_at(self, index, value):
        self.UnitExtension[index] = value
    def hasContent_(self):
        if (
            self.UnitExtension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='UnitExtensionsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('UnitExtensionsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UnitExtensionsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='UnitExtensionsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='UnitExtensionsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='UnitExtensionsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for UnitExtension_ in self.UnitExtension:
            namespaceprefix_ = self.UnitExtension_nsprefix_ + ':' if (UseCapturedNS_ and self.UnitExtension_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUnitExtension>%s</%sUnitExtension>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(UnitExtension_), input_name='UnitExtension')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'UnitExtension':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'UnitExtension')
            value_ = self.gds_validate_string(value_, node, 'UnitExtension')
            self.UnitExtension.append(value_)
            self.UnitExtension_nsprefix_ = child_.prefix
# end class UnitExtensionsType


class ResourceURIsType9(GeneratedsSuper):
    """Preferably resolvable URIs of the unit."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('ResourceURI', 'xs:anyURI', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'ResourceURI', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Unit-ResourceURI', 'type': 'xs:anyURI'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, ResourceURI=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ResourceURI is None:
            self.ResourceURI = []
        else:
            self.ResourceURI = ResourceURI
        self.ResourceURI_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ResourceURIsType9)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ResourceURIsType9.subclass:
            return ResourceURIsType9.subclass(*args_, **kwargs_)
        else:
            return ResourceURIsType9(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ResourceURI(self):
        return self.ResourceURI
    def set_ResourceURI(self, ResourceURI):
        self.ResourceURI = ResourceURI
    def add_ResourceURI(self, value):
        self.ResourceURI.append(value)
    def insert_ResourceURI_at(self, index, value):
        self.ResourceURI.insert(index, value)
    def replace_ResourceURI_at(self, index, value):
        self.ResourceURI[index] = value
    def hasContent_(self):
        if (
            self.ResourceURI
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='ResourceURIsType9', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ResourceURIsType9')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ResourceURIsType9')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ResourceURIsType9', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ResourceURIsType9'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='ResourceURIsType9', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ResourceURI_ in self.ResourceURI:
            namespaceprefix_ = self.ResourceURI_nsprefix_ + ':' if (UseCapturedNS_ and self.ResourceURI_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sResourceURI>%s</%sResourceURI>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(ResourceURI_), input_name='ResourceURI')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ResourceURI':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ResourceURI')
            value_ = self.gds_validate_string(value_, node, 'ResourceURI')
            self.ResourceURI.append(value_)
            self.ResourceURI_nsprefix_ = child_.prefix
# end class ResourceURIsType9


class LicensesType(GeneratedsSuper):
    """Container element for one to several statements, normally representing
    different language representations of the same content."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('License', 'LegalStatement', 1, 0, {'maxOccurs': 'unbounded', 'name': 'License', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/License', 'type': 'LegalStatement'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, License=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if License is None:
            self.License = []
        else:
            self.License = License
        self.License_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LicensesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LicensesType.subclass:
            return LicensesType.subclass(*args_, **kwargs_)
        else:
            return LicensesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_License(self):
        return self.License
    def set_License(self, License):
        self.License = License
    def add_License(self, value):
        self.License.append(value)
    def insert_License_at(self, index, value):
        self.License.insert(index, value)
    def replace_License_at(self, index, value):
        self.License[index] = value
    def hasContent_(self):
        if (
            self.License
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='LicensesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LicensesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LicensesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LicensesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LicensesType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='LicensesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for License_ in self.License:
            namespaceprefix_ = self.License_nsprefix_ + ':' if (UseCapturedNS_ and self.License_nsprefix_) else ''
            License_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='License', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'License':
            obj_ = LegalStatement.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.License.append(obj_)
            obj_.original_tagname_ = 'License'
# end class LicensesType


class AcknowledgementsType(GeneratedsSuper):
    """Container element for one to several statements, normally representing
    different language representations of the same content."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('Acknowledgement', 'LegalStatement', 1, 0, {'maxOccurs': 'unbounded', 'name': 'Acknowledgement', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Acknowledgement', 'type': 'LegalStatement'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, Acknowledgement=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Acknowledgement is None:
            self.Acknowledgement = []
        else:
            self.Acknowledgement = Acknowledgement
        self.Acknowledgement_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AcknowledgementsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AcknowledgementsType.subclass:
            return AcknowledgementsType.subclass(*args_, **kwargs_)
        else:
            return AcknowledgementsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Acknowledgement(self):
        return self.Acknowledgement
    def set_Acknowledgement(self, Acknowledgement):
        self.Acknowledgement = Acknowledgement
    def add_Acknowledgement(self, value):
        self.Acknowledgement.append(value)
    def insert_Acknowledgement_at(self, index, value):
        self.Acknowledgement.insert(index, value)
    def replace_Acknowledgement_at(self, index, value):
        self.Acknowledgement[index] = value
    def hasContent_(self):
        if (
            self.Acknowledgement
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='AcknowledgementsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AcknowledgementsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AcknowledgementsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AcknowledgementsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AcknowledgementsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='AcknowledgementsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Acknowledgement_ in self.Acknowledgement:
            namespaceprefix_ = self.Acknowledgement_nsprefix_ + ':' if (UseCapturedNS_ and self.Acknowledgement_nsprefix_) else ''
            Acknowledgement_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Acknowledgement', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Acknowledgement':
            obj_ = LegalStatement.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Acknowledgement.append(obj_)
            obj_.original_tagname_ = 'Acknowledgement'
# end class AcknowledgementsType


class SuggestedCitationsType(GeneratedsSuper):
    """Container element for one to several statements, normally representing
    different language representations of the same content."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('SuggestedCitation', 'LegalStatement', 1, 0, {'maxOccurs': 'unbounded', 'name': 'SuggestedCitation', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/SuggestedCitation', 'type': 'LegalStatement'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, SuggestedCitation=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if SuggestedCitation is None:
            self.SuggestedCitation = []
        else:
            self.SuggestedCitation = SuggestedCitation
        self.SuggestedCitation_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SuggestedCitationsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SuggestedCitationsType.subclass:
            return SuggestedCitationsType.subclass(*args_, **kwargs_)
        else:
            return SuggestedCitationsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_SuggestedCitation(self):
        return self.SuggestedCitation
    def set_SuggestedCitation(self, SuggestedCitation):
        self.SuggestedCitation = SuggestedCitation
    def add_SuggestedCitation(self, value):
        self.SuggestedCitation.append(value)
    def insert_SuggestedCitation_at(self, index, value):
        self.SuggestedCitation.insert(index, value)
    def replace_SuggestedCitation_at(self, index, value):
        self.SuggestedCitation[index] = value
    def hasContent_(self):
        if (
            self.SuggestedCitation
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='SuggestedCitationsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SuggestedCitationsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SuggestedCitationsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SuggestedCitationsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SuggestedCitationsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='SuggestedCitationsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SuggestedCitation_ in self.SuggestedCitation:
            namespaceprefix_ = self.SuggestedCitation_nsprefix_ + ':' if (UseCapturedNS_ and self.SuggestedCitation_nsprefix_) else ''
            SuggestedCitation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SuggestedCitation', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'SuggestedCitation':
            obj_ = LegalStatement.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SuggestedCitation.append(obj_)
            obj_.original_tagname_ = 'SuggestedCitation'
# end class SuggestedCitationsType


class OtherLegalStatementsType(GeneratedsSuper):
    """Container element for one to several statements, normally representing
    different language representations of the same content."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('OtherLegalStatement', 'LegalStatement', 1, 0, {'maxOccurs': 'unbounded', 'name': 'OtherLegalStatement', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/OtherLegalStatement', 'type': 'LegalStatement'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, OtherLegalStatement=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if OtherLegalStatement is None:
            self.OtherLegalStatement = []
        else:
            self.OtherLegalStatement = OtherLegalStatement
        self.OtherLegalStatement_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OtherLegalStatementsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OtherLegalStatementsType.subclass:
            return OtherLegalStatementsType.subclass(*args_, **kwargs_)
        else:
            return OtherLegalStatementsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_OtherLegalStatement(self):
        return self.OtherLegalStatement
    def set_OtherLegalStatement(self, OtherLegalStatement):
        self.OtherLegalStatement = OtherLegalStatement
    def add_OtherLegalStatement(self, value):
        self.OtherLegalStatement.append(value)
    def insert_OtherLegalStatement_at(self, index, value):
        self.OtherLegalStatement.insert(index, value)
    def replace_OtherLegalStatement_at(self, index, value):
        self.OtherLegalStatement[index] = value
    def hasContent_(self):
        if (
            self.OtherLegalStatement
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='OtherLegalStatementsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OtherLegalStatementsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OtherLegalStatementsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='OtherLegalStatementsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='OtherLegalStatementsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='OtherLegalStatementsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for OtherLegalStatement_ in self.OtherLegalStatement:
            namespaceprefix_ = self.OtherLegalStatement_nsprefix_ + ':' if (UseCapturedNS_ and self.OtherLegalStatement_nsprefix_) else ''
            OtherLegalStatement_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='OtherLegalStatement', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'OtherLegalStatement':
            obj_ = LegalStatement.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OtherLegalStatement.append(obj_)
            obj_.original_tagname_ = 'OtherLegalStatement'
# end class OtherLegalStatementsType


class TagsType(GeneratedsSuper):
    """General keywords or tags. Tags may be multi-worded phrases. Where
    scientific names, common names, geographic locations, etc. are
    separable, those should go into the more specific coverage metadata
    items provided further below. Examples: "flower diagram". Character or
    part keywords like "leaf", or "flower color" are especially
    desirable."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('Tag', ['String', 'xs:normalizedString'], 1, 0, {'maxOccurs': 'unbounded', 'name': 'Tag', 'sawsdl:modelReference': 'http://rs.tdwg.org/ac/terms/tag', 'type': 'xs:normalizedString'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, Tag=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Tag is None:
            self.Tag = []
        else:
            self.Tag = Tag
        self.Tag_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TagsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TagsType.subclass:
            return TagsType.subclass(*args_, **kwargs_)
        else:
            return TagsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Tag(self):
        return self.Tag
    def set_Tag(self, Tag):
        self.Tag = Tag
    def add_Tag(self, value):
        self.Tag.append(value)
    def insert_Tag_at(self, index, value):
        self.Tag.insert(index, value)
    def replace_Tag_at(self, index, value):
        self.Tag[index] = value
    def validate_String(self, value):
        result = True
        # Validate type String, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on String' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.Tag
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='TagsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TagsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TagsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TagsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TagsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='TagsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Tag_ in self.Tag:
            namespaceprefix_ = self.Tag_nsprefix_ + ':' if (UseCapturedNS_ and self.Tag_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTag>%s</%sTag>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(Tag_), input_name='Tag')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Tag':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Tag')
            value_ = self.gds_validate_string(value_, node, 'Tag')
            self.Tag.append(value_)
            self.Tag_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.Tag[-1])
# end class TagsType


class RatingsType(GeneratedsSuper):
    """A rating of the media resources, provided by record originators or
    editors, with -1 defining rejected, 0 defining unrated, and 1
    (worst) to 5 (best). The origin of the rating is not communicated. It
    may, e. g., be based on user feedback or on editorial ratings. If
    Rating is not present, a value of 0 may be assumed. By "user-assigned"
    is meant assigned by the originator or editor of the record using the
    term."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('Rating', ['String', 'xs:normalizedString'], 1, 0, {'maxOccurs': 'unbounded', 'name': 'Rating', 'sawsdl:modelReference': 'http://ns.adobe.com/xap/1.0/Rating', 'type': 'xs:normalizedString'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, Rating=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Rating is None:
            self.Rating = []
        else:
            self.Rating = Rating
        self.Rating_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RatingsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RatingsType.subclass:
            return RatingsType.subclass(*args_, **kwargs_)
        else:
            return RatingsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Rating(self):
        return self.Rating
    def set_Rating(self, Rating):
        self.Rating = Rating
    def add_Rating(self, value):
        self.Rating.append(value)
    def insert_Rating_at(self, index, value):
        self.Rating.insert(index, value)
    def replace_Rating_at(self, index, value):
        self.Rating[index] = value
    def validate_String(self, value):
        result = True
        # Validate type String, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on String' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.Rating
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='RatingsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RatingsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RatingsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RatingsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RatingsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='RatingsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Rating_ in self.Rating:
            namespaceprefix_ = self.Rating_nsprefix_ + ':' if (UseCapturedNS_ and self.Rating_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRating>%s</%sRating>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(Rating_), input_name='Rating')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Rating':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Rating')
            value_ = self.gds_validate_string(value_, node, 'Rating')
            self.Rating.append(value_)
            self.Rating_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.Rating[-1])
# end class RatingsType


class CreatorsType(GeneratedsSuper):
    """Identifier, e.g. name or other id, of (technical) personnel who has
    taken the multimedia. Does not imply copyrights or other rights."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('Creator', ['String', 'xs:normalizedString'], 1, 0, {'maxOccurs': 'unbounded', 'name': 'Creator', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/MultimediaObject-CreatorURI', 'type': 'xs:normalizedString'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, Creator=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Creator is None:
            self.Creator = []
        else:
            self.Creator = Creator
        self.Creator_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CreatorsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CreatorsType.subclass:
            return CreatorsType.subclass(*args_, **kwargs_)
        else:
            return CreatorsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Creator(self):
        return self.Creator
    def set_Creator(self, Creator):
        self.Creator = Creator
    def add_Creator(self, value):
        self.Creator.append(value)
    def insert_Creator_at(self, index, value):
        self.Creator.insert(index, value)
    def replace_Creator_at(self, index, value):
        self.Creator[index] = value
    def validate_String(self, value):
        result = True
        # Validate type String, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on String' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.Creator
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='CreatorsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CreatorsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CreatorsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CreatorsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CreatorsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='CreatorsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Creator_ in self.Creator:
            namespaceprefix_ = self.Creator_nsprefix_ + ':' if (UseCapturedNS_ and self.Creator_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCreator>%s</%sCreator>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(Creator_), input_name='Creator')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Creator':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Creator')
            value_ = self.gds_validate_string(value_, node, 'Creator')
            self.Creator.append(value_)
            self.Creator_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.Creator[-1])
# end class CreatorsType


class TaxaInBackgroundType(GeneratedsSuper):
    """Other taxa recorded in background"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('TaxonInBackground', 'TaxonIdentified', 1, 0, {'maxOccurs': 'unbounded', 'name': 'TaxonInBackground', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/TaxonInBackground', 'type': 'TaxonIdentified'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, TaxonInBackground=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if TaxonInBackground is None:
            self.TaxonInBackground = []
        else:
            self.TaxonInBackground = TaxonInBackground
        self.TaxonInBackground_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TaxaInBackgroundType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TaxaInBackgroundType.subclass:
            return TaxaInBackgroundType.subclass(*args_, **kwargs_)
        else:
            return TaxaInBackgroundType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_TaxonInBackground(self):
        return self.TaxonInBackground
    def set_TaxonInBackground(self, TaxonInBackground):
        self.TaxonInBackground = TaxonInBackground
    def add_TaxonInBackground(self, value):
        self.TaxonInBackground.append(value)
    def insert_TaxonInBackground_at(self, index, value):
        self.TaxonInBackground.insert(index, value)
    def replace_TaxonInBackground_at(self, index, value):
        self.TaxonInBackground[index] = value
    def hasContent_(self):
        if (
            self.TaxonInBackground
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='TaxaInBackgroundType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TaxaInBackgroundType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TaxaInBackgroundType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TaxaInBackgroundType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TaxaInBackgroundType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='TaxaInBackgroundType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for TaxonInBackground_ in self.TaxonInBackground:
            namespaceprefix_ = self.TaxonInBackground_nsprefix_ + ':' if (UseCapturedNS_ and self.TaxonInBackground_nsprefix_) else ''
            TaxonInBackground_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TaxonInBackground', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'TaxonInBackground':
            obj_ = TaxonIdentified.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TaxonInBackground.append(obj_)
            obj_.original_tagname_ = 'TaxonInBackground'
# end class TaxaInBackgroundType


class AudioType(GeneratedsSuper):
    """Use this container for audio items."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('Microphone', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'Microphone', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/microphone', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('AudioChannel', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'AudioChannel', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/audioChannel', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('DurationTimeCode', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'DurationTimeCode', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/durationTimeCode', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('CodecName', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'CodecName', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/codecName', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('CodecQuality', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'CodecQuality', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/codecQuality', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('AudioEncoding', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'AudioEncoding', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/audioEncoding', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('SamplingRate', 'xs:double', 0, 1, {'minOccurs': '0', 'name': 'SamplingRate', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/samplingRate', 'type': 'xs:double'}, None),
        MemberSpec_('AudioBitrate', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'AudioBitrate', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/audioBitrate', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('Parabola', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'Parabola', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/parabola', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('CarrierFrequency', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'CarrierFrequency', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/carrierFrequency', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('PulseRepetitionRate', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'PulseRepetitionRate', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/pulseRepetitionRate', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('PulseLength', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'PulseLength', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/pulseLength', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('PulseFrequencyContour', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'PulseFrequencyContour', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/pulseFrequencyContour', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('PulseEnergyContour', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'PulseEnergyContour', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/pulseFrequencyContour', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('PulseTimeEncodedSignal', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'PulseTimeEncodedSignal', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/pulseTimeEncodedSignal', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('PulseMaximumAmplitude', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'PulseMaximumAmplitude', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/pulseMaximumAmplitude', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('PulseFrequencyModulations', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'PulseFrequencyModulations', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/pulseFrequencyModulations', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('PulseDistanceRegularity', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'PulseDistanceRegularity', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/pulseDistanceRegularity', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('PulseGrouping', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'PulseGrouping', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/pulseGrouping', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('Speed', 'xs:double', 0, 1, {'minOccurs': '0', 'name': 'Speed', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/speed', 'type': 'xs:double'}, None),
        MemberSpec_('Pitch', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'Pitch', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/pitch', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('Volume', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'Volume', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/volume', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('CallType', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'CallType', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/callType', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('NumberOfNotes', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'NumberOfNotes', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/numberOfNotes', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('Chapters', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'Chapters', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/chapters', 'type': 'xs:normalizedString'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, Microphone=None, AudioChannel=None, DurationTimeCode=None, CodecName=None, CodecQuality=None, AudioEncoding=None, SamplingRate=None, AudioBitrate=None, Parabola=None, CarrierFrequency=None, PulseRepetitionRate=None, PulseLength=None, PulseFrequencyContour=None, PulseEnergyContour=None, PulseTimeEncodedSignal=None, PulseMaximumAmplitude=None, PulseFrequencyModulations=None, PulseDistanceRegularity=None, PulseGrouping=None, Speed=None, Pitch=None, Volume=None, CallType=None, NumberOfNotes=None, Chapters=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Microphone = Microphone
        self.validate_String(self.Microphone)
        self.Microphone_nsprefix_ = None
        self.AudioChannel = AudioChannel
        self.validate_String(self.AudioChannel)
        self.AudioChannel_nsprefix_ = None
        self.DurationTimeCode = DurationTimeCode
        self.validate_String(self.DurationTimeCode)
        self.DurationTimeCode_nsprefix_ = None
        self.CodecName = CodecName
        self.validate_String(self.CodecName)
        self.CodecName_nsprefix_ = None
        self.CodecQuality = CodecQuality
        self.validate_String(self.CodecQuality)
        self.CodecQuality_nsprefix_ = None
        self.AudioEncoding = AudioEncoding
        self.validate_String(self.AudioEncoding)
        self.AudioEncoding_nsprefix_ = None
        self.SamplingRate = SamplingRate
        self.SamplingRate_nsprefix_ = None
        self.AudioBitrate = AudioBitrate
        self.validate_String(self.AudioBitrate)
        self.AudioBitrate_nsprefix_ = None
        self.Parabola = Parabola
        self.validate_String(self.Parabola)
        self.Parabola_nsprefix_ = None
        self.CarrierFrequency = CarrierFrequency
        self.validate_String(self.CarrierFrequency)
        self.CarrierFrequency_nsprefix_ = None
        self.PulseRepetitionRate = PulseRepetitionRate
        self.validate_String(self.PulseRepetitionRate)
        self.PulseRepetitionRate_nsprefix_ = None
        self.PulseLength = PulseLength
        self.validate_String(self.PulseLength)
        self.PulseLength_nsprefix_ = None
        self.PulseFrequencyContour = PulseFrequencyContour
        self.validate_String(self.PulseFrequencyContour)
        self.PulseFrequencyContour_nsprefix_ = None
        self.PulseEnergyContour = PulseEnergyContour
        self.validate_String(self.PulseEnergyContour)
        self.PulseEnergyContour_nsprefix_ = None
        self.PulseTimeEncodedSignal = PulseTimeEncodedSignal
        self.validate_String(self.PulseTimeEncodedSignal)
        self.PulseTimeEncodedSignal_nsprefix_ = None
        self.PulseMaximumAmplitude = PulseMaximumAmplitude
        self.validate_String(self.PulseMaximumAmplitude)
        self.PulseMaximumAmplitude_nsprefix_ = None
        self.PulseFrequencyModulations = PulseFrequencyModulations
        self.validate_String(self.PulseFrequencyModulations)
        self.PulseFrequencyModulations_nsprefix_ = None
        self.PulseDistanceRegularity = PulseDistanceRegularity
        self.validate_String(self.PulseDistanceRegularity)
        self.PulseDistanceRegularity_nsprefix_ = None
        self.PulseGrouping = PulseGrouping
        self.validate_String(self.PulseGrouping)
        self.PulseGrouping_nsprefix_ = None
        self.Speed = Speed
        self.Speed_nsprefix_ = None
        self.Pitch = Pitch
        self.validate_String(self.Pitch)
        self.Pitch_nsprefix_ = None
        self.Volume = Volume
        self.validate_String(self.Volume)
        self.Volume_nsprefix_ = None
        self.CallType = CallType
        self.validate_String(self.CallType)
        self.CallType_nsprefix_ = None
        self.NumberOfNotes = NumberOfNotes
        self.validate_String(self.NumberOfNotes)
        self.NumberOfNotes_nsprefix_ = None
        self.Chapters = Chapters
        self.validate_String(self.Chapters)
        self.Chapters_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AudioType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AudioType.subclass:
            return AudioType.subclass(*args_, **kwargs_)
        else:
            return AudioType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Microphone(self):
        return self.Microphone
    def set_Microphone(self, Microphone):
        self.Microphone = Microphone
    def get_AudioChannel(self):
        return self.AudioChannel
    def set_AudioChannel(self, AudioChannel):
        self.AudioChannel = AudioChannel
    def get_DurationTimeCode(self):
        return self.DurationTimeCode
    def set_DurationTimeCode(self, DurationTimeCode):
        self.DurationTimeCode = DurationTimeCode
    def get_CodecName(self):
        return self.CodecName
    def set_CodecName(self, CodecName):
        self.CodecName = CodecName
    def get_CodecQuality(self):
        return self.CodecQuality
    def set_CodecQuality(self, CodecQuality):
        self.CodecQuality = CodecQuality
    def get_AudioEncoding(self):
        return self.AudioEncoding
    def set_AudioEncoding(self, AudioEncoding):
        self.AudioEncoding = AudioEncoding
    def get_SamplingRate(self):
        return self.SamplingRate
    def set_SamplingRate(self, SamplingRate):
        self.SamplingRate = SamplingRate
    def get_AudioBitrate(self):
        return self.AudioBitrate
    def set_AudioBitrate(self, AudioBitrate):
        self.AudioBitrate = AudioBitrate
    def get_Parabola(self):
        return self.Parabola
    def set_Parabola(self, Parabola):
        self.Parabola = Parabola
    def get_CarrierFrequency(self):
        return self.CarrierFrequency
    def set_CarrierFrequency(self, CarrierFrequency):
        self.CarrierFrequency = CarrierFrequency
    def get_PulseRepetitionRate(self):
        return self.PulseRepetitionRate
    def set_PulseRepetitionRate(self, PulseRepetitionRate):
        self.PulseRepetitionRate = PulseRepetitionRate
    def get_PulseLength(self):
        return self.PulseLength
    def set_PulseLength(self, PulseLength):
        self.PulseLength = PulseLength
    def get_PulseFrequencyContour(self):
        return self.PulseFrequencyContour
    def set_PulseFrequencyContour(self, PulseFrequencyContour):
        self.PulseFrequencyContour = PulseFrequencyContour
    def get_PulseEnergyContour(self):
        return self.PulseEnergyContour
    def set_PulseEnergyContour(self, PulseEnergyContour):
        self.PulseEnergyContour = PulseEnergyContour
    def get_PulseTimeEncodedSignal(self):
        return self.PulseTimeEncodedSignal
    def set_PulseTimeEncodedSignal(self, PulseTimeEncodedSignal):
        self.PulseTimeEncodedSignal = PulseTimeEncodedSignal
    def get_PulseMaximumAmplitude(self):
        return self.PulseMaximumAmplitude
    def set_PulseMaximumAmplitude(self, PulseMaximumAmplitude):
        self.PulseMaximumAmplitude = PulseMaximumAmplitude
    def get_PulseFrequencyModulations(self):
        return self.PulseFrequencyModulations
    def set_PulseFrequencyModulations(self, PulseFrequencyModulations):
        self.PulseFrequencyModulations = PulseFrequencyModulations
    def get_PulseDistanceRegularity(self):
        return self.PulseDistanceRegularity
    def set_PulseDistanceRegularity(self, PulseDistanceRegularity):
        self.PulseDistanceRegularity = PulseDistanceRegularity
    def get_PulseGrouping(self):
        return self.PulseGrouping
    def set_PulseGrouping(self, PulseGrouping):
        self.PulseGrouping = PulseGrouping
    def get_Speed(self):
        return self.Speed
    def set_Speed(self, Speed):
        self.Speed = Speed
    def get_Pitch(self):
        return self.Pitch
    def set_Pitch(self, Pitch):
        self.Pitch = Pitch
    def get_Volume(self):
        return self.Volume
    def set_Volume(self, Volume):
        self.Volume = Volume
    def get_CallType(self):
        return self.CallType
    def set_CallType(self, CallType):
        self.CallType = CallType
    def get_NumberOfNotes(self):
        return self.NumberOfNotes
    def set_NumberOfNotes(self, NumberOfNotes):
        self.NumberOfNotes = NumberOfNotes
    def get_Chapters(self):
        return self.Chapters
    def set_Chapters(self, Chapters):
        self.Chapters = Chapters
    def validate_String(self, value):
        result = True
        # Validate type String, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on String' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.Microphone is not None or
            self.AudioChannel is not None or
            self.DurationTimeCode is not None or
            self.CodecName is not None or
            self.CodecQuality is not None or
            self.AudioEncoding is not None or
            self.SamplingRate is not None or
            self.AudioBitrate is not None or
            self.Parabola is not None or
            self.CarrierFrequency is not None or
            self.PulseRepetitionRate is not None or
            self.PulseLength is not None or
            self.PulseFrequencyContour is not None or
            self.PulseEnergyContour is not None or
            self.PulseTimeEncodedSignal is not None or
            self.PulseMaximumAmplitude is not None or
            self.PulseFrequencyModulations is not None or
            self.PulseDistanceRegularity is not None or
            self.PulseGrouping is not None or
            self.Speed is not None or
            self.Pitch is not None or
            self.Volume is not None or
            self.CallType is not None or
            self.NumberOfNotes is not None or
            self.Chapters is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='AudioType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AudioType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AudioType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AudioType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AudioType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='AudioType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Microphone is not None:
            namespaceprefix_ = self.Microphone_nsprefix_ + ':' if (UseCapturedNS_ and self.Microphone_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMicrophone>%s</%sMicrophone>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Microphone), input_name='Microphone')), namespaceprefix_ , eol_))
        if self.AudioChannel is not None:
            namespaceprefix_ = self.AudioChannel_nsprefix_ + ':' if (UseCapturedNS_ and self.AudioChannel_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAudioChannel>%s</%sAudioChannel>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.AudioChannel), input_name='AudioChannel')), namespaceprefix_ , eol_))
        if self.DurationTimeCode is not None:
            namespaceprefix_ = self.DurationTimeCode_nsprefix_ + ':' if (UseCapturedNS_ and self.DurationTimeCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDurationTimeCode>%s</%sDurationTimeCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DurationTimeCode), input_name='DurationTimeCode')), namespaceprefix_ , eol_))
        if self.CodecName is not None:
            namespaceprefix_ = self.CodecName_nsprefix_ + ':' if (UseCapturedNS_ and self.CodecName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCodecName>%s</%sCodecName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CodecName), input_name='CodecName')), namespaceprefix_ , eol_))
        if self.CodecQuality is not None:
            namespaceprefix_ = self.CodecQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.CodecQuality_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCodecQuality>%s</%sCodecQuality>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CodecQuality), input_name='CodecQuality')), namespaceprefix_ , eol_))
        if self.AudioEncoding is not None:
            namespaceprefix_ = self.AudioEncoding_nsprefix_ + ':' if (UseCapturedNS_ and self.AudioEncoding_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAudioEncoding>%s</%sAudioEncoding>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.AudioEncoding), input_name='AudioEncoding')), namespaceprefix_ , eol_))
        if self.SamplingRate is not None:
            namespaceprefix_ = self.SamplingRate_nsprefix_ + ':' if (UseCapturedNS_ and self.SamplingRate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSamplingRate>%s</%sSamplingRate>%s' % (namespaceprefix_ , self.gds_format_double(self.SamplingRate, input_name='SamplingRate'), namespaceprefix_ , eol_))
        if self.AudioBitrate is not None:
            namespaceprefix_ = self.AudioBitrate_nsprefix_ + ':' if (UseCapturedNS_ and self.AudioBitrate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAudioBitrate>%s</%sAudioBitrate>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.AudioBitrate), input_name='AudioBitrate')), namespaceprefix_ , eol_))
        if self.Parabola is not None:
            namespaceprefix_ = self.Parabola_nsprefix_ + ':' if (UseCapturedNS_ and self.Parabola_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sParabola>%s</%sParabola>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Parabola), input_name='Parabola')), namespaceprefix_ , eol_))
        if self.CarrierFrequency is not None:
            namespaceprefix_ = self.CarrierFrequency_nsprefix_ + ':' if (UseCapturedNS_ and self.CarrierFrequency_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCarrierFrequency>%s</%sCarrierFrequency>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CarrierFrequency), input_name='CarrierFrequency')), namespaceprefix_ , eol_))
        if self.PulseRepetitionRate is not None:
            namespaceprefix_ = self.PulseRepetitionRate_nsprefix_ + ':' if (UseCapturedNS_ and self.PulseRepetitionRate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPulseRepetitionRate>%s</%sPulseRepetitionRate>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PulseRepetitionRate), input_name='PulseRepetitionRate')), namespaceprefix_ , eol_))
        if self.PulseLength is not None:
            namespaceprefix_ = self.PulseLength_nsprefix_ + ':' if (UseCapturedNS_ and self.PulseLength_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPulseLength>%s</%sPulseLength>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PulseLength), input_name='PulseLength')), namespaceprefix_ , eol_))
        if self.PulseFrequencyContour is not None:
            namespaceprefix_ = self.PulseFrequencyContour_nsprefix_ + ':' if (UseCapturedNS_ and self.PulseFrequencyContour_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPulseFrequencyContour>%s</%sPulseFrequencyContour>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PulseFrequencyContour), input_name='PulseFrequencyContour')), namespaceprefix_ , eol_))
        if self.PulseEnergyContour is not None:
            namespaceprefix_ = self.PulseEnergyContour_nsprefix_ + ':' if (UseCapturedNS_ and self.PulseEnergyContour_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPulseEnergyContour>%s</%sPulseEnergyContour>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PulseEnergyContour), input_name='PulseEnergyContour')), namespaceprefix_ , eol_))
        if self.PulseTimeEncodedSignal is not None:
            namespaceprefix_ = self.PulseTimeEncodedSignal_nsprefix_ + ':' if (UseCapturedNS_ and self.PulseTimeEncodedSignal_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPulseTimeEncodedSignal>%s</%sPulseTimeEncodedSignal>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PulseTimeEncodedSignal), input_name='PulseTimeEncodedSignal')), namespaceprefix_ , eol_))
        if self.PulseMaximumAmplitude is not None:
            namespaceprefix_ = self.PulseMaximumAmplitude_nsprefix_ + ':' if (UseCapturedNS_ and self.PulseMaximumAmplitude_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPulseMaximumAmplitude>%s</%sPulseMaximumAmplitude>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PulseMaximumAmplitude), input_name='PulseMaximumAmplitude')), namespaceprefix_ , eol_))
        if self.PulseFrequencyModulations is not None:
            namespaceprefix_ = self.PulseFrequencyModulations_nsprefix_ + ':' if (UseCapturedNS_ and self.PulseFrequencyModulations_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPulseFrequencyModulations>%s</%sPulseFrequencyModulations>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PulseFrequencyModulations), input_name='PulseFrequencyModulations')), namespaceprefix_ , eol_))
        if self.PulseDistanceRegularity is not None:
            namespaceprefix_ = self.PulseDistanceRegularity_nsprefix_ + ':' if (UseCapturedNS_ and self.PulseDistanceRegularity_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPulseDistanceRegularity>%s</%sPulseDistanceRegularity>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PulseDistanceRegularity), input_name='PulseDistanceRegularity')), namespaceprefix_ , eol_))
        if self.PulseGrouping is not None:
            namespaceprefix_ = self.PulseGrouping_nsprefix_ + ':' if (UseCapturedNS_ and self.PulseGrouping_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPulseGrouping>%s</%sPulseGrouping>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PulseGrouping), input_name='PulseGrouping')), namespaceprefix_ , eol_))
        if self.Speed is not None:
            namespaceprefix_ = self.Speed_nsprefix_ + ':' if (UseCapturedNS_ and self.Speed_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSpeed>%s</%sSpeed>%s' % (namespaceprefix_ , self.gds_format_double(self.Speed, input_name='Speed'), namespaceprefix_ , eol_))
        if self.Pitch is not None:
            namespaceprefix_ = self.Pitch_nsprefix_ + ':' if (UseCapturedNS_ and self.Pitch_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPitch>%s</%sPitch>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Pitch), input_name='Pitch')), namespaceprefix_ , eol_))
        if self.Volume is not None:
            namespaceprefix_ = self.Volume_nsprefix_ + ':' if (UseCapturedNS_ and self.Volume_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVolume>%s</%sVolume>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Volume), input_name='Volume')), namespaceprefix_ , eol_))
        if self.CallType is not None:
            namespaceprefix_ = self.CallType_nsprefix_ + ':' if (UseCapturedNS_ and self.CallType_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCallType>%s</%sCallType>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CallType), input_name='CallType')), namespaceprefix_ , eol_))
        if self.NumberOfNotes is not None:
            namespaceprefix_ = self.NumberOfNotes_nsprefix_ + ':' if (UseCapturedNS_ and self.NumberOfNotes_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNumberOfNotes>%s</%sNumberOfNotes>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NumberOfNotes), input_name='NumberOfNotes')), namespaceprefix_ , eol_))
        if self.Chapters is not None:
            namespaceprefix_ = self.Chapters_nsprefix_ + ':' if (UseCapturedNS_ and self.Chapters_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sChapters>%s</%sChapters>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Chapters), input_name='Chapters')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Microphone':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Microphone')
            value_ = self.gds_validate_string(value_, node, 'Microphone')
            self.Microphone = value_
            self.Microphone_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.Microphone)
        elif nodeName_ == 'AudioChannel':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'AudioChannel')
            value_ = self.gds_validate_string(value_, node, 'AudioChannel')
            self.AudioChannel = value_
            self.AudioChannel_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.AudioChannel)
        elif nodeName_ == 'DurationTimeCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DurationTimeCode')
            value_ = self.gds_validate_string(value_, node, 'DurationTimeCode')
            self.DurationTimeCode = value_
            self.DurationTimeCode_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.DurationTimeCode)
        elif nodeName_ == 'CodecName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CodecName')
            value_ = self.gds_validate_string(value_, node, 'CodecName')
            self.CodecName = value_
            self.CodecName_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.CodecName)
        elif nodeName_ == 'CodecQuality':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CodecQuality')
            value_ = self.gds_validate_string(value_, node, 'CodecQuality')
            self.CodecQuality = value_
            self.CodecQuality_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.CodecQuality)
        elif nodeName_ == 'AudioEncoding':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'AudioEncoding')
            value_ = self.gds_validate_string(value_, node, 'AudioEncoding')
            self.AudioEncoding = value_
            self.AudioEncoding_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.AudioEncoding)
        elif nodeName_ == 'SamplingRate' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_double(sval_, node, 'SamplingRate')
            fval_ = self.gds_validate_double(fval_, node, 'SamplingRate')
            self.SamplingRate = fval_
            self.SamplingRate_nsprefix_ = child_.prefix
        elif nodeName_ == 'AudioBitrate':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'AudioBitrate')
            value_ = self.gds_validate_string(value_, node, 'AudioBitrate')
            self.AudioBitrate = value_
            self.AudioBitrate_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.AudioBitrate)
        elif nodeName_ == 'Parabola':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Parabola')
            value_ = self.gds_validate_string(value_, node, 'Parabola')
            self.Parabola = value_
            self.Parabola_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.Parabola)
        elif nodeName_ == 'CarrierFrequency':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CarrierFrequency')
            value_ = self.gds_validate_string(value_, node, 'CarrierFrequency')
            self.CarrierFrequency = value_
            self.CarrierFrequency_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.CarrierFrequency)
        elif nodeName_ == 'PulseRepetitionRate':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PulseRepetitionRate')
            value_ = self.gds_validate_string(value_, node, 'PulseRepetitionRate')
            self.PulseRepetitionRate = value_
            self.PulseRepetitionRate_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.PulseRepetitionRate)
        elif nodeName_ == 'PulseLength':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PulseLength')
            value_ = self.gds_validate_string(value_, node, 'PulseLength')
            self.PulseLength = value_
            self.PulseLength_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.PulseLength)
        elif nodeName_ == 'PulseFrequencyContour':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PulseFrequencyContour')
            value_ = self.gds_validate_string(value_, node, 'PulseFrequencyContour')
            self.PulseFrequencyContour = value_
            self.PulseFrequencyContour_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.PulseFrequencyContour)
        elif nodeName_ == 'PulseEnergyContour':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PulseEnergyContour')
            value_ = self.gds_validate_string(value_, node, 'PulseEnergyContour')
            self.PulseEnergyContour = value_
            self.PulseEnergyContour_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.PulseEnergyContour)
        elif nodeName_ == 'PulseTimeEncodedSignal':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PulseTimeEncodedSignal')
            value_ = self.gds_validate_string(value_, node, 'PulseTimeEncodedSignal')
            self.PulseTimeEncodedSignal = value_
            self.PulseTimeEncodedSignal_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.PulseTimeEncodedSignal)
        elif nodeName_ == 'PulseMaximumAmplitude':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PulseMaximumAmplitude')
            value_ = self.gds_validate_string(value_, node, 'PulseMaximumAmplitude')
            self.PulseMaximumAmplitude = value_
            self.PulseMaximumAmplitude_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.PulseMaximumAmplitude)
        elif nodeName_ == 'PulseFrequencyModulations':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PulseFrequencyModulations')
            value_ = self.gds_validate_string(value_, node, 'PulseFrequencyModulations')
            self.PulseFrequencyModulations = value_
            self.PulseFrequencyModulations_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.PulseFrequencyModulations)
        elif nodeName_ == 'PulseDistanceRegularity':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PulseDistanceRegularity')
            value_ = self.gds_validate_string(value_, node, 'PulseDistanceRegularity')
            self.PulseDistanceRegularity = value_
            self.PulseDistanceRegularity_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.PulseDistanceRegularity)
        elif nodeName_ == 'PulseGrouping':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PulseGrouping')
            value_ = self.gds_validate_string(value_, node, 'PulseGrouping')
            self.PulseGrouping = value_
            self.PulseGrouping_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.PulseGrouping)
        elif nodeName_ == 'Speed' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_double(sval_, node, 'Speed')
            fval_ = self.gds_validate_double(fval_, node, 'Speed')
            self.Speed = fval_
            self.Speed_nsprefix_ = child_.prefix
        elif nodeName_ == 'Pitch':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Pitch')
            value_ = self.gds_validate_string(value_, node, 'Pitch')
            self.Pitch = value_
            self.Pitch_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.Pitch)
        elif nodeName_ == 'Volume':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Volume')
            value_ = self.gds_validate_string(value_, node, 'Volume')
            self.Volume = value_
            self.Volume_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.Volume)
        elif nodeName_ == 'CallType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CallType')
            value_ = self.gds_validate_string(value_, node, 'CallType')
            self.CallType = value_
            self.CallType_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.CallType)
        elif nodeName_ == 'NumberOfNotes':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NumberOfNotes')
            value_ = self.gds_validate_string(value_, node, 'NumberOfNotes')
            self.NumberOfNotes = value_
            self.NumberOfNotes_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.NumberOfNotes)
        elif nodeName_ == 'Chapters':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Chapters')
            value_ = self.gds_validate_string(value_, node, 'Chapters')
            self.Chapters = value_
            self.Chapters_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.Chapters)
# end class AudioType


class VideoType(GeneratedsSuper):
    """Use this container for video items."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('Microphone', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'Microphone', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/microphone', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('LensModel', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'LensModel', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/lensModel', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('LightSource', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'LightSource', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/lightSource', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('AudioChannel', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'AudioChannel', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/audioChannel', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('DurationTimeCode', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'DurationTimeCode', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/durationTimeCode', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('AudioEncoding', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'AudioEncoding', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/audioEncoding', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('AudioBitrate', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'AudioBitrate', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/audioBitrate', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('AspectRatio', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'AspectRatio', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/aspectRatio', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('VideoEncoding', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'VideoEncoding', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/videoEncoding', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('VideoBitrate', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'VideoBitrate', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/videoBitrate', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('Framerate', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'Framerate', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/frameRate', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('CaptureFramerate', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'CaptureFramerate', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/captureFramerate', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('Color', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'Color', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/color', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('ThumbnailURL', 'xs:anyURI', 0, 1, {'minOccurs': '0', 'name': 'ThumbnailURL', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/thumbnailURL', 'type': 'xs:anyURI'}, None),
        MemberSpec_('ImageSize', 'imageSize', 0, 1, {'minOccurs': '0', 'name': 'ImageSize', 'type': 'imageSize'}, None),
        MemberSpec_('CallType', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'CallType', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/callType', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('NumberOfNotes', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'NumberOfNotes', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/numberOfNotes', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('Subtitles', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'Subtitles', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/subtitles', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('SubtitlesFormat', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'SubtitlesFormat', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/subtitlesFormat', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('Chapters', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'Chapters', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/chapters', 'type': 'xs:normalizedString'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, Microphone=None, LensModel=None, LightSource=None, AudioChannel=None, DurationTimeCode=None, AudioEncoding=None, AudioBitrate=None, AspectRatio=None, VideoEncoding=None, VideoBitrate=None, Framerate=None, CaptureFramerate=None, Color=None, ThumbnailURL=None, ImageSize=None, CallType=None, NumberOfNotes=None, Subtitles=None, SubtitlesFormat=None, Chapters=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Microphone = Microphone
        self.validate_String(self.Microphone)
        self.Microphone_nsprefix_ = None
        self.LensModel = LensModel
        self.validate_String(self.LensModel)
        self.LensModel_nsprefix_ = None
        self.LightSource = LightSource
        self.validate_String(self.LightSource)
        self.LightSource_nsprefix_ = None
        self.AudioChannel = AudioChannel
        self.validate_String(self.AudioChannel)
        self.AudioChannel_nsprefix_ = None
        self.DurationTimeCode = DurationTimeCode
        self.validate_String(self.DurationTimeCode)
        self.DurationTimeCode_nsprefix_ = None
        self.AudioEncoding = AudioEncoding
        self.validate_String(self.AudioEncoding)
        self.AudioEncoding_nsprefix_ = None
        self.AudioBitrate = AudioBitrate
        self.validate_String(self.AudioBitrate)
        self.AudioBitrate_nsprefix_ = None
        self.AspectRatio = AspectRatio
        self.validate_String(self.AspectRatio)
        self.AspectRatio_nsprefix_ = None
        self.VideoEncoding = VideoEncoding
        self.validate_String(self.VideoEncoding)
        self.VideoEncoding_nsprefix_ = None
        self.VideoBitrate = VideoBitrate
        self.validate_String(self.VideoBitrate)
        self.VideoBitrate_nsprefix_ = None
        self.Framerate = Framerate
        self.validate_String(self.Framerate)
        self.Framerate_nsprefix_ = None
        self.CaptureFramerate = CaptureFramerate
        self.validate_String(self.CaptureFramerate)
        self.CaptureFramerate_nsprefix_ = None
        self.Color = Color
        self.validate_String(self.Color)
        self.Color_nsprefix_ = None
        self.ThumbnailURL = ThumbnailURL
        self.ThumbnailURL_nsprefix_ = None
        self.ImageSize = ImageSize
        self.ImageSize_nsprefix_ = None
        self.CallType = CallType
        self.validate_String(self.CallType)
        self.CallType_nsprefix_ = None
        self.NumberOfNotes = NumberOfNotes
        self.validate_String(self.NumberOfNotes)
        self.NumberOfNotes_nsprefix_ = None
        self.Subtitles = Subtitles
        self.validate_String(self.Subtitles)
        self.Subtitles_nsprefix_ = None
        self.SubtitlesFormat = SubtitlesFormat
        self.validate_String(self.SubtitlesFormat)
        self.SubtitlesFormat_nsprefix_ = None
        self.Chapters = Chapters
        self.validate_String(self.Chapters)
        self.Chapters_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VideoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VideoType.subclass:
            return VideoType.subclass(*args_, **kwargs_)
        else:
            return VideoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Microphone(self):
        return self.Microphone
    def set_Microphone(self, Microphone):
        self.Microphone = Microphone
    def get_LensModel(self):
        return self.LensModel
    def set_LensModel(self, LensModel):
        self.LensModel = LensModel
    def get_LightSource(self):
        return self.LightSource
    def set_LightSource(self, LightSource):
        self.LightSource = LightSource
    def get_AudioChannel(self):
        return self.AudioChannel
    def set_AudioChannel(self, AudioChannel):
        self.AudioChannel = AudioChannel
    def get_DurationTimeCode(self):
        return self.DurationTimeCode
    def set_DurationTimeCode(self, DurationTimeCode):
        self.DurationTimeCode = DurationTimeCode
    def get_AudioEncoding(self):
        return self.AudioEncoding
    def set_AudioEncoding(self, AudioEncoding):
        self.AudioEncoding = AudioEncoding
    def get_AudioBitrate(self):
        return self.AudioBitrate
    def set_AudioBitrate(self, AudioBitrate):
        self.AudioBitrate = AudioBitrate
    def get_AspectRatio(self):
        return self.AspectRatio
    def set_AspectRatio(self, AspectRatio):
        self.AspectRatio = AspectRatio
    def get_VideoEncoding(self):
        return self.VideoEncoding
    def set_VideoEncoding(self, VideoEncoding):
        self.VideoEncoding = VideoEncoding
    def get_VideoBitrate(self):
        return self.VideoBitrate
    def set_VideoBitrate(self, VideoBitrate):
        self.VideoBitrate = VideoBitrate
    def get_Framerate(self):
        return self.Framerate
    def set_Framerate(self, Framerate):
        self.Framerate = Framerate
    def get_CaptureFramerate(self):
        return self.CaptureFramerate
    def set_CaptureFramerate(self, CaptureFramerate):
        self.CaptureFramerate = CaptureFramerate
    def get_Color(self):
        return self.Color
    def set_Color(self, Color):
        self.Color = Color
    def get_ThumbnailURL(self):
        return self.ThumbnailURL
    def set_ThumbnailURL(self, ThumbnailURL):
        self.ThumbnailURL = ThumbnailURL
    def get_ImageSize(self):
        return self.ImageSize
    def set_ImageSize(self, ImageSize):
        self.ImageSize = ImageSize
    def get_CallType(self):
        return self.CallType
    def set_CallType(self, CallType):
        self.CallType = CallType
    def get_NumberOfNotes(self):
        return self.NumberOfNotes
    def set_NumberOfNotes(self, NumberOfNotes):
        self.NumberOfNotes = NumberOfNotes
    def get_Subtitles(self):
        return self.Subtitles
    def set_Subtitles(self, Subtitles):
        self.Subtitles = Subtitles
    def get_SubtitlesFormat(self):
        return self.SubtitlesFormat
    def set_SubtitlesFormat(self, SubtitlesFormat):
        self.SubtitlesFormat = SubtitlesFormat
    def get_Chapters(self):
        return self.Chapters
    def set_Chapters(self, Chapters):
        self.Chapters = Chapters
    def validate_String(self, value):
        result = True
        # Validate type String, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on String' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.Microphone is not None or
            self.LensModel is not None or
            self.LightSource is not None or
            self.AudioChannel is not None or
            self.DurationTimeCode is not None or
            self.AudioEncoding is not None or
            self.AudioBitrate is not None or
            self.AspectRatio is not None or
            self.VideoEncoding is not None or
            self.VideoBitrate is not None or
            self.Framerate is not None or
            self.CaptureFramerate is not None or
            self.Color is not None or
            self.ThumbnailURL is not None or
            self.ImageSize is not None or
            self.CallType is not None or
            self.NumberOfNotes is not None or
            self.Subtitles is not None or
            self.SubtitlesFormat is not None or
            self.Chapters is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='VideoType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VideoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VideoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VideoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VideoType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='VideoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Microphone is not None:
            namespaceprefix_ = self.Microphone_nsprefix_ + ':' if (UseCapturedNS_ and self.Microphone_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMicrophone>%s</%sMicrophone>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Microphone), input_name='Microphone')), namespaceprefix_ , eol_))
        if self.LensModel is not None:
            namespaceprefix_ = self.LensModel_nsprefix_ + ':' if (UseCapturedNS_ and self.LensModel_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLensModel>%s</%sLensModel>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.LensModel), input_name='LensModel')), namespaceprefix_ , eol_))
        if self.LightSource is not None:
            namespaceprefix_ = self.LightSource_nsprefix_ + ':' if (UseCapturedNS_ and self.LightSource_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLightSource>%s</%sLightSource>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.LightSource), input_name='LightSource')), namespaceprefix_ , eol_))
        if self.AudioChannel is not None:
            namespaceprefix_ = self.AudioChannel_nsprefix_ + ':' if (UseCapturedNS_ and self.AudioChannel_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAudioChannel>%s</%sAudioChannel>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.AudioChannel), input_name='AudioChannel')), namespaceprefix_ , eol_))
        if self.DurationTimeCode is not None:
            namespaceprefix_ = self.DurationTimeCode_nsprefix_ + ':' if (UseCapturedNS_ and self.DurationTimeCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDurationTimeCode>%s</%sDurationTimeCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DurationTimeCode), input_name='DurationTimeCode')), namespaceprefix_ , eol_))
        if self.AudioEncoding is not None:
            namespaceprefix_ = self.AudioEncoding_nsprefix_ + ':' if (UseCapturedNS_ and self.AudioEncoding_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAudioEncoding>%s</%sAudioEncoding>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.AudioEncoding), input_name='AudioEncoding')), namespaceprefix_ , eol_))
        if self.AudioBitrate is not None:
            namespaceprefix_ = self.AudioBitrate_nsprefix_ + ':' if (UseCapturedNS_ and self.AudioBitrate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAudioBitrate>%s</%sAudioBitrate>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.AudioBitrate), input_name='AudioBitrate')), namespaceprefix_ , eol_))
        if self.AspectRatio is not None:
            namespaceprefix_ = self.AspectRatio_nsprefix_ + ':' if (UseCapturedNS_ and self.AspectRatio_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAspectRatio>%s</%sAspectRatio>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.AspectRatio), input_name='AspectRatio')), namespaceprefix_ , eol_))
        if self.VideoEncoding is not None:
            namespaceprefix_ = self.VideoEncoding_nsprefix_ + ':' if (UseCapturedNS_ and self.VideoEncoding_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVideoEncoding>%s</%sVideoEncoding>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.VideoEncoding), input_name='VideoEncoding')), namespaceprefix_ , eol_))
        if self.VideoBitrate is not None:
            namespaceprefix_ = self.VideoBitrate_nsprefix_ + ':' if (UseCapturedNS_ and self.VideoBitrate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVideoBitrate>%s</%sVideoBitrate>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.VideoBitrate), input_name='VideoBitrate')), namespaceprefix_ , eol_))
        if self.Framerate is not None:
            namespaceprefix_ = self.Framerate_nsprefix_ + ':' if (UseCapturedNS_ and self.Framerate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFramerate>%s</%sFramerate>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Framerate), input_name='Framerate')), namespaceprefix_ , eol_))
        if self.CaptureFramerate is not None:
            namespaceprefix_ = self.CaptureFramerate_nsprefix_ + ':' if (UseCapturedNS_ and self.CaptureFramerate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCaptureFramerate>%s</%sCaptureFramerate>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CaptureFramerate), input_name='CaptureFramerate')), namespaceprefix_ , eol_))
        if self.Color is not None:
            namespaceprefix_ = self.Color_nsprefix_ + ':' if (UseCapturedNS_ and self.Color_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sColor>%s</%sColor>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Color), input_name='Color')), namespaceprefix_ , eol_))
        if self.ThumbnailURL is not None:
            namespaceprefix_ = self.ThumbnailURL_nsprefix_ + ':' if (UseCapturedNS_ and self.ThumbnailURL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sThumbnailURL>%s</%sThumbnailURL>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ThumbnailURL), input_name='ThumbnailURL')), namespaceprefix_ , eol_))
        if self.ImageSize is not None:
            namespaceprefix_ = self.ImageSize_nsprefix_ + ':' if (UseCapturedNS_ and self.ImageSize_nsprefix_) else ''
            self.ImageSize.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ImageSize', pretty_print=pretty_print)
        if self.CallType is not None:
            namespaceprefix_ = self.CallType_nsprefix_ + ':' if (UseCapturedNS_ and self.CallType_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCallType>%s</%sCallType>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CallType), input_name='CallType')), namespaceprefix_ , eol_))
        if self.NumberOfNotes is not None:
            namespaceprefix_ = self.NumberOfNotes_nsprefix_ + ':' if (UseCapturedNS_ and self.NumberOfNotes_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNumberOfNotes>%s</%sNumberOfNotes>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NumberOfNotes), input_name='NumberOfNotes')), namespaceprefix_ , eol_))
        if self.Subtitles is not None:
            namespaceprefix_ = self.Subtitles_nsprefix_ + ':' if (UseCapturedNS_ and self.Subtitles_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSubtitles>%s</%sSubtitles>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Subtitles), input_name='Subtitles')), namespaceprefix_ , eol_))
        if self.SubtitlesFormat is not None:
            namespaceprefix_ = self.SubtitlesFormat_nsprefix_ + ':' if (UseCapturedNS_ and self.SubtitlesFormat_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSubtitlesFormat>%s</%sSubtitlesFormat>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SubtitlesFormat), input_name='SubtitlesFormat')), namespaceprefix_ , eol_))
        if self.Chapters is not None:
            namespaceprefix_ = self.Chapters_nsprefix_ + ':' if (UseCapturedNS_ and self.Chapters_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sChapters>%s</%sChapters>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Chapters), input_name='Chapters')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Microphone':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Microphone')
            value_ = self.gds_validate_string(value_, node, 'Microphone')
            self.Microphone = value_
            self.Microphone_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.Microphone)
        elif nodeName_ == 'LensModel':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'LensModel')
            value_ = self.gds_validate_string(value_, node, 'LensModel')
            self.LensModel = value_
            self.LensModel_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.LensModel)
        elif nodeName_ == 'LightSource':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'LightSource')
            value_ = self.gds_validate_string(value_, node, 'LightSource')
            self.LightSource = value_
            self.LightSource_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.LightSource)
        elif nodeName_ == 'AudioChannel':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'AudioChannel')
            value_ = self.gds_validate_string(value_, node, 'AudioChannel')
            self.AudioChannel = value_
            self.AudioChannel_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.AudioChannel)
        elif nodeName_ == 'DurationTimeCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DurationTimeCode')
            value_ = self.gds_validate_string(value_, node, 'DurationTimeCode')
            self.DurationTimeCode = value_
            self.DurationTimeCode_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.DurationTimeCode)
        elif nodeName_ == 'AudioEncoding':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'AudioEncoding')
            value_ = self.gds_validate_string(value_, node, 'AudioEncoding')
            self.AudioEncoding = value_
            self.AudioEncoding_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.AudioEncoding)
        elif nodeName_ == 'AudioBitrate':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'AudioBitrate')
            value_ = self.gds_validate_string(value_, node, 'AudioBitrate')
            self.AudioBitrate = value_
            self.AudioBitrate_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.AudioBitrate)
        elif nodeName_ == 'AspectRatio':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'AspectRatio')
            value_ = self.gds_validate_string(value_, node, 'AspectRatio')
            self.AspectRatio = value_
            self.AspectRatio_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.AspectRatio)
        elif nodeName_ == 'VideoEncoding':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'VideoEncoding')
            value_ = self.gds_validate_string(value_, node, 'VideoEncoding')
            self.VideoEncoding = value_
            self.VideoEncoding_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.VideoEncoding)
        elif nodeName_ == 'VideoBitrate':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'VideoBitrate')
            value_ = self.gds_validate_string(value_, node, 'VideoBitrate')
            self.VideoBitrate = value_
            self.VideoBitrate_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.VideoBitrate)
        elif nodeName_ == 'Framerate':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Framerate')
            value_ = self.gds_validate_string(value_, node, 'Framerate')
            self.Framerate = value_
            self.Framerate_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.Framerate)
        elif nodeName_ == 'CaptureFramerate':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CaptureFramerate')
            value_ = self.gds_validate_string(value_, node, 'CaptureFramerate')
            self.CaptureFramerate = value_
            self.CaptureFramerate_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.CaptureFramerate)
        elif nodeName_ == 'Color':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Color')
            value_ = self.gds_validate_string(value_, node, 'Color')
            self.Color = value_
            self.Color_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.Color)
        elif nodeName_ == 'ThumbnailURL':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ThumbnailURL')
            value_ = self.gds_validate_string(value_, node, 'ThumbnailURL')
            self.ThumbnailURL = value_
            self.ThumbnailURL_nsprefix_ = child_.prefix
        elif nodeName_ == 'ImageSize':
            obj_ = imageSize.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ImageSize = obj_
            obj_.original_tagname_ = 'ImageSize'
        elif nodeName_ == 'CallType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CallType')
            value_ = self.gds_validate_string(value_, node, 'CallType')
            self.CallType = value_
            self.CallType_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.CallType)
        elif nodeName_ == 'NumberOfNotes':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NumberOfNotes')
            value_ = self.gds_validate_string(value_, node, 'NumberOfNotes')
            self.NumberOfNotes = value_
            self.NumberOfNotes_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.NumberOfNotes)
        elif nodeName_ == 'Subtitles':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Subtitles')
            value_ = self.gds_validate_string(value_, node, 'Subtitles')
            self.Subtitles = value_
            self.Subtitles_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.Subtitles)
        elif nodeName_ == 'SubtitlesFormat':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SubtitlesFormat')
            value_ = self.gds_validate_string(value_, node, 'SubtitlesFormat')
            self.SubtitlesFormat = value_
            self.SubtitlesFormat_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.SubtitlesFormat)
        elif nodeName_ == 'Chapters':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Chapters')
            value_ = self.gds_validate_string(value_, node, 'Chapters')
            self.Chapters = value_
            self.Chapters_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.Chapters)
# end class VideoType


class ImageType(GeneratedsSuper):
    """Use this container for image records."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('LensModel', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'LensModel', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/lensModel', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('FNumber', 'xs:double', 0, 1, {'minOccurs': '0', 'name': 'FNumber', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/fNumber', 'type': 'xs:double'}, None),
        MemberSpec_('FocalLength', 'xs:double', 0, 1, {'minOccurs': '0', 'name': 'FocalLength', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/focalLength', 'type': 'xs:double'}, None),
        MemberSpec_('FocalLengthIn35mmFilm', 'xs:double', 0, 1, {'minOccurs': '0', 'name': 'FocalLengthIn35mmFilm', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/focalLengthIn35mmFilm', 'type': 'xs:double'}, None),
        MemberSpec_('LightSource', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'LightSource', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/lightSource', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('Flash', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'Flash', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/flash', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('FlashEnergy', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'FlashEnergy', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/flashEnergy', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('WhiteBalance', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'WhiteBalance', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/whiteBalance', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('DigitalZoomRatio', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'DigitalZoomRatio', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/digitalZoomRatio', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('Contrast', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'Contrast', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/contrast', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('Saturation', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'Saturation', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/saturation', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('Sharpness', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'Sharpness', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/sharpness', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('Gamma', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'Gamma', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/gamma', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('ColorSpace', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'ColorSpace', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/colorSpace', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('ImageSize', 'imageSize', 0, 1, {'minOccurs': '0', 'name': 'ImageSize', 'type': 'imageSize'}, None),
        MemberSpec_('ImageResolution', 'xs:int', 0, 1, {'minOccurs': '0', 'name': 'ImageResolution', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/imageResolution', 'type': 'xs:int'}, None),
        MemberSpec_('ExposureTime', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'ExposureTime', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/exposureTime', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('ExposureMode', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'ExposureMode', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/exposureMode', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('SpectralSensitivity', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'SpectralSensitivity', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/spectralSensitivity', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('PhotographicSensitivity', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'PhotographicSensitivity', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/photographicSensitivity', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('ISOSpeed', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'ISOSpeed', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/isoSpeed', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('ShutterSpeed', 'xs:integer', 0, 1, {'minOccurs': '0', 'name': 'ShutterSpeed', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/shutterSpeed', 'type': 'xs:integer'}, None),
        MemberSpec_('Brightness', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'Brightness', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/brightness', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('Color', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'Color', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/color', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('ThumbnailURL', 'xs:anyURI', 0, 1, {'minOccurs': '0', 'name': 'ThumbnailURL', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/thumbnailURL', 'type': 'xs:anyURI'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, LensModel=None, FNumber=None, FocalLength=None, FocalLengthIn35mmFilm=None, LightSource=None, Flash=None, FlashEnergy=None, WhiteBalance=None, DigitalZoomRatio=None, Contrast=None, Saturation=None, Sharpness=None, Gamma=None, ColorSpace=None, ImageSize=None, ImageResolution=None, ExposureTime=None, ExposureMode=None, SpectralSensitivity=None, PhotographicSensitivity=None, ISOSpeed=None, ShutterSpeed=None, Brightness=None, Color=None, ThumbnailURL=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.LensModel = LensModel
        self.validate_String(self.LensModel)
        self.LensModel_nsprefix_ = None
        self.FNumber = FNumber
        self.FNumber_nsprefix_ = None
        self.FocalLength = FocalLength
        self.FocalLength_nsprefix_ = None
        self.FocalLengthIn35mmFilm = FocalLengthIn35mmFilm
        self.FocalLengthIn35mmFilm_nsprefix_ = None
        self.LightSource = LightSource
        self.validate_String(self.LightSource)
        self.LightSource_nsprefix_ = None
        self.Flash = Flash
        self.validate_String(self.Flash)
        self.Flash_nsprefix_ = None
        self.FlashEnergy = FlashEnergy
        self.validate_String(self.FlashEnergy)
        self.FlashEnergy_nsprefix_ = None
        self.WhiteBalance = WhiteBalance
        self.validate_String(self.WhiteBalance)
        self.WhiteBalance_nsprefix_ = None
        self.DigitalZoomRatio = DigitalZoomRatio
        self.validate_String(self.DigitalZoomRatio)
        self.DigitalZoomRatio_nsprefix_ = None
        self.Contrast = Contrast
        self.validate_String(self.Contrast)
        self.Contrast_nsprefix_ = None
        self.Saturation = Saturation
        self.validate_String(self.Saturation)
        self.Saturation_nsprefix_ = None
        self.Sharpness = Sharpness
        self.validate_String(self.Sharpness)
        self.Sharpness_nsprefix_ = None
        self.Gamma = Gamma
        self.validate_String(self.Gamma)
        self.Gamma_nsprefix_ = None
        self.ColorSpace = ColorSpace
        self.validate_String(self.ColorSpace)
        self.ColorSpace_nsprefix_ = None
        self.ImageSize = ImageSize
        self.ImageSize_nsprefix_ = None
        self.ImageResolution = ImageResolution
        self.ImageResolution_nsprefix_ = None
        self.ExposureTime = ExposureTime
        self.validate_String(self.ExposureTime)
        self.ExposureTime_nsprefix_ = None
        self.ExposureMode = ExposureMode
        self.validate_String(self.ExposureMode)
        self.ExposureMode_nsprefix_ = None
        self.SpectralSensitivity = SpectralSensitivity
        self.validate_String(self.SpectralSensitivity)
        self.SpectralSensitivity_nsprefix_ = None
        self.PhotographicSensitivity = PhotographicSensitivity
        self.validate_String(self.PhotographicSensitivity)
        self.PhotographicSensitivity_nsprefix_ = None
        self.ISOSpeed = ISOSpeed
        self.validate_String(self.ISOSpeed)
        self.ISOSpeed_nsprefix_ = None
        self.ShutterSpeed = ShutterSpeed
        self.ShutterSpeed_nsprefix_ = None
        self.Brightness = Brightness
        self.validate_String(self.Brightness)
        self.Brightness_nsprefix_ = None
        self.Color = Color
        self.validate_String(self.Color)
        self.Color_nsprefix_ = None
        self.ThumbnailURL = ThumbnailURL
        self.ThumbnailURL_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ImageType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ImageType.subclass:
            return ImageType.subclass(*args_, **kwargs_)
        else:
            return ImageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_LensModel(self):
        return self.LensModel
    def set_LensModel(self, LensModel):
        self.LensModel = LensModel
    def get_FNumber(self):
        return self.FNumber
    def set_FNumber(self, FNumber):
        self.FNumber = FNumber
    def get_FocalLength(self):
        return self.FocalLength
    def set_FocalLength(self, FocalLength):
        self.FocalLength = FocalLength
    def get_FocalLengthIn35mmFilm(self):
        return self.FocalLengthIn35mmFilm
    def set_FocalLengthIn35mmFilm(self, FocalLengthIn35mmFilm):
        self.FocalLengthIn35mmFilm = FocalLengthIn35mmFilm
    def get_LightSource(self):
        return self.LightSource
    def set_LightSource(self, LightSource):
        self.LightSource = LightSource
    def get_Flash(self):
        return self.Flash
    def set_Flash(self, Flash):
        self.Flash = Flash
    def get_FlashEnergy(self):
        return self.FlashEnergy
    def set_FlashEnergy(self, FlashEnergy):
        self.FlashEnergy = FlashEnergy
    def get_WhiteBalance(self):
        return self.WhiteBalance
    def set_WhiteBalance(self, WhiteBalance):
        self.WhiteBalance = WhiteBalance
    def get_DigitalZoomRatio(self):
        return self.DigitalZoomRatio
    def set_DigitalZoomRatio(self, DigitalZoomRatio):
        self.DigitalZoomRatio = DigitalZoomRatio
    def get_Contrast(self):
        return self.Contrast
    def set_Contrast(self, Contrast):
        self.Contrast = Contrast
    def get_Saturation(self):
        return self.Saturation
    def set_Saturation(self, Saturation):
        self.Saturation = Saturation
    def get_Sharpness(self):
        return self.Sharpness
    def set_Sharpness(self, Sharpness):
        self.Sharpness = Sharpness
    def get_Gamma(self):
        return self.Gamma
    def set_Gamma(self, Gamma):
        self.Gamma = Gamma
    def get_ColorSpace(self):
        return self.ColorSpace
    def set_ColorSpace(self, ColorSpace):
        self.ColorSpace = ColorSpace
    def get_ImageSize(self):
        return self.ImageSize
    def set_ImageSize(self, ImageSize):
        self.ImageSize = ImageSize
    def get_ImageResolution(self):
        return self.ImageResolution
    def set_ImageResolution(self, ImageResolution):
        self.ImageResolution = ImageResolution
    def get_ExposureTime(self):
        return self.ExposureTime
    def set_ExposureTime(self, ExposureTime):
        self.ExposureTime = ExposureTime
    def get_ExposureMode(self):
        return self.ExposureMode
    def set_ExposureMode(self, ExposureMode):
        self.ExposureMode = ExposureMode
    def get_SpectralSensitivity(self):
        return self.SpectralSensitivity
    def set_SpectralSensitivity(self, SpectralSensitivity):
        self.SpectralSensitivity = SpectralSensitivity
    def get_PhotographicSensitivity(self):
        return self.PhotographicSensitivity
    def set_PhotographicSensitivity(self, PhotographicSensitivity):
        self.PhotographicSensitivity = PhotographicSensitivity
    def get_ISOSpeed(self):
        return self.ISOSpeed
    def set_ISOSpeed(self, ISOSpeed):
        self.ISOSpeed = ISOSpeed
    def get_ShutterSpeed(self):
        return self.ShutterSpeed
    def set_ShutterSpeed(self, ShutterSpeed):
        self.ShutterSpeed = ShutterSpeed
    def get_Brightness(self):
        return self.Brightness
    def set_Brightness(self, Brightness):
        self.Brightness = Brightness
    def get_Color(self):
        return self.Color
    def set_Color(self, Color):
        self.Color = Color
    def get_ThumbnailURL(self):
        return self.ThumbnailURL
    def set_ThumbnailURL(self, ThumbnailURL):
        self.ThumbnailURL = ThumbnailURL
    def validate_String(self, value):
        result = True
        # Validate type String, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on String' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.LensModel is not None or
            self.FNumber is not None or
            self.FocalLength is not None or
            self.FocalLengthIn35mmFilm is not None or
            self.LightSource is not None or
            self.Flash is not None or
            self.FlashEnergy is not None or
            self.WhiteBalance is not None or
            self.DigitalZoomRatio is not None or
            self.Contrast is not None or
            self.Saturation is not None or
            self.Sharpness is not None or
            self.Gamma is not None or
            self.ColorSpace is not None or
            self.ImageSize is not None or
            self.ImageResolution is not None or
            self.ExposureTime is not None or
            self.ExposureMode is not None or
            self.SpectralSensitivity is not None or
            self.PhotographicSensitivity is not None or
            self.ISOSpeed is not None or
            self.ShutterSpeed is not None or
            self.Brightness is not None or
            self.Color is not None or
            self.ThumbnailURL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='ImageType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ImageType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ImageType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ImageType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ImageType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='ImageType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LensModel is not None:
            namespaceprefix_ = self.LensModel_nsprefix_ + ':' if (UseCapturedNS_ and self.LensModel_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLensModel>%s</%sLensModel>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.LensModel), input_name='LensModel')), namespaceprefix_ , eol_))
        if self.FNumber is not None:
            namespaceprefix_ = self.FNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.FNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFNumber>%s</%sFNumber>%s' % (namespaceprefix_ , self.gds_format_double(self.FNumber, input_name='FNumber'), namespaceprefix_ , eol_))
        if self.FocalLength is not None:
            namespaceprefix_ = self.FocalLength_nsprefix_ + ':' if (UseCapturedNS_ and self.FocalLength_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFocalLength>%s</%sFocalLength>%s' % (namespaceprefix_ , self.gds_format_double(self.FocalLength, input_name='FocalLength'), namespaceprefix_ , eol_))
        if self.FocalLengthIn35mmFilm is not None:
            namespaceprefix_ = self.FocalLengthIn35mmFilm_nsprefix_ + ':' if (UseCapturedNS_ and self.FocalLengthIn35mmFilm_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFocalLengthIn35mmFilm>%s</%sFocalLengthIn35mmFilm>%s' % (namespaceprefix_ , self.gds_format_double(self.FocalLengthIn35mmFilm, input_name='FocalLengthIn35mmFilm'), namespaceprefix_ , eol_))
        if self.LightSource is not None:
            namespaceprefix_ = self.LightSource_nsprefix_ + ':' if (UseCapturedNS_ and self.LightSource_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLightSource>%s</%sLightSource>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.LightSource), input_name='LightSource')), namespaceprefix_ , eol_))
        if self.Flash is not None:
            namespaceprefix_ = self.Flash_nsprefix_ + ':' if (UseCapturedNS_ and self.Flash_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFlash>%s</%sFlash>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Flash), input_name='Flash')), namespaceprefix_ , eol_))
        if self.FlashEnergy is not None:
            namespaceprefix_ = self.FlashEnergy_nsprefix_ + ':' if (UseCapturedNS_ and self.FlashEnergy_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFlashEnergy>%s</%sFlashEnergy>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.FlashEnergy), input_name='FlashEnergy')), namespaceprefix_ , eol_))
        if self.WhiteBalance is not None:
            namespaceprefix_ = self.WhiteBalance_nsprefix_ + ':' if (UseCapturedNS_ and self.WhiteBalance_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sWhiteBalance>%s</%sWhiteBalance>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.WhiteBalance), input_name='WhiteBalance')), namespaceprefix_ , eol_))
        if self.DigitalZoomRatio is not None:
            namespaceprefix_ = self.DigitalZoomRatio_nsprefix_ + ':' if (UseCapturedNS_ and self.DigitalZoomRatio_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDigitalZoomRatio>%s</%sDigitalZoomRatio>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DigitalZoomRatio), input_name='DigitalZoomRatio')), namespaceprefix_ , eol_))
        if self.Contrast is not None:
            namespaceprefix_ = self.Contrast_nsprefix_ + ':' if (UseCapturedNS_ and self.Contrast_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sContrast>%s</%sContrast>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Contrast), input_name='Contrast')), namespaceprefix_ , eol_))
        if self.Saturation is not None:
            namespaceprefix_ = self.Saturation_nsprefix_ + ':' if (UseCapturedNS_ and self.Saturation_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSaturation>%s</%sSaturation>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Saturation), input_name='Saturation')), namespaceprefix_ , eol_))
        if self.Sharpness is not None:
            namespaceprefix_ = self.Sharpness_nsprefix_ + ':' if (UseCapturedNS_ and self.Sharpness_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSharpness>%s</%sSharpness>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Sharpness), input_name='Sharpness')), namespaceprefix_ , eol_))
        if self.Gamma is not None:
            namespaceprefix_ = self.Gamma_nsprefix_ + ':' if (UseCapturedNS_ and self.Gamma_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGamma>%s</%sGamma>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Gamma), input_name='Gamma')), namespaceprefix_ , eol_))
        if self.ColorSpace is not None:
            namespaceprefix_ = self.ColorSpace_nsprefix_ + ':' if (UseCapturedNS_ and self.ColorSpace_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sColorSpace>%s</%sColorSpace>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ColorSpace), input_name='ColorSpace')), namespaceprefix_ , eol_))
        if self.ImageSize is not None:
            namespaceprefix_ = self.ImageSize_nsprefix_ + ':' if (UseCapturedNS_ and self.ImageSize_nsprefix_) else ''
            self.ImageSize.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ImageSize', pretty_print=pretty_print)
        if self.ImageResolution is not None:
            namespaceprefix_ = self.ImageResolution_nsprefix_ + ':' if (UseCapturedNS_ and self.ImageResolution_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sImageResolution>%s</%sImageResolution>%s' % (namespaceprefix_ , self.gds_format_integer(self.ImageResolution, input_name='ImageResolution'), namespaceprefix_ , eol_))
        if self.ExposureTime is not None:
            namespaceprefix_ = self.ExposureTime_nsprefix_ + ':' if (UseCapturedNS_ and self.ExposureTime_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sExposureTime>%s</%sExposureTime>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ExposureTime), input_name='ExposureTime')), namespaceprefix_ , eol_))
        if self.ExposureMode is not None:
            namespaceprefix_ = self.ExposureMode_nsprefix_ + ':' if (UseCapturedNS_ and self.ExposureMode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sExposureMode>%s</%sExposureMode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ExposureMode), input_name='ExposureMode')), namespaceprefix_ , eol_))
        if self.SpectralSensitivity is not None:
            namespaceprefix_ = self.SpectralSensitivity_nsprefix_ + ':' if (UseCapturedNS_ and self.SpectralSensitivity_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSpectralSensitivity>%s</%sSpectralSensitivity>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SpectralSensitivity), input_name='SpectralSensitivity')), namespaceprefix_ , eol_))
        if self.PhotographicSensitivity is not None:
            namespaceprefix_ = self.PhotographicSensitivity_nsprefix_ + ':' if (UseCapturedNS_ and self.PhotographicSensitivity_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPhotographicSensitivity>%s</%sPhotographicSensitivity>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PhotographicSensitivity), input_name='PhotographicSensitivity')), namespaceprefix_ , eol_))
        if self.ISOSpeed is not None:
            namespaceprefix_ = self.ISOSpeed_nsprefix_ + ':' if (UseCapturedNS_ and self.ISOSpeed_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sISOSpeed>%s</%sISOSpeed>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ISOSpeed), input_name='ISOSpeed')), namespaceprefix_ , eol_))
        if self.ShutterSpeed is not None:
            namespaceprefix_ = self.ShutterSpeed_nsprefix_ + ':' if (UseCapturedNS_ and self.ShutterSpeed_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sShutterSpeed>%s</%sShutterSpeed>%s' % (namespaceprefix_ , self.gds_format_integer(self.ShutterSpeed, input_name='ShutterSpeed'), namespaceprefix_ , eol_))
        if self.Brightness is not None:
            namespaceprefix_ = self.Brightness_nsprefix_ + ':' if (UseCapturedNS_ and self.Brightness_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBrightness>%s</%sBrightness>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Brightness), input_name='Brightness')), namespaceprefix_ , eol_))
        if self.Color is not None:
            namespaceprefix_ = self.Color_nsprefix_ + ':' if (UseCapturedNS_ and self.Color_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sColor>%s</%sColor>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Color), input_name='Color')), namespaceprefix_ , eol_))
        if self.ThumbnailURL is not None:
            namespaceprefix_ = self.ThumbnailURL_nsprefix_ + ':' if (UseCapturedNS_ and self.ThumbnailURL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sThumbnailURL>%s</%sThumbnailURL>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ThumbnailURL), input_name='ThumbnailURL')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'LensModel':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'LensModel')
            value_ = self.gds_validate_string(value_, node, 'LensModel')
            self.LensModel = value_
            self.LensModel_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.LensModel)
        elif nodeName_ == 'FNumber' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_double(sval_, node, 'FNumber')
            fval_ = self.gds_validate_double(fval_, node, 'FNumber')
            self.FNumber = fval_
            self.FNumber_nsprefix_ = child_.prefix
        elif nodeName_ == 'FocalLength' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_double(sval_, node, 'FocalLength')
            fval_ = self.gds_validate_double(fval_, node, 'FocalLength')
            self.FocalLength = fval_
            self.FocalLength_nsprefix_ = child_.prefix
        elif nodeName_ == 'FocalLengthIn35mmFilm' and child_.text:
            sval_ = child_.text
            fval_ = self.gds_parse_double(sval_, node, 'FocalLengthIn35mmFilm')
            fval_ = self.gds_validate_double(fval_, node, 'FocalLengthIn35mmFilm')
            self.FocalLengthIn35mmFilm = fval_
            self.FocalLengthIn35mmFilm_nsprefix_ = child_.prefix
        elif nodeName_ == 'LightSource':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'LightSource')
            value_ = self.gds_validate_string(value_, node, 'LightSource')
            self.LightSource = value_
            self.LightSource_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.LightSource)
        elif nodeName_ == 'Flash':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Flash')
            value_ = self.gds_validate_string(value_, node, 'Flash')
            self.Flash = value_
            self.Flash_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.Flash)
        elif nodeName_ == 'FlashEnergy':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'FlashEnergy')
            value_ = self.gds_validate_string(value_, node, 'FlashEnergy')
            self.FlashEnergy = value_
            self.FlashEnergy_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.FlashEnergy)
        elif nodeName_ == 'WhiteBalance':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'WhiteBalance')
            value_ = self.gds_validate_string(value_, node, 'WhiteBalance')
            self.WhiteBalance = value_
            self.WhiteBalance_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.WhiteBalance)
        elif nodeName_ == 'DigitalZoomRatio':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DigitalZoomRatio')
            value_ = self.gds_validate_string(value_, node, 'DigitalZoomRatio')
            self.DigitalZoomRatio = value_
            self.DigitalZoomRatio_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.DigitalZoomRatio)
        elif nodeName_ == 'Contrast':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Contrast')
            value_ = self.gds_validate_string(value_, node, 'Contrast')
            self.Contrast = value_
            self.Contrast_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.Contrast)
        elif nodeName_ == 'Saturation':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Saturation')
            value_ = self.gds_validate_string(value_, node, 'Saturation')
            self.Saturation = value_
            self.Saturation_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.Saturation)
        elif nodeName_ == 'Sharpness':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Sharpness')
            value_ = self.gds_validate_string(value_, node, 'Sharpness')
            self.Sharpness = value_
            self.Sharpness_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.Sharpness)
        elif nodeName_ == 'Gamma':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Gamma')
            value_ = self.gds_validate_string(value_, node, 'Gamma')
            self.Gamma = value_
            self.Gamma_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.Gamma)
        elif nodeName_ == 'ColorSpace':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ColorSpace')
            value_ = self.gds_validate_string(value_, node, 'ColorSpace')
            self.ColorSpace = value_
            self.ColorSpace_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.ColorSpace)
        elif nodeName_ == 'ImageSize':
            obj_ = imageSize.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ImageSize = obj_
            obj_.original_tagname_ = 'ImageSize'
        elif nodeName_ == 'ImageResolution' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ImageResolution')
            ival_ = self.gds_validate_integer(ival_, node, 'ImageResolution')
            self.ImageResolution = ival_
            self.ImageResolution_nsprefix_ = child_.prefix
        elif nodeName_ == 'ExposureTime':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ExposureTime')
            value_ = self.gds_validate_string(value_, node, 'ExposureTime')
            self.ExposureTime = value_
            self.ExposureTime_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.ExposureTime)
        elif nodeName_ == 'ExposureMode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ExposureMode')
            value_ = self.gds_validate_string(value_, node, 'ExposureMode')
            self.ExposureMode = value_
            self.ExposureMode_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.ExposureMode)
        elif nodeName_ == 'SpectralSensitivity':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SpectralSensitivity')
            value_ = self.gds_validate_string(value_, node, 'SpectralSensitivity')
            self.SpectralSensitivity = value_
            self.SpectralSensitivity_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.SpectralSensitivity)
        elif nodeName_ == 'PhotographicSensitivity':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PhotographicSensitivity')
            value_ = self.gds_validate_string(value_, node, 'PhotographicSensitivity')
            self.PhotographicSensitivity = value_
            self.PhotographicSensitivity_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.PhotographicSensitivity)
        elif nodeName_ == 'ISOSpeed':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ISOSpeed')
            value_ = self.gds_validate_string(value_, node, 'ISOSpeed')
            self.ISOSpeed = value_
            self.ISOSpeed_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.ISOSpeed)
        elif nodeName_ == 'ShutterSpeed' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ShutterSpeed')
            ival_ = self.gds_validate_integer(ival_, node, 'ShutterSpeed')
            self.ShutterSpeed = ival_
            self.ShutterSpeed_nsprefix_ = child_.prefix
        elif nodeName_ == 'Brightness':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Brightness')
            value_ = self.gds_validate_string(value_, node, 'Brightness')
            self.Brightness = value_
            self.Brightness_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.Brightness)
        elif nodeName_ == 'Color':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Color')
            value_ = self.gds_validate_string(value_, node, 'Color')
            self.Color = value_
            self.Color_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.Color)
        elif nodeName_ == 'ThumbnailURL':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ThumbnailURL')
            value_ = self.gds_validate_string(value_, node, 'ThumbnailURL')
            self.ThumbnailURL = value_
            self.ThumbnailURL_nsprefix_ = child_.prefix
# end class ImageType


class ResourceURIsType10(GeneratedsSuper):
    """Preferably resolvable URIs of the reference (e.g. DOI)."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('ResourceURI', 'xs:anyURI', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'ResourceURI', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Reference-ResourceURI', 'type': 'xs:anyURI'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, ResourceURI=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ResourceURI is None:
            self.ResourceURI = []
        else:
            self.ResourceURI = ResourceURI
        self.ResourceURI_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ResourceURIsType10)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ResourceURIsType10.subclass:
            return ResourceURIsType10.subclass(*args_, **kwargs_)
        else:
            return ResourceURIsType10(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ResourceURI(self):
        return self.ResourceURI
    def set_ResourceURI(self, ResourceURI):
        self.ResourceURI = ResourceURI
    def add_ResourceURI(self, value):
        self.ResourceURI.append(value)
    def insert_ResourceURI_at(self, index, value):
        self.ResourceURI.insert(index, value)
    def replace_ResourceURI_at(self, index, value):
        self.ResourceURI[index] = value
    def hasContent_(self):
        if (
            self.ResourceURI
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='ResourceURIsType10', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ResourceURIsType10')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ResourceURIsType10')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ResourceURIsType10', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ResourceURIsType10'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='ResourceURIsType10', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ResourceURI_ in self.ResourceURI:
            namespaceprefix_ = self.ResourceURI_nsprefix_ + ':' if (UseCapturedNS_ and self.ResourceURI_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sResourceURI>%s</%sResourceURI>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(ResourceURI_), input_name='ResourceURI')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ResourceURI':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ResourceURI')
            value_ = self.gds_validate_string(value_, node, 'ResourceURI')
            self.ResourceURI.append(value_)
            self.ResourceURI_nsprefix_ = child_.prefix
# end class ResourceURIsType10


class RolesType(GeneratedsSuper):
    """A container element for several roles of the person."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('Role', 'StringL', 1, 0, {'maxOccurs': 'unbounded', 'name': 'Role', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/role', 'type': 'StringL'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, Role=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Role is None:
            self.Role = []
        else:
            self.Role = Role
        self.Role_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RolesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RolesType.subclass:
            return RolesType.subclass(*args_, **kwargs_)
        else:
            return RolesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Role(self):
        return self.Role
    def set_Role(self, Role):
        self.Role = Role
    def add_Role(self, value):
        self.Role.append(value)
    def insert_Role_at(self, index, value):
        self.Role.insert(index, value)
    def replace_Role_at(self, index, value):
        self.Role[index] = value
    def hasContent_(self):
        if (
            self.Role
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='RolesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RolesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RolesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RolesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RolesType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='RolesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Role_ in self.Role:
            namespaceprefix_ = self.Role_nsprefix_ + ':' if (UseCapturedNS_ and self.Role_nsprefix_) else ''
            Role_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Role', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Role':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Role.append(obj_)
            obj_.original_tagname_ = 'Role'
# end class RolesType


class AddressesType(GeneratedsSuper):
    """Contact addresses (one preferred, different languages possible)"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('Address', 'StringLP', 1, 0, {'maxOccurs': 'unbounded', 'name': 'Address', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/address', 'type': 'StringLP'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, Address=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Address is None:
            self.Address = []
        else:
            self.Address = Address
        self.Address_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AddressesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AddressesType.subclass:
            return AddressesType.subclass(*args_, **kwargs_)
        else:
            return AddressesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Address(self):
        return self.Address
    def set_Address(self, Address):
        self.Address = Address
    def add_Address(self, value):
        self.Address.append(value)
    def insert_Address_at(self, index, value):
        self.Address.insert(index, value)
    def replace_Address_at(self, index, value):
        self.Address[index] = value
    def hasContent_(self):
        if (
            self.Address
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='AddressesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AddressesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AddressesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AddressesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AddressesType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='AddressesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Address_ in self.Address:
            namespaceprefix_ = self.Address_nsprefix_ + ':' if (UseCapturedNS_ and self.Address_nsprefix_) else ''
            Address_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Address', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Address':
            obj_ = StringLP.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Address.append(obj_)
            obj_.original_tagname_ = 'Address'
# end class AddressesType


class TelephoneNumbersType(GeneratedsSuper):
    """Telephone and fax numbers"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('TelephoneNumber', 'StringP255', 1, 0, {'maxOccurs': 'unbounded', 'name': 'TelephoneNumber', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/telephoneNumber', 'type': 'StringP255'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, TelephoneNumber=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if TelephoneNumber is None:
            self.TelephoneNumber = []
        else:
            self.TelephoneNumber = TelephoneNumber
        self.TelephoneNumber_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TelephoneNumbersType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TelephoneNumbersType.subclass:
            return TelephoneNumbersType.subclass(*args_, **kwargs_)
        else:
            return TelephoneNumbersType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_TelephoneNumber(self):
        return self.TelephoneNumber
    def set_TelephoneNumber(self, TelephoneNumber):
        self.TelephoneNumber = TelephoneNumber
    def add_TelephoneNumber(self, value):
        self.TelephoneNumber.append(value)
    def insert_TelephoneNumber_at(self, index, value):
        self.TelephoneNumber.insert(index, value)
    def replace_TelephoneNumber_at(self, index, value):
        self.TelephoneNumber[index] = value
    def hasContent_(self):
        if (
            self.TelephoneNumber
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='TelephoneNumbersType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TelephoneNumbersType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TelephoneNumbersType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TelephoneNumbersType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TelephoneNumbersType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='TelephoneNumbersType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for TelephoneNumber_ in self.TelephoneNumber:
            namespaceprefix_ = self.TelephoneNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.TelephoneNumber_nsprefix_) else ''
            TelephoneNumber_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TelephoneNumber', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'TelephoneNumber':
            obj_ = StringP255.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TelephoneNumber.append(obj_)
            obj_.original_tagname_ = 'TelephoneNumber'
# end class TelephoneNumbersType


class EmailAddressesType(GeneratedsSuper):
    """E-mail addresses"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('EmailAddress', 'StringP255', 1, 0, {'maxOccurs': 'unbounded', 'name': 'EmailAddress', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/emailAddress', 'type': 'StringP255'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, EmailAddress=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if EmailAddress is None:
            self.EmailAddress = []
        else:
            self.EmailAddress = EmailAddress
        self.EmailAddress_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EmailAddressesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EmailAddressesType.subclass:
            return EmailAddressesType.subclass(*args_, **kwargs_)
        else:
            return EmailAddressesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_EmailAddress(self):
        return self.EmailAddress
    def set_EmailAddress(self, EmailAddress):
        self.EmailAddress = EmailAddress
    def add_EmailAddress(self, value):
        self.EmailAddress.append(value)
    def insert_EmailAddress_at(self, index, value):
        self.EmailAddress.insert(index, value)
    def replace_EmailAddress_at(self, index, value):
        self.EmailAddress[index] = value
    def hasContent_(self):
        if (
            self.EmailAddress
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='EmailAddressesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EmailAddressesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EmailAddressesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EmailAddressesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='EmailAddressesType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='EmailAddressesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for EmailAddress_ in self.EmailAddress:
            namespaceprefix_ = self.EmailAddress_nsprefix_ + ':' if (UseCapturedNS_ and self.EmailAddress_nsprefix_) else ''
            EmailAddress_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='EmailAddress', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'EmailAddress':
            obj_ = StringP255.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EmailAddress.append(obj_)
            obj_.original_tagname_ = 'EmailAddress'
# end class EmailAddressesType


class ResourceURIsType11(GeneratedsSuper):
    """URIs for person or Organization"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('ResourceURI', 'xs:anyURI', 1, 0, {'maxOccurs': 'unbounded', 'name': 'ResourceURI', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Contact-ResourceURI', 'type': 'xs:anyURI'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, ResourceURI=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ResourceURI is None:
            self.ResourceURI = []
        else:
            self.ResourceURI = ResourceURI
        self.ResourceURI_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ResourceURIsType11)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ResourceURIsType11.subclass:
            return ResourceURIsType11.subclass(*args_, **kwargs_)
        else:
            return ResourceURIsType11(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ResourceURI(self):
        return self.ResourceURI
    def set_ResourceURI(self, ResourceURI):
        self.ResourceURI = ResourceURI
    def add_ResourceURI(self, value):
        self.ResourceURI.append(value)
    def insert_ResourceURI_at(self, index, value):
        self.ResourceURI.insert(index, value)
    def replace_ResourceURI_at(self, index, value):
        self.ResourceURI[index] = value
    def hasContent_(self):
        if (
            self.ResourceURI
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='ResourceURIsType11', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ResourceURIsType11')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ResourceURIsType11')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ResourceURIsType11', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ResourceURIsType11'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='ResourceURIsType11', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ResourceURI_ in self.ResourceURI:
            namespaceprefix_ = self.ResourceURI_nsprefix_ + ':' if (UseCapturedNS_ and self.ResourceURI_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sResourceURI>%s</%sResourceURI>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(ResourceURI_), input_name='ResourceURI')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ResourceURI':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ResourceURI')
            value_ = self.gds_validate_string(value_, node, 'ResourceURI')
            self.ResourceURI.append(value_)
            self.ResourceURI_nsprefix_ = child_.prefix
# end class ResourceURIsType11


class DivisionsType(GeneratedsSuper):
    """If the contact contains no person definition: the unit within the
    organization the agent represents; else a list of the various
    Organizational units to which a person may belong. (vCard:OrgUnit)"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('Division', 'StringL', 1, 0, {'maxOccurs': 'unbounded', 'name': 'Division', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/division', 'type': 'StringL'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, Division=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Division is None:
            self.Division = []
        else:
            self.Division = Division
        self.Division_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DivisionsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DivisionsType.subclass:
            return DivisionsType.subclass(*args_, **kwargs_)
        else:
            return DivisionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Division(self):
        return self.Division
    def set_Division(self, Division):
        self.Division = Division
    def add_Division(self, value):
        self.Division.append(value)
    def insert_Division_at(self, index, value):
        self.Division.insert(index, value)
    def replace_Division_at(self, index, value):
        self.Division[index] = value
    def hasContent_(self):
        if (
            self.Division
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='DivisionsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DivisionsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DivisionsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DivisionsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DivisionsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='DivisionsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Division_ in self.Division:
            namespaceprefix_ = self.Division_nsprefix_ + ':' if (UseCapturedNS_ and self.Division_nsprefix_) else ''
            Division_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Division', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Division':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Division.append(obj_)
            obj_.original_tagname_ = 'Division'
# end class DivisionsType


class RepresentationType(LabelRepr):
    """Language-specific label representation [ATTR: language]"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
    ]
    subclass = None
    superclass = LabelRepr
    def __init__(self, language=None, Text=None, Abbreviation=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(RepresentationType, self).__init__(language, Text, Abbreviation,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RepresentationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RepresentationType.subclass:
            return RepresentationType.subclass(*args_, **kwargs_)
        else:
            return RepresentationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def hasContent_(self):
        if (
            super(RepresentationType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RepresentationType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RepresentationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RepresentationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RepresentationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RepresentationType'):
        super(RepresentationType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RepresentationType')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RepresentationType', fromsubclass_=False, pretty_print=True):
        super(RepresentationType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(RepresentationType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(RepresentationType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class RepresentationType


class AtomizedNameType(GeneratedsSuper):
    """Atomized name of the person."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('InheritedName', ['String255', 'xs:normalizedString'], 0, 0, {'name': 'InheritedName', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/inheritedName', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('Prefix', ['String255', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'Prefix', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/namePrefix', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('Suffix', ['String255', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'Suffix', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/nameSuffix', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('GivenNames', ['String255', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'GivenNames', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/givenNames', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('PreferredName', ['String255', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'PreferredName', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/preferredName', 'type': 'xs:normalizedString'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, InheritedName=None, Prefix=None, Suffix=None, GivenNames=None, PreferredName=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.InheritedName = InheritedName
        self.validate_String255(self.InheritedName)
        self.InheritedName_nsprefix_ = None
        self.Prefix = Prefix
        self.validate_String255(self.Prefix)
        self.Prefix_nsprefix_ = None
        self.Suffix = Suffix
        self.validate_String255(self.Suffix)
        self.Suffix_nsprefix_ = None
        self.GivenNames = GivenNames
        self.validate_String255(self.GivenNames)
        self.GivenNames_nsprefix_ = None
        self.PreferredName = PreferredName
        self.validate_String255(self.PreferredName)
        self.PreferredName_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AtomizedNameType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AtomizedNameType.subclass:
            return AtomizedNameType.subclass(*args_, **kwargs_)
        else:
            return AtomizedNameType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_InheritedName(self):
        return self.InheritedName
    def set_InheritedName(self, InheritedName):
        self.InheritedName = InheritedName
    def get_Prefix(self):
        return self.Prefix
    def set_Prefix(self, Prefix):
        self.Prefix = Prefix
    def get_Suffix(self):
        return self.Suffix
    def set_Suffix(self, Suffix):
        self.Suffix = Suffix
    def get_GivenNames(self):
        return self.GivenNames
    def set_GivenNames(self, GivenNames):
        self.GivenNames = GivenNames
    def get_PreferredName(self):
        return self.PreferredName
    def set_PreferredName(self, PreferredName):
        self.PreferredName = PreferredName
    def validate_String255(self, value):
        result = True
        # Validate type String255, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 255:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on String255' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on String255' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.InheritedName is not None or
            self.Prefix is not None or
            self.Suffix is not None or
            self.GivenNames is not None or
            self.PreferredName is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='AtomizedNameType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AtomizedNameType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AtomizedNameType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AtomizedNameType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AtomizedNameType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='AtomizedNameType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.InheritedName is not None:
            namespaceprefix_ = self.InheritedName_nsprefix_ + ':' if (UseCapturedNS_ and self.InheritedName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sInheritedName>%s</%sInheritedName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.InheritedName), input_name='InheritedName')), namespaceprefix_ , eol_))
        if self.Prefix is not None:
            namespaceprefix_ = self.Prefix_nsprefix_ + ':' if (UseCapturedNS_ and self.Prefix_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrefix>%s</%sPrefix>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Prefix), input_name='Prefix')), namespaceprefix_ , eol_))
        if self.Suffix is not None:
            namespaceprefix_ = self.Suffix_nsprefix_ + ':' if (UseCapturedNS_ and self.Suffix_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSuffix>%s</%sSuffix>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Suffix), input_name='Suffix')), namespaceprefix_ , eol_))
        if self.GivenNames is not None:
            namespaceprefix_ = self.GivenNames_nsprefix_ + ':' if (UseCapturedNS_ and self.GivenNames_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGivenNames>%s</%sGivenNames>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.GivenNames), input_name='GivenNames')), namespaceprefix_ , eol_))
        if self.PreferredName is not None:
            namespaceprefix_ = self.PreferredName_nsprefix_ + ':' if (UseCapturedNS_ and self.PreferredName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPreferredName>%s</%sPreferredName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PreferredName), input_name='PreferredName')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'InheritedName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'InheritedName')
            value_ = self.gds_validate_string(value_, node, 'InheritedName')
            self.InheritedName = value_
            self.InheritedName_nsprefix_ = child_.prefix
            # validate type String255
            self.validate_String255(self.InheritedName)
        elif nodeName_ == 'Prefix':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Prefix')
            value_ = self.gds_validate_string(value_, node, 'Prefix')
            self.Prefix = value_
            self.Prefix_nsprefix_ = child_.prefix
            # validate type String255
            self.validate_String255(self.Prefix)
        elif nodeName_ == 'Suffix':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Suffix')
            value_ = self.gds_validate_string(value_, node, 'Suffix')
            self.Suffix = value_
            self.Suffix_nsprefix_ = child_.prefix
            # validate type String255
            self.validate_String255(self.Suffix)
        elif nodeName_ == 'GivenNames':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'GivenNames')
            value_ = self.gds_validate_string(value_, node, 'GivenNames')
            self.GivenNames = value_
            self.GivenNames_nsprefix_ = child_.prefix
            # validate type String255
            self.validate_String255(self.GivenNames)
        elif nodeName_ == 'PreferredName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PreferredName')
            value_ = self.gds_validate_string(value_, node, 'PreferredName')
            self.PreferredName = value_
            self.PreferredName_nsprefix_ = child_.prefix
            # validate type String255
            self.validate_String255(self.PreferredName)
# end class AtomizedNameType


class CultureNamesType(GeneratedsSuper):
    """Container element for names under which the culture is known"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('CultureName', 'StringL', 1, 0, {'maxOccurs': 'unbounded', 'name': 'CultureName', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/cultureName', 'type': 'StringL'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, CultureName=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if CultureName is None:
            self.CultureName = []
        else:
            self.CultureName = CultureName
        self.CultureName_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CultureNamesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CultureNamesType.subclass:
            return CultureNamesType.subclass(*args_, **kwargs_)
        else:
            return CultureNamesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CultureName(self):
        return self.CultureName
    def set_CultureName(self, CultureName):
        self.CultureName = CultureName
    def add_CultureName(self, value):
        self.CultureName.append(value)
    def insert_CultureName_at(self, index, value):
        self.CultureName.insert(index, value)
    def replace_CultureName_at(self, index, value):
        self.CultureName[index] = value
    def hasContent_(self):
        if (
            self.CultureName
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='CultureNamesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CultureNamesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CultureNamesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CultureNamesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CultureNamesType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='CultureNamesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for CultureName_ in self.CultureName:
            namespaceprefix_ = self.CultureName_nsprefix_ + ':' if (UseCapturedNS_ and self.CultureName_nsprefix_) else ''
            CultureName_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CultureName', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CultureName':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CultureName.append(obj_)
            obj_.original_tagname_ = 'CultureName'
# end class CultureNamesType


class GrowthConditionsAtomizedType(GeneratedsSuper):
    """Atomized elements describing the growth conditions of the culture
    unit."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('GrowthConditionAtomized', 'GrowthConditionAtomized', 1, 0, {'maxOccurs': 'unbounded', 'name': 'GrowthConditionAtomized', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/GrowthCondition', 'type': 'GrowthConditionAtomized'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, GrowthConditionAtomized=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if GrowthConditionAtomized is None:
            self.GrowthConditionAtomized = []
        else:
            self.GrowthConditionAtomized = GrowthConditionAtomized
        self.GrowthConditionAtomized_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GrowthConditionsAtomizedType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GrowthConditionsAtomizedType.subclass:
            return GrowthConditionsAtomizedType.subclass(*args_, **kwargs_)
        else:
            return GrowthConditionsAtomizedType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_GrowthConditionAtomized(self):
        return self.GrowthConditionAtomized
    def set_GrowthConditionAtomized(self, GrowthConditionAtomized):
        self.GrowthConditionAtomized = GrowthConditionAtomized
    def add_GrowthConditionAtomized(self, value):
        self.GrowthConditionAtomized.append(value)
    def insert_GrowthConditionAtomized_at(self, index, value):
        self.GrowthConditionAtomized.insert(index, value)
    def replace_GrowthConditionAtomized_at(self, index, value):
        self.GrowthConditionAtomized[index] = value
    def hasContent_(self):
        if (
            self.GrowthConditionAtomized
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='GrowthConditionsAtomizedType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GrowthConditionsAtomizedType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GrowthConditionsAtomizedType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GrowthConditionsAtomizedType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='GrowthConditionsAtomizedType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='GrowthConditionsAtomizedType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for GrowthConditionAtomized_ in self.GrowthConditionAtomized:
            namespaceprefix_ = self.GrowthConditionAtomized_nsprefix_ + ':' if (UseCapturedNS_ and self.GrowthConditionAtomized_nsprefix_) else ''
            GrowthConditionAtomized_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='GrowthConditionAtomized', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'GrowthConditionAtomized':
            obj_ = GrowthConditionAtomized.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.GrowthConditionAtomized.append(obj_)
            obj_.original_tagname_ = 'GrowthConditionAtomized'
# end class GrowthConditionsAtomizedType


class ReferencesType12(GeneratedsSuper):
    """References for the culture conditions and method or for a description of
    the strain"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('Reference', 'Reference', 1, 0, {'maxOccurs': 'unbounded', 'name': 'Reference', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/CultureCollectionUnit-Reference', 'type': 'Reference'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, Reference=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Reference is None:
            self.Reference = []
        else:
            self.Reference = Reference
        self.Reference_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReferencesType12)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReferencesType12.subclass:
            return ReferencesType12.subclass(*args_, **kwargs_)
        else:
            return ReferencesType12(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Reference(self):
        return self.Reference
    def set_Reference(self, Reference):
        self.Reference = Reference
    def add_Reference(self, value):
        self.Reference.append(value)
    def insert_Reference_at(self, index, value):
        self.Reference.insert(index, value)
    def replace_Reference_at(self, index, value):
        self.Reference[index] = value
    def hasContent_(self):
        if (
            self.Reference
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='ReferencesType12', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReferencesType12')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReferencesType12')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ReferencesType12', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ReferencesType12'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='ReferencesType12', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Reference_ in self.Reference:
            namespaceprefix_ = self.Reference_nsprefix_ + ':' if (UseCapturedNS_ and self.Reference_nsprefix_) else ''
            Reference_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Reference', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Reference':
            obj_ = Reference.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Reference.append(obj_)
            obj_.original_tagname_ = 'Reference'
# end class ReferencesType12


class ReferencesType13(GeneratedsSuper):
    """References for the culture conditions and method."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('Reference', 'Reference', 1, 0, {'maxOccurs': 'unbounded', 'name': 'Reference', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/GrowthCondition-Reference', 'type': 'Reference'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, Reference=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Reference is None:
            self.Reference = []
        else:
            self.Reference = Reference
        self.Reference_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReferencesType13)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReferencesType13.subclass:
            return ReferencesType13.subclass(*args_, **kwargs_)
        else:
            return ReferencesType13(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Reference(self):
        return self.Reference
    def set_Reference(self, Reference):
        self.Reference = Reference
    def add_Reference(self, value):
        self.Reference.append(value)
    def insert_Reference_at(self, index, value):
        self.Reference.insert(index, value)
    def replace_Reference_at(self, index, value):
        self.Reference[index] = value
    def hasContent_(self):
        if (
            self.Reference
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='ReferencesType13', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReferencesType13')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReferencesType13')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ReferencesType13', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ReferencesType13'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='ReferencesType13', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Reference_ in self.Reference:
            namespaceprefix_ = self.Reference_nsprefix_ + ':' if (UseCapturedNS_ and self.Reference_nsprefix_) else ''
            Reference_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Reference', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Reference':
            obj_ = Reference.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Reference.append(obj_)
            obj_.original_tagname_ = 'Reference'
# end class ReferencesType13


class GrowthConditionsMeasurementsOrFactsType(GeneratedsSuper):
    """Further measurements or facts relevant for cultivation of strains. E.g.
    temperature, pH, oxygen, etc."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('GrowthConditionsMeasurementOrFact', 'MeasurementOrFact', 1, 0, {'maxOccurs': 'unbounded', 'name': 'GrowthConditionsMeasurementOrFact', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/GrowthCondition-MeasurementOrFact', 'type': 'MeasurementOrFact'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, GrowthConditionsMeasurementOrFact=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if GrowthConditionsMeasurementOrFact is None:
            self.GrowthConditionsMeasurementOrFact = []
        else:
            self.GrowthConditionsMeasurementOrFact = GrowthConditionsMeasurementOrFact
        self.GrowthConditionsMeasurementOrFact_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GrowthConditionsMeasurementsOrFactsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GrowthConditionsMeasurementsOrFactsType.subclass:
            return GrowthConditionsMeasurementsOrFactsType.subclass(*args_, **kwargs_)
        else:
            return GrowthConditionsMeasurementsOrFactsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_GrowthConditionsMeasurementOrFact(self):
        return self.GrowthConditionsMeasurementOrFact
    def set_GrowthConditionsMeasurementOrFact(self, GrowthConditionsMeasurementOrFact):
        self.GrowthConditionsMeasurementOrFact = GrowthConditionsMeasurementOrFact
    def add_GrowthConditionsMeasurementOrFact(self, value):
        self.GrowthConditionsMeasurementOrFact.append(value)
    def insert_GrowthConditionsMeasurementOrFact_at(self, index, value):
        self.GrowthConditionsMeasurementOrFact.insert(index, value)
    def replace_GrowthConditionsMeasurementOrFact_at(self, index, value):
        self.GrowthConditionsMeasurementOrFact[index] = value
    def hasContent_(self):
        if (
            self.GrowthConditionsMeasurementOrFact
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='GrowthConditionsMeasurementsOrFactsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GrowthConditionsMeasurementsOrFactsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GrowthConditionsMeasurementsOrFactsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GrowthConditionsMeasurementsOrFactsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='GrowthConditionsMeasurementsOrFactsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='GrowthConditionsMeasurementsOrFactsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for GrowthConditionsMeasurementOrFact_ in self.GrowthConditionsMeasurementOrFact:
            namespaceprefix_ = self.GrowthConditionsMeasurementOrFact_nsprefix_ + ':' if (UseCapturedNS_ and self.GrowthConditionsMeasurementOrFact_nsprefix_) else ''
            GrowthConditionsMeasurementOrFact_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='GrowthConditionsMeasurementOrFact', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'GrowthConditionsMeasurementOrFact':
            obj_ = MeasurementOrFact.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.GrowthConditionsMeasurementOrFact.append(obj_)
            obj_.original_tagname_ = 'GrowthConditionsMeasurementOrFact'
# end class GrowthConditionsMeasurementsOrFactsType


class MycologicalLiveStagesType(GeneratedsSuper):
    """Spore states present in the sample."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('MycologicalLiveStage', 'StringL', 1, 0, {'maxOccurs': 'unbounded', 'name': 'MycologicalLiveStage', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/mycologicalLiveStage', 'type': 'StringL'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, MycologicalLiveStage=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if MycologicalLiveStage is None:
            self.MycologicalLiveStage = []
        else:
            self.MycologicalLiveStage = MycologicalLiveStage
        self.MycologicalLiveStage_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MycologicalLiveStagesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MycologicalLiveStagesType.subclass:
            return MycologicalLiveStagesType.subclass(*args_, **kwargs_)
        else:
            return MycologicalLiveStagesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_MycologicalLiveStage(self):
        return self.MycologicalLiveStage
    def set_MycologicalLiveStage(self, MycologicalLiveStage):
        self.MycologicalLiveStage = MycologicalLiveStage
    def add_MycologicalLiveStage(self, value):
        self.MycologicalLiveStage.append(value)
    def insert_MycologicalLiveStage_at(self, index, value):
        self.MycologicalLiveStage.insert(index, value)
    def replace_MycologicalLiveStage_at(self, index, value):
        self.MycologicalLiveStage[index] = value
    def hasContent_(self):
        if (
            self.MycologicalLiveStage
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='MycologicalLiveStagesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MycologicalLiveStagesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MycologicalLiveStagesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MycologicalLiveStagesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MycologicalLiveStagesType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='MycologicalLiveStagesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for MycologicalLiveStage_ in self.MycologicalLiveStage:
            namespaceprefix_ = self.MycologicalLiveStage_nsprefix_ + ':' if (UseCapturedNS_ and self.MycologicalLiveStage_nsprefix_) else ''
            MycologicalLiveStage_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MycologicalLiveStage', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'MycologicalLiveStage':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MycologicalLiveStage.append(obj_)
            obj_.original_tagname_ = 'MycologicalLiveStage'
# end class MycologicalLiveStagesType


class AccessionNamesType(GeneratedsSuper):
    """A container element for the accession names."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('AccessionName', ['String', 'xs:normalizedString'], 1, 0, {'maxOccurs': 'unbounded', 'name': 'AccessionName', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/accessionName', 'type': 'xs:normalizedString'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, AccessionName=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if AccessionName is None:
            self.AccessionName = []
        else:
            self.AccessionName = AccessionName
        self.AccessionName_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AccessionNamesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AccessionNamesType.subclass:
            return AccessionNamesType.subclass(*args_, **kwargs_)
        else:
            return AccessionNamesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_AccessionName(self):
        return self.AccessionName
    def set_AccessionName(self, AccessionName):
        self.AccessionName = AccessionName
    def add_AccessionName(self, value):
        self.AccessionName.append(value)
    def insert_AccessionName_at(self, index, value):
        self.AccessionName.insert(index, value)
    def replace_AccessionName_at(self, index, value):
        self.AccessionName[index] = value
    def validate_String(self, value):
        result = True
        # Validate type String, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on String' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.AccessionName
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='AccessionNamesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AccessionNamesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AccessionNamesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AccessionNamesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AccessionNamesType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='AccessionNamesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for AccessionName_ in self.AccessionName:
            namespaceprefix_ = self.AccessionName_nsprefix_ + ':' if (UseCapturedNS_ and self.AccessionName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAccessionName>%s</%sAccessionName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(AccessionName_), input_name='AccessionName')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'AccessionName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'AccessionName')
            value_ = self.gds_validate_string(value_, node, 'AccessionName')
            self.AccessionName.append(value_)
            self.AccessionName_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.AccessionName[-1])
# end class AccessionNamesType


class PreservationType14(GeneratedsSuper):
    """Description of the fossil preservation of the specimen."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('Completeness', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'Completeness', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/completeness', 'type': 'StringL'}, None),
        MemberSpec_('Form', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'Form', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/form', 'type': 'StringL'}, None),
        MemberSpec_('Matrix', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'Matrix', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/matrix', 'type': 'StringL'}, None),
        MemberSpec_('Mineralization', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'Mineralization', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/mineralization', 'type': 'StringL'}, None),
        MemberSpec_('Taphonomy', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'Taphonomy', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/taphonomy', 'type': 'StringL'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, Completeness=None, Form=None, Matrix=None, Mineralization=None, Taphonomy=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Completeness = Completeness
        self.Completeness_nsprefix_ = None
        self.Form = Form
        self.Form_nsprefix_ = None
        self.Matrix = Matrix
        self.Matrix_nsprefix_ = None
        self.Mineralization = Mineralization
        self.Mineralization_nsprefix_ = None
        self.Taphonomy = Taphonomy
        self.Taphonomy_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PreservationType14)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PreservationType14.subclass:
            return PreservationType14.subclass(*args_, **kwargs_)
        else:
            return PreservationType14(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Completeness(self):
        return self.Completeness
    def set_Completeness(self, Completeness):
        self.Completeness = Completeness
    def get_Form(self):
        return self.Form
    def set_Form(self, Form):
        self.Form = Form
    def get_Matrix(self):
        return self.Matrix
    def set_Matrix(self, Matrix):
        self.Matrix = Matrix
    def get_Mineralization(self):
        return self.Mineralization
    def set_Mineralization(self, Mineralization):
        self.Mineralization = Mineralization
    def get_Taphonomy(self):
        return self.Taphonomy
    def set_Taphonomy(self, Taphonomy):
        self.Taphonomy = Taphonomy
    def hasContent_(self):
        if (
            self.Completeness is not None or
            self.Form is not None or
            self.Matrix is not None or
            self.Mineralization is not None or
            self.Taphonomy is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='PreservationType14', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PreservationType14')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PreservationType14')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PreservationType14', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PreservationType14'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='PreservationType14', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Completeness is not None:
            namespaceprefix_ = self.Completeness_nsprefix_ + ':' if (UseCapturedNS_ and self.Completeness_nsprefix_) else ''
            self.Completeness.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Completeness', pretty_print=pretty_print)
        if self.Form is not None:
            namespaceprefix_ = self.Form_nsprefix_ + ':' if (UseCapturedNS_ and self.Form_nsprefix_) else ''
            self.Form.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Form', pretty_print=pretty_print)
        if self.Matrix is not None:
            namespaceprefix_ = self.Matrix_nsprefix_ + ':' if (UseCapturedNS_ and self.Matrix_nsprefix_) else ''
            self.Matrix.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Matrix', pretty_print=pretty_print)
        if self.Mineralization is not None:
            namespaceprefix_ = self.Mineralization_nsprefix_ + ':' if (UseCapturedNS_ and self.Mineralization_nsprefix_) else ''
            self.Mineralization.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Mineralization', pretty_print=pretty_print)
        if self.Taphonomy is not None:
            namespaceprefix_ = self.Taphonomy_nsprefix_ + ':' if (UseCapturedNS_ and self.Taphonomy_nsprefix_) else ''
            self.Taphonomy.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Taphonomy', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Completeness':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Completeness = obj_
            obj_.original_tagname_ = 'Completeness'
        elif nodeName_ == 'Form':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Form = obj_
            obj_.original_tagname_ = 'Form'
        elif nodeName_ == 'Matrix':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Matrix = obj_
            obj_.original_tagname_ = 'Matrix'
        elif nodeName_ == 'Mineralization':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Mineralization = obj_
            obj_.original_tagname_ = 'Mineralization'
        elif nodeName_ == 'Taphonomy':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Taphonomy = obj_
            obj_.original_tagname_ = 'Taphonomy'
# end class PreservationType14


class ChronostratigraphicTermsType(GeneratedsSuper):
    """A container element for several chronostratigraphic dating terms
    expressing stratigraphy at the gathering site."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('ChronostratigraphicTerm', 'StratigraphicTermL', 1, 0, {'maxOccurs': 'unbounded', 'name': 'ChronostratigraphicTerm', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/ChronostratigraphicTerm', 'type': 'StratigraphicTermL'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, ChronostratigraphicTerm=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ChronostratigraphicTerm is None:
            self.ChronostratigraphicTerm = []
        else:
            self.ChronostratigraphicTerm = ChronostratigraphicTerm
        self.ChronostratigraphicTerm_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ChronostratigraphicTermsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ChronostratigraphicTermsType.subclass:
            return ChronostratigraphicTermsType.subclass(*args_, **kwargs_)
        else:
            return ChronostratigraphicTermsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ChronostratigraphicTerm(self):
        return self.ChronostratigraphicTerm
    def set_ChronostratigraphicTerm(self, ChronostratigraphicTerm):
        self.ChronostratigraphicTerm = ChronostratigraphicTerm
    def add_ChronostratigraphicTerm(self, value):
        self.ChronostratigraphicTerm.append(value)
    def insert_ChronostratigraphicTerm_at(self, index, value):
        self.ChronostratigraphicTerm.insert(index, value)
    def replace_ChronostratigraphicTerm_at(self, index, value):
        self.ChronostratigraphicTerm[index] = value
    def hasContent_(self):
        if (
            self.ChronostratigraphicTerm
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='ChronostratigraphicTermsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ChronostratigraphicTermsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ChronostratigraphicTermsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ChronostratigraphicTermsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ChronostratigraphicTermsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='ChronostratigraphicTermsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ChronostratigraphicTerm_ in self.ChronostratigraphicTerm:
            namespaceprefix_ = self.ChronostratigraphicTerm_nsprefix_ + ':' if (UseCapturedNS_ and self.ChronostratigraphicTerm_nsprefix_) else ''
            ChronostratigraphicTerm_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ChronostratigraphicTerm', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ChronostratigraphicTerm':
            obj_ = StratigraphicTermL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ChronostratigraphicTerm.append(obj_)
            obj_.original_tagname_ = 'ChronostratigraphicTerm'
# end class ChronostratigraphicTermsType


class BiostratigraphicTermsType(GeneratedsSuper):
    """A container element for several biostratigraphic zonation terms
    expressing stratigraphy at the gathering site."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('BiostratigraphicTerm', 'StratigraphicTermL', 1, 0, {'maxOccurs': 'unbounded', 'name': 'BiostratigraphicTerm', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/BiostratigraphicTerm', 'type': 'StratigraphicTermL'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, BiostratigraphicTerm=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if BiostratigraphicTerm is None:
            self.BiostratigraphicTerm = []
        else:
            self.BiostratigraphicTerm = BiostratigraphicTerm
        self.BiostratigraphicTerm_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BiostratigraphicTermsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BiostratigraphicTermsType.subclass:
            return BiostratigraphicTermsType.subclass(*args_, **kwargs_)
        else:
            return BiostratigraphicTermsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_BiostratigraphicTerm(self):
        return self.BiostratigraphicTerm
    def set_BiostratigraphicTerm(self, BiostratigraphicTerm):
        self.BiostratigraphicTerm = BiostratigraphicTerm
    def add_BiostratigraphicTerm(self, value):
        self.BiostratigraphicTerm.append(value)
    def insert_BiostratigraphicTerm_at(self, index, value):
        self.BiostratigraphicTerm.insert(index, value)
    def replace_BiostratigraphicTerm_at(self, index, value):
        self.BiostratigraphicTerm[index] = value
    def hasContent_(self):
        if (
            self.BiostratigraphicTerm
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='BiostratigraphicTermsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BiostratigraphicTermsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BiostratigraphicTermsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BiostratigraphicTermsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BiostratigraphicTermsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='BiostratigraphicTermsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for BiostratigraphicTerm_ in self.BiostratigraphicTerm:
            namespaceprefix_ = self.BiostratigraphicTerm_nsprefix_ + ':' if (UseCapturedNS_ and self.BiostratigraphicTerm_nsprefix_) else ''
            BiostratigraphicTerm_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='BiostratigraphicTerm', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'BiostratigraphicTerm':
            obj_ = StratigraphicTermL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BiostratigraphicTerm.append(obj_)
            obj_.original_tagname_ = 'BiostratigraphicTerm'
# end class BiostratigraphicTermsType


class LithostratigraphicTermsType(GeneratedsSuper):
    """A container element for several lithostratigraphic terms describing
    geology at the gathering site."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('LithostratigraphicTerm', 'StratigraphicTermL', 1, 0, {'maxOccurs': 'unbounded', 'name': 'LithostratigraphicTerm', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/LithostratigraphicTerm', 'type': 'StratigraphicTermL'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, LithostratigraphicTerm=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if LithostratigraphicTerm is None:
            self.LithostratigraphicTerm = []
        else:
            self.LithostratigraphicTerm = LithostratigraphicTerm
        self.LithostratigraphicTerm_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LithostratigraphicTermsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LithostratigraphicTermsType.subclass:
            return LithostratigraphicTermsType.subclass(*args_, **kwargs_)
        else:
            return LithostratigraphicTermsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_LithostratigraphicTerm(self):
        return self.LithostratigraphicTerm
    def set_LithostratigraphicTerm(self, LithostratigraphicTerm):
        self.LithostratigraphicTerm = LithostratigraphicTerm
    def add_LithostratigraphicTerm(self, value):
        self.LithostratigraphicTerm.append(value)
    def insert_LithostratigraphicTerm_at(self, index, value):
        self.LithostratigraphicTerm.insert(index, value)
    def replace_LithostratigraphicTerm_at(self, index, value):
        self.LithostratigraphicTerm[index] = value
    def hasContent_(self):
        if (
            self.LithostratigraphicTerm
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='LithostratigraphicTermsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LithostratigraphicTermsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LithostratigraphicTermsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LithostratigraphicTermsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LithostratigraphicTermsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='LithostratigraphicTermsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for LithostratigraphicTerm_ in self.LithostratigraphicTerm:
            namespaceprefix_ = self.LithostratigraphicTerm_nsprefix_ + ':' if (UseCapturedNS_ and self.LithostratigraphicTerm_nsprefix_) else ''
            LithostratigraphicTerm_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LithostratigraphicTerm', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'LithostratigraphicTerm':
            obj_ = StratigraphicTermL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LithostratigraphicTerm.append(obj_)
            obj_.original_tagname_ = 'LithostratigraphicTerm'
# end class LithostratigraphicTermsType


class PhasesOrStagesType(GeneratedsSuper):
    """Container element for the phase or stage of the individual organism or
    the organisms present in the unit. Note that counts can be provided in
    the Unit's MeasurementsOrFacts section."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('PhaseOrStage', 'StringL', 1, 0, {'maxOccurs': 'unbounded', 'name': 'PhaseOrStage', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/phaseOrStage', 'type': 'StringL'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, PhaseOrStage=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if PhaseOrStage is None:
            self.PhaseOrStage = []
        else:
            self.PhaseOrStage = PhaseOrStage
        self.PhaseOrStage_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PhasesOrStagesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PhasesOrStagesType.subclass:
            return PhasesOrStagesType.subclass(*args_, **kwargs_)
        else:
            return PhasesOrStagesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_PhaseOrStage(self):
        return self.PhaseOrStage
    def set_PhaseOrStage(self, PhaseOrStage):
        self.PhaseOrStage = PhaseOrStage
    def add_PhaseOrStage(self, value):
        self.PhaseOrStage.append(value)
    def insert_PhaseOrStage_at(self, index, value):
        self.PhaseOrStage.insert(index, value)
    def replace_PhaseOrStage_at(self, index, value):
        self.PhaseOrStage[index] = value
    def hasContent_(self):
        if (
            self.PhaseOrStage
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='PhasesOrStagesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PhasesOrStagesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PhasesOrStagesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PhasesOrStagesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PhasesOrStagesType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='PhasesOrStagesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for PhaseOrStage_ in self.PhaseOrStage:
            namespaceprefix_ = self.PhaseOrStage_nsprefix_ + ':' if (UseCapturedNS_ and self.PhaseOrStage_nsprefix_) else ''
            PhaseOrStage_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PhaseOrStage', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'PhaseOrStage':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PhaseOrStage.append(obj_)
            obj_.original_tagname_ = 'PhaseOrStage'
# end class PhasesOrStagesType


class MeasurementOrFactAtomizedType(GeneratedsSuper):
    """Atomized data describing a measurement or fact."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('MeasuredBy', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'MeasuredBy', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/MeasuredBy', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('MeasurementDateTime', ['DateTimeISO', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'MeasurementDateTime', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/MeasurementOrFact-Date', 'type': 'xs:string'}, None),
        MemberSpec_('Duration', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'Duration', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/duration', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('Method', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'Method', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/MeasurementOrFact-Method', 'type': 'StringL'}, None),
        MemberSpec_('Parameter', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'Parameter', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/parameter', 'type': 'StringL'}, None),
        MemberSpec_('AppliesTo', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'AppliesTo', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/appliesTo', 'type': 'StringL'}, None),
        MemberSpec_('LowerValue', 'StringL', 0, 0, {'name': 'LowerValue', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/lowerValue', 'type': 'StringL'}, None),
        MemberSpec_('UpperValue', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'UpperValue', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/upperValue', 'type': 'StringL'}, None),
        MemberSpec_('UnitOfMeasurement', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'UnitOfMeasurement', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/unitOfMeasurement', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('Accuracy', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'Accuracy', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/MeasurementOrFact-Accuracy', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('MeasurementOrFactReference', 'Reference', 0, 1, {'minOccurs': '0', 'name': 'MeasurementOrFactReference', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/MeasurementOrFact-Reference', 'type': 'Reference'}, None),
        MemberSpec_('IsQuantitative', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'IsQuantitative', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/isQuantitative', 'type': 'xs:boolean'}, None),
        MemberSpec_('ReferenceSystem', ['String', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'ReferenceSystem', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/referenceSystem', 'type': 'xs:normalizedString'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, MeasuredBy=None, MeasurementDateTime=None, Duration=None, Method=None, Parameter=None, AppliesTo=None, LowerValue=None, UpperValue=None, UnitOfMeasurement=None, Accuracy=None, MeasurementOrFactReference=None, IsQuantitative=None, ReferenceSystem=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.MeasuredBy = MeasuredBy
        self.validate_String(self.MeasuredBy)
        self.MeasuredBy_nsprefix_ = None
        self.MeasurementDateTime = MeasurementDateTime
        self.validate_DateTimeISO(self.MeasurementDateTime)
        self.MeasurementDateTime_nsprefix_ = None
        self.Duration = Duration
        self.validate_String(self.Duration)
        self.Duration_nsprefix_ = None
        self.Method = Method
        self.Method_nsprefix_ = None
        self.Parameter = Parameter
        self.Parameter_nsprefix_ = None
        self.AppliesTo = AppliesTo
        self.AppliesTo_nsprefix_ = None
        self.LowerValue = LowerValue
        self.LowerValue_nsprefix_ = None
        self.UpperValue = UpperValue
        self.UpperValue_nsprefix_ = None
        self.UnitOfMeasurement = UnitOfMeasurement
        self.validate_String(self.UnitOfMeasurement)
        self.UnitOfMeasurement_nsprefix_ = None
        self.Accuracy = Accuracy
        self.validate_String(self.Accuracy)
        self.Accuracy_nsprefix_ = None
        self.MeasurementOrFactReference = MeasurementOrFactReference
        self.MeasurementOrFactReference_nsprefix_ = None
        self.IsQuantitative = IsQuantitative
        self.IsQuantitative_nsprefix_ = None
        self.ReferenceSystem = ReferenceSystem
        self.validate_String(self.ReferenceSystem)
        self.ReferenceSystem_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MeasurementOrFactAtomizedType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MeasurementOrFactAtomizedType.subclass:
            return MeasurementOrFactAtomizedType.subclass(*args_, **kwargs_)
        else:
            return MeasurementOrFactAtomizedType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_MeasuredBy(self):
        return self.MeasuredBy
    def set_MeasuredBy(self, MeasuredBy):
        self.MeasuredBy = MeasuredBy
    def get_MeasurementDateTime(self):
        return self.MeasurementDateTime
    def set_MeasurementDateTime(self, MeasurementDateTime):
        self.MeasurementDateTime = MeasurementDateTime
    def get_Duration(self):
        return self.Duration
    def set_Duration(self, Duration):
        self.Duration = Duration
    def get_Method(self):
        return self.Method
    def set_Method(self, Method):
        self.Method = Method
    def get_Parameter(self):
        return self.Parameter
    def set_Parameter(self, Parameter):
        self.Parameter = Parameter
    def get_AppliesTo(self):
        return self.AppliesTo
    def set_AppliesTo(self, AppliesTo):
        self.AppliesTo = AppliesTo
    def get_LowerValue(self):
        return self.LowerValue
    def set_LowerValue(self, LowerValue):
        self.LowerValue = LowerValue
    def get_UpperValue(self):
        return self.UpperValue
    def set_UpperValue(self, UpperValue):
        self.UpperValue = UpperValue
    def get_UnitOfMeasurement(self):
        return self.UnitOfMeasurement
    def set_UnitOfMeasurement(self, UnitOfMeasurement):
        self.UnitOfMeasurement = UnitOfMeasurement
    def get_Accuracy(self):
        return self.Accuracy
    def set_Accuracy(self, Accuracy):
        self.Accuracy = Accuracy
    def get_MeasurementOrFactReference(self):
        return self.MeasurementOrFactReference
    def set_MeasurementOrFactReference(self, MeasurementOrFactReference):
        self.MeasurementOrFactReference = MeasurementOrFactReference
    def get_IsQuantitative(self):
        return self.IsQuantitative
    def set_IsQuantitative(self, IsQuantitative):
        self.IsQuantitative = IsQuantitative
    def get_ReferenceSystem(self):
        return self.ReferenceSystem
    def set_ReferenceSystem(self, ReferenceSystem):
        self.ReferenceSystem = ReferenceSystem
    def validate_String(self, value):
        result = True
        # Validate type String, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on String' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_DateTimeISO(self, value):
        result = True
        # Validate type DateTimeISO, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_DateTimeISO_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_DateTimeISO_patterns_, ))
                result = False
        return result
    validate_DateTimeISO_patterns_ = [['^(((1(5(8[3-9]|9\\d)|[6789]\\d\\d))|(20\\d\\d))(-((0[1-9]|1[012])(-(0[1-9]|1\\d|2[0-8])(T(0\\d|1\\d|2[0-3])(:[0-5]\\d(:[0-5]\\d(.\\d+)?)?)?(Z|[+\\-](0\\d|1[12])(:[0-5]\\d)?)?)?)?|(0[13-9]|1[012])-(29|30)(T(0\\d|1\\d|2[0-3])(:[0-5]\\d(:[0-5]\\d(.\\d+)?)?)?(Z|[+\\-](0\\d|1[12])(:[0-5]\\d)?)?)?|(0[13578]|1[02])-31(T(0\\d|1\\d|2[0-3])(:[0-5]\\d(:[0-5]\\d(.\\d+)?)?)?(Z|[+\\-](0\\d|1[12])(:[0-5]\\d)?)?)?))?|((15(8[48]|9[26]))|(1[6-9](0[48]|[2468][048]|[13579][26])|20(0[48]|[2468][048]|[13579][26]))|((16|20)00))-02-29(T(\\d|1\\d|2[0-3])(:[0-5]\\d(:[0-5]\\d(.\\d+)?)?)?(Z|[+\\-](0\\d|1[12])(:[0-5]\\d)?)?)?)$']]
    def hasContent_(self):
        if (
            self.MeasuredBy is not None or
            self.MeasurementDateTime is not None or
            self.Duration is not None or
            self.Method is not None or
            self.Parameter is not None or
            self.AppliesTo is not None or
            self.LowerValue is not None or
            self.UpperValue is not None or
            self.UnitOfMeasurement is not None or
            self.Accuracy is not None or
            self.MeasurementOrFactReference is not None or
            self.IsQuantitative is not None or
            self.ReferenceSystem is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='MeasurementOrFactAtomizedType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MeasurementOrFactAtomizedType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MeasurementOrFactAtomizedType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MeasurementOrFactAtomizedType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MeasurementOrFactAtomizedType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='MeasurementOrFactAtomizedType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MeasuredBy is not None:
            namespaceprefix_ = self.MeasuredBy_nsprefix_ + ':' if (UseCapturedNS_ and self.MeasuredBy_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMeasuredBy>%s</%sMeasuredBy>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.MeasuredBy), input_name='MeasuredBy')), namespaceprefix_ , eol_))
        if self.MeasurementDateTime is not None:
            namespaceprefix_ = self.MeasurementDateTime_nsprefix_ + ':' if (UseCapturedNS_ and self.MeasurementDateTime_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMeasurementDateTime>%s</%sMeasurementDateTime>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.MeasurementDateTime), input_name='MeasurementDateTime')), namespaceprefix_ , eol_))
        if self.Duration is not None:
            namespaceprefix_ = self.Duration_nsprefix_ + ':' if (UseCapturedNS_ and self.Duration_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDuration>%s</%sDuration>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Duration), input_name='Duration')), namespaceprefix_ , eol_))
        if self.Method is not None:
            namespaceprefix_ = self.Method_nsprefix_ + ':' if (UseCapturedNS_ and self.Method_nsprefix_) else ''
            self.Method.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Method', pretty_print=pretty_print)
        if self.Parameter is not None:
            namespaceprefix_ = self.Parameter_nsprefix_ + ':' if (UseCapturedNS_ and self.Parameter_nsprefix_) else ''
            self.Parameter.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Parameter', pretty_print=pretty_print)
        if self.AppliesTo is not None:
            namespaceprefix_ = self.AppliesTo_nsprefix_ + ':' if (UseCapturedNS_ and self.AppliesTo_nsprefix_) else ''
            self.AppliesTo.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AppliesTo', pretty_print=pretty_print)
        if self.LowerValue is not None:
            namespaceprefix_ = self.LowerValue_nsprefix_ + ':' if (UseCapturedNS_ and self.LowerValue_nsprefix_) else ''
            self.LowerValue.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LowerValue', pretty_print=pretty_print)
        if self.UpperValue is not None:
            namespaceprefix_ = self.UpperValue_nsprefix_ + ':' if (UseCapturedNS_ and self.UpperValue_nsprefix_) else ''
            self.UpperValue.export(outfile, level, namespaceprefix_, namespacedef_='', name_='UpperValue', pretty_print=pretty_print)
        if self.UnitOfMeasurement is not None:
            namespaceprefix_ = self.UnitOfMeasurement_nsprefix_ + ':' if (UseCapturedNS_ and self.UnitOfMeasurement_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUnitOfMeasurement>%s</%sUnitOfMeasurement>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.UnitOfMeasurement), input_name='UnitOfMeasurement')), namespaceprefix_ , eol_))
        if self.Accuracy is not None:
            namespaceprefix_ = self.Accuracy_nsprefix_ + ':' if (UseCapturedNS_ and self.Accuracy_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAccuracy>%s</%sAccuracy>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Accuracy), input_name='Accuracy')), namespaceprefix_ , eol_))
        if self.MeasurementOrFactReference is not None:
            namespaceprefix_ = self.MeasurementOrFactReference_nsprefix_ + ':' if (UseCapturedNS_ and self.MeasurementOrFactReference_nsprefix_) else ''
            self.MeasurementOrFactReference.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MeasurementOrFactReference', pretty_print=pretty_print)
        if self.IsQuantitative is not None:
            namespaceprefix_ = self.IsQuantitative_nsprefix_ + ':' if (UseCapturedNS_ and self.IsQuantitative_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIsQuantitative>%s</%sIsQuantitative>%s' % (namespaceprefix_ , self.gds_format_boolean(self.IsQuantitative, input_name='IsQuantitative'), namespaceprefix_ , eol_))
        if self.ReferenceSystem is not None:
            namespaceprefix_ = self.ReferenceSystem_nsprefix_ + ':' if (UseCapturedNS_ and self.ReferenceSystem_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReferenceSystem>%s</%sReferenceSystem>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ReferenceSystem), input_name='ReferenceSystem')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'MeasuredBy':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'MeasuredBy')
            value_ = self.gds_validate_string(value_, node, 'MeasuredBy')
            self.MeasuredBy = value_
            self.MeasuredBy_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.MeasuredBy)
        elif nodeName_ == 'MeasurementDateTime':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'MeasurementDateTime')
            value_ = self.gds_validate_string(value_, node, 'MeasurementDateTime')
            self.MeasurementDateTime = value_
            self.MeasurementDateTime_nsprefix_ = child_.prefix
            # validate type DateTimeISO
            self.validate_DateTimeISO(self.MeasurementDateTime)
        elif nodeName_ == 'Duration':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Duration')
            value_ = self.gds_validate_string(value_, node, 'Duration')
            self.Duration = value_
            self.Duration_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.Duration)
        elif nodeName_ == 'Method':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Method = obj_
            obj_.original_tagname_ = 'Method'
        elif nodeName_ == 'Parameter':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Parameter = obj_
            obj_.original_tagname_ = 'Parameter'
        elif nodeName_ == 'AppliesTo':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AppliesTo = obj_
            obj_.original_tagname_ = 'AppliesTo'
        elif nodeName_ == 'LowerValue':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LowerValue = obj_
            obj_.original_tagname_ = 'LowerValue'
        elif nodeName_ == 'UpperValue':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.UpperValue = obj_
            obj_.original_tagname_ = 'UpperValue'
        elif nodeName_ == 'UnitOfMeasurement':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'UnitOfMeasurement')
            value_ = self.gds_validate_string(value_, node, 'UnitOfMeasurement')
            self.UnitOfMeasurement = value_
            self.UnitOfMeasurement_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.UnitOfMeasurement)
        elif nodeName_ == 'Accuracy':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Accuracy')
            value_ = self.gds_validate_string(value_, node, 'Accuracy')
            self.Accuracy = value_
            self.Accuracy_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.Accuracy)
        elif nodeName_ == 'MeasurementOrFactReference':
            obj_ = Reference.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MeasurementOrFactReference = obj_
            obj_.original_tagname_ = 'MeasurementOrFactReference'
        elif nodeName_ == 'IsQuantitative':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'IsQuantitative')
            ival_ = self.gds_validate_boolean(ival_, node, 'IsQuantitative')
            self.IsQuantitative = ival_
            self.IsQuantitative_nsprefix_ = child_.prefix
        elif nodeName_ == 'ReferenceSystem':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ReferenceSystem')
            value_ = self.gds_validate_string(value_, node, 'ReferenceSystem')
            self.ReferenceSystem = value_
            self.ReferenceSystem_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.ReferenceSystem)
# end class MeasurementOrFactAtomizedType


class DescriptionType(GeneratedsSuper):
    """Dublin Core conformant elements describing the content of the data
    source queried, representation in different languages possible"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('Representation', 'MetadataDescriptionRepr', 1, 0, {'maxOccurs': 'unbounded', 'name': 'Representation', 'type': 'MetadataDescriptionRepr'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, Representation=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Representation is None:
            self.Representation = []
        else:
            self.Representation = Representation
        self.Representation_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DescriptionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DescriptionType.subclass:
            return DescriptionType.subclass(*args_, **kwargs_)
        else:
            return DescriptionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Representation(self):
        return self.Representation
    def set_Representation(self, Representation):
        self.Representation = Representation
    def add_Representation(self, value):
        self.Representation.append(value)
    def insert_Representation_at(self, index, value):
        self.Representation.insert(index, value)
    def replace_Representation_at(self, index, value):
        self.Representation[index] = value
    def hasContent_(self):
        if (
            self.Representation
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='DescriptionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DescriptionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DescriptionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DescriptionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DescriptionType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='DescriptionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Representation_ in self.Representation:
            namespaceprefix_ = self.Representation_nsprefix_ + ':' if (UseCapturedNS_ and self.Representation_nsprefix_) else ''
            Representation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Representation', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Representation':
            obj_ = MetadataDescriptionRepr.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Representation.append(obj_)
            obj_.original_tagname_ = 'Representation'
# end class DescriptionType


class ScopeType(GeneratedsSuper):
    """Keyword lists of geographical, taxonomic, etc. scopes. In the case of
    projects in progress, 'scope' may define the planned or intended,
    rather than the achieved scope (or coverage). If scope is given, the
    content available should be entirely within scope, because this item is
    for resource discovery purposes. Compare also Coverage in
    DC.Description (which is language-specific). (Items from Scope may be
    added to DC.Coverage)"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('GeoecologicalTerms', 'GeoecologicalTermsType', 0, 1, {'minOccurs': '0', 'name': 'GeoecologicalTerms', 'type': 'GeoecologicalTermsType'}, None),
        MemberSpec_('TaxonomicTerms', 'TaxonomicTermsType', 0, 1, {'minOccurs': '0', 'name': 'TaxonomicTerms', 'type': 'TaxonomicTermsType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, GeoecologicalTerms=None, TaxonomicTerms=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.GeoecologicalTerms = GeoecologicalTerms
        self.GeoecologicalTerms_nsprefix_ = None
        self.TaxonomicTerms = TaxonomicTerms
        self.TaxonomicTerms_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ScopeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ScopeType.subclass:
            return ScopeType.subclass(*args_, **kwargs_)
        else:
            return ScopeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_GeoecologicalTerms(self):
        return self.GeoecologicalTerms
    def set_GeoecologicalTerms(self, GeoecologicalTerms):
        self.GeoecologicalTerms = GeoecologicalTerms
    def get_TaxonomicTerms(self):
        return self.TaxonomicTerms
    def set_TaxonomicTerms(self, TaxonomicTerms):
        self.TaxonomicTerms = TaxonomicTerms
    def hasContent_(self):
        if (
            self.GeoecologicalTerms is not None or
            self.TaxonomicTerms is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='ScopeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ScopeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ScopeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ScopeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ScopeType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='ScopeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.GeoecologicalTerms is not None:
            namespaceprefix_ = self.GeoecologicalTerms_nsprefix_ + ':' if (UseCapturedNS_ and self.GeoecologicalTerms_nsprefix_) else ''
            self.GeoecologicalTerms.export(outfile, level, namespaceprefix_, namespacedef_='', name_='GeoecologicalTerms', pretty_print=pretty_print)
        if self.TaxonomicTerms is not None:
            namespaceprefix_ = self.TaxonomicTerms_nsprefix_ + ':' if (UseCapturedNS_ and self.TaxonomicTerms_nsprefix_) else ''
            self.TaxonomicTerms.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TaxonomicTerms', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'GeoecologicalTerms':
            obj_ = GeoecologicalTermsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.GeoecologicalTerms = obj_
            obj_.original_tagname_ = 'GeoecologicalTerms'
        elif nodeName_ == 'TaxonomicTerms':
            obj_ = TaxonomicTermsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TaxonomicTerms = obj_
            obj_.original_tagname_ = 'TaxonomicTerms'
# end class ScopeType


class GeoecologicalTermsType(GeneratedsSuper):
    """A collection of terms describing the geoecological scope of the source
    queried by means of area names (e.g. 'World', 'Germany', 'Atlantic
    Ocean', 'Andes', 'Mountains'). A list of recommended terms should be
    developed."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('GeoecologicalTerm', 'StringL255', 1, 0, {'maxOccurs': 'unbounded', 'name': 'GeoecologicalTerm', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/geoecologicalTerm', 'type': 'StringL255'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, GeoecologicalTerm=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if GeoecologicalTerm is None:
            self.GeoecologicalTerm = []
        else:
            self.GeoecologicalTerm = GeoecologicalTerm
        self.GeoecologicalTerm_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GeoecologicalTermsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeoecologicalTermsType.subclass:
            return GeoecologicalTermsType.subclass(*args_, **kwargs_)
        else:
            return GeoecologicalTermsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_GeoecologicalTerm(self):
        return self.GeoecologicalTerm
    def set_GeoecologicalTerm(self, GeoecologicalTerm):
        self.GeoecologicalTerm = GeoecologicalTerm
    def add_GeoecologicalTerm(self, value):
        self.GeoecologicalTerm.append(value)
    def insert_GeoecologicalTerm_at(self, index, value):
        self.GeoecologicalTerm.insert(index, value)
    def replace_GeoecologicalTerm_at(self, index, value):
        self.GeoecologicalTerm[index] = value
    def hasContent_(self):
        if (
            self.GeoecologicalTerm
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='GeoecologicalTermsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GeoecologicalTermsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GeoecologicalTermsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GeoecologicalTermsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='GeoecologicalTermsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='GeoecologicalTermsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for GeoecologicalTerm_ in self.GeoecologicalTerm:
            namespaceprefix_ = self.GeoecologicalTerm_nsprefix_ + ':' if (UseCapturedNS_ and self.GeoecologicalTerm_nsprefix_) else ''
            GeoecologicalTerm_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='GeoecologicalTerm', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'GeoecologicalTerm':
            obj_ = StringL255.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.GeoecologicalTerm.append(obj_)
            obj_.original_tagname_ = 'GeoecologicalTerm'
# end class GeoecologicalTermsType


class TaxonomicTermsType(GeneratedsSuper):
    """A collection of taxon names of higher rank describing the taxonomic
    scope of the source queried. A list of recommended terms should be
    developed."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('TaxonomicTerm', 'StringL255', 1, 0, {'maxOccurs': 'unbounded', 'name': 'TaxonomicTerm', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/taxonomicTerm', 'type': 'StringL255'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, TaxonomicTerm=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if TaxonomicTerm is None:
            self.TaxonomicTerm = []
        else:
            self.TaxonomicTerm = TaxonomicTerm
        self.TaxonomicTerm_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TaxonomicTermsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TaxonomicTermsType.subclass:
            return TaxonomicTermsType.subclass(*args_, **kwargs_)
        else:
            return TaxonomicTermsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_TaxonomicTerm(self):
        return self.TaxonomicTerm
    def set_TaxonomicTerm(self, TaxonomicTerm):
        self.TaxonomicTerm = TaxonomicTerm
    def add_TaxonomicTerm(self, value):
        self.TaxonomicTerm.append(value)
    def insert_TaxonomicTerm_at(self, index, value):
        self.TaxonomicTerm.insert(index, value)
    def replace_TaxonomicTerm_at(self, index, value):
        self.TaxonomicTerm[index] = value
    def hasContent_(self):
        if (
            self.TaxonomicTerm
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='TaxonomicTermsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TaxonomicTermsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TaxonomicTermsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TaxonomicTermsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TaxonomicTermsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='TaxonomicTermsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for TaxonomicTerm_ in self.TaxonomicTerm:
            namespaceprefix_ = self.TaxonomicTerm_nsprefix_ + ':' if (UseCapturedNS_ and self.TaxonomicTerm_nsprefix_) else ''
            TaxonomicTerm_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TaxonomicTerm', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'TaxonomicTerm':
            obj_ = StringL255.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TaxonomicTerm.append(obj_)
            obj_.original_tagname_ = 'TaxonomicTerm'
# end class TaxonomicTermsType


class VersionType(GeneratedsSuper):
    """Number and date of current version (particularly for citing purposes)"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('Major', 'xs:nonNegativeInteger', 0, 0, {'name': 'Major', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/major', 'type': 'xs:nonNegativeInteger'}, None),
        MemberSpec_('Minor', 'xs:nonNegativeInteger', 0, 1, {'minOccurs': '0', 'name': 'Minor', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/minor', 'type': 'xs:nonNegativeInteger'}, None),
        MemberSpec_('Modifier', ['String255', 'xs:normalizedString'], 0, 1, {'minOccurs': '0', 'name': 'Modifier', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/modifier', 'type': 'xs:normalizedString'}, None),
        MemberSpec_('DateCreated', ['DateTimeISO', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'DateCreated', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Version-DateCreated', 'type': 'xs:string'}, None),
        MemberSpec_('VersionText', 'StringL', 0, 1, {'minOccurs': '0', 'name': 'VersionText', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/VersionText', 'type': 'StringL'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, Major=None, Minor=None, Modifier=None, DateCreated=None, VersionText=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Major = Major
        self.Major_nsprefix_ = None
        self.Minor = Minor
        self.Minor_nsprefix_ = None
        self.Modifier = Modifier
        self.validate_String255(self.Modifier)
        self.Modifier_nsprefix_ = None
        self.DateCreated = DateCreated
        self.validate_DateTimeISO(self.DateCreated)
        self.DateCreated_nsprefix_ = None
        self.VersionText = VersionText
        self.VersionText_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VersionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VersionType.subclass:
            return VersionType.subclass(*args_, **kwargs_)
        else:
            return VersionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Major(self):
        return self.Major
    def set_Major(self, Major):
        self.Major = Major
    def get_Minor(self):
        return self.Minor
    def set_Minor(self, Minor):
        self.Minor = Minor
    def get_Modifier(self):
        return self.Modifier
    def set_Modifier(self, Modifier):
        self.Modifier = Modifier
    def get_DateCreated(self):
        return self.DateCreated
    def set_DateCreated(self, DateCreated):
        self.DateCreated = DateCreated
    def get_VersionText(self):
        return self.VersionText
    def set_VersionText(self, VersionText):
        self.VersionText = VersionText
    def validate_String255(self, value):
        result = True
        # Validate type String255, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 255:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on String255' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on String255' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def validate_DateTimeISO(self, value):
        result = True
        # Validate type DateTimeISO, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_DateTimeISO_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_DateTimeISO_patterns_, ))
                result = False
        return result
    validate_DateTimeISO_patterns_ = [['^(((1(5(8[3-9]|9\\d)|[6789]\\d\\d))|(20\\d\\d))(-((0[1-9]|1[012])(-(0[1-9]|1\\d|2[0-8])(T(0\\d|1\\d|2[0-3])(:[0-5]\\d(:[0-5]\\d(.\\d+)?)?)?(Z|[+\\-](0\\d|1[12])(:[0-5]\\d)?)?)?)?|(0[13-9]|1[012])-(29|30)(T(0\\d|1\\d|2[0-3])(:[0-5]\\d(:[0-5]\\d(.\\d+)?)?)?(Z|[+\\-](0\\d|1[12])(:[0-5]\\d)?)?)?|(0[13578]|1[02])-31(T(0\\d|1\\d|2[0-3])(:[0-5]\\d(:[0-5]\\d(.\\d+)?)?)?(Z|[+\\-](0\\d|1[12])(:[0-5]\\d)?)?)?))?|((15(8[48]|9[26]))|(1[6-9](0[48]|[2468][048]|[13579][26])|20(0[48]|[2468][048]|[13579][26]))|((16|20)00))-02-29(T(\\d|1\\d|2[0-3])(:[0-5]\\d(:[0-5]\\d(.\\d+)?)?)?(Z|[+\\-](0\\d|1[12])(:[0-5]\\d)?)?)?)$']]
    def hasContent_(self):
        if (
            self.Major is not None or
            self.Minor is not None or
            self.Modifier is not None or
            self.DateCreated is not None or
            self.VersionText is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='VersionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VersionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VersionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VersionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VersionType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='VersionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Major is not None:
            namespaceprefix_ = self.Major_nsprefix_ + ':' if (UseCapturedNS_ and self.Major_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMajor>%s</%sMajor>%s' % (namespaceprefix_ , self.gds_format_integer(self.Major, input_name='Major'), namespaceprefix_ , eol_))
        if self.Minor is not None:
            namespaceprefix_ = self.Minor_nsprefix_ + ':' if (UseCapturedNS_ and self.Minor_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMinor>%s</%sMinor>%s' % (namespaceprefix_ , self.gds_format_integer(self.Minor, input_name='Minor'), namespaceprefix_ , eol_))
        if self.Modifier is not None:
            namespaceprefix_ = self.Modifier_nsprefix_ + ':' if (UseCapturedNS_ and self.Modifier_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sModifier>%s</%sModifier>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Modifier), input_name='Modifier')), namespaceprefix_ , eol_))
        if self.DateCreated is not None:
            namespaceprefix_ = self.DateCreated_nsprefix_ + ':' if (UseCapturedNS_ and self.DateCreated_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDateCreated>%s</%sDateCreated>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DateCreated), input_name='DateCreated')), namespaceprefix_ , eol_))
        if self.VersionText is not None:
            namespaceprefix_ = self.VersionText_nsprefix_ + ':' if (UseCapturedNS_ and self.VersionText_nsprefix_) else ''
            self.VersionText.export(outfile, level, namespaceprefix_, namespacedef_='', name_='VersionText', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Major' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'Major')
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'Major')
            self.Major = ival_
            self.Major_nsprefix_ = child_.prefix
        elif nodeName_ == 'Minor' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'Minor')
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'Minor')
            self.Minor = ival_
            self.Minor_nsprefix_ = child_.prefix
        elif nodeName_ == 'Modifier':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Modifier')
            value_ = self.gds_validate_string(value_, node, 'Modifier')
            self.Modifier = value_
            self.Modifier_nsprefix_ = child_.prefix
            # validate type String255
            self.validate_String255(self.Modifier)
        elif nodeName_ == 'DateCreated':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DateCreated')
            value_ = self.gds_validate_string(value_, node, 'DateCreated')
            self.DateCreated = value_
            self.DateCreated_nsprefix_ = child_.prefix
            # validate type DateTimeISO
            self.validate_DateTimeISO(self.DateCreated)
        elif nodeName_ == 'VersionText':
            obj_ = StringL.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VersionText = obj_
            obj_.original_tagname_ = 'VersionText'
# end class VersionType


class OwnersType(GeneratedsSuper):
    """Entities having legal possession of the data collection content. Here
    defined for the entire data collection, not for individual units. If an
    owner statement is present on the unit level, it should override this
    dataset-level statement."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('Owner', 'Contact', 1, 0, {'maxOccurs': 'unbounded', 'name': 'Owner', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/mappings/Owner http://rs.tdwg.org/abcd/mappings/DataSet-Owner', 'type': 'Contact'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, Owner=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Owner is None:
            self.Owner = []
        else:
            self.Owner = Owner
        self.Owner_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OwnersType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OwnersType.subclass:
            return OwnersType.subclass(*args_, **kwargs_)
        else:
            return OwnersType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Owner(self):
        return self.Owner
    def set_Owner(self, Owner):
        self.Owner = Owner
    def add_Owner(self, value):
        self.Owner.append(value)
    def insert_Owner_at(self, index, value):
        self.Owner.insert(index, value)
    def replace_Owner_at(self, index, value):
        self.Owner[index] = value
    def hasContent_(self):
        if (
            self.Owner
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='OwnersType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OwnersType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OwnersType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='OwnersType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='OwnersType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='OwnersType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Owner_ in self.Owner:
            namespaceprefix_ = self.Owner_nsprefix_ + ':' if (UseCapturedNS_ and self.Owner_nsprefix_) else ''
            Owner_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Owner', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Owner':
            class_obj_ = self.get_class_obj_(child_, Contact)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Owner.append(obj_)
            obj_.original_tagname_ = 'Owner'
# end class OwnersType


class HigherTaxaType(GeneratedsSuper):
    """Wrapper element for multiple designations of higher taxa. These are
    higher-level classifications of the name identified, NOT a higher taxon
    as the sole identification."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('HigherTaxon', 'HigherTaxon', 1, 0, {'maxOccurs': 'unbounded', 'name': 'HigherTaxon', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/HigherTaxon', 'type': 'HigherTaxon'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, HigherTaxon=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if HigherTaxon is None:
            self.HigherTaxon = []
        else:
            self.HigherTaxon = HigherTaxon
        self.HigherTaxon_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HigherTaxaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HigherTaxaType.subclass:
            return HigherTaxaType.subclass(*args_, **kwargs_)
        else:
            return HigherTaxaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_HigherTaxon(self):
        return self.HigherTaxon
    def set_HigherTaxon(self, HigherTaxon):
        self.HigherTaxon = HigherTaxon
    def add_HigherTaxon(self, value):
        self.HigherTaxon.append(value)
    def insert_HigherTaxon_at(self, index, value):
        self.HigherTaxon.insert(index, value)
    def replace_HigherTaxon_at(self, index, value):
        self.HigherTaxon[index] = value
    def hasContent_(self):
        if (
            self.HigherTaxon
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='HigherTaxaType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HigherTaxaType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HigherTaxaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='HigherTaxaType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='HigherTaxaType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='HigherTaxaType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for HigherTaxon_ in self.HigherTaxon:
            namespaceprefix_ = self.HigherTaxon_nsprefix_ + ':' if (UseCapturedNS_ and self.HigherTaxon_nsprefix_) else ''
            HigherTaxon_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='HigherTaxon', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'HigherTaxon':
            obj_ = HigherTaxon.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.HigherTaxon.append(obj_)
            obj_.original_tagname_ = 'HigherTaxon'
# end class HigherTaxaType


class HybridFlagType(GeneratedsSuper):
    """Flag indicating that this is a named hybrid ("x") or a graft chimaera
    ("+"). The attribute insertionpoint defines the name element in front
    of which the hybrid flag should be inserted (1 = before entire name, 2=
    before first epithet, 3 = before rank designation for second
    epithet.)"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('insertionpoint', 'xs:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, insertionpoint=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.insertionpoint = _cast(int, insertionpoint)
        self.insertionpoint_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HybridFlagType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HybridFlagType.subclass:
            return HybridFlagType.subclass(*args_, **kwargs_)
        else:
            return HybridFlagType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_insertionpoint(self):
        return self.insertionpoint
    def set_insertionpoint(self, insertionpoint):
        self.insertionpoint = insertionpoint
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='HybridFlagType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HybridFlagType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HybridFlagType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='HybridFlagType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='HybridFlagType'):
        if self.insertionpoint is not None and 'insertionpoint' not in already_processed:
            already_processed.add('insertionpoint')
            outfile.write(' insertionpoint="%s"' % self.gds_format_integer(self.insertionpoint, input_name='insertionpoint'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='HybridFlagType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('insertionpoint', node)
        if value is not None and 'insertionpoint' not in already_processed:
            already_processed.add('insertionpoint')
            self.insertionpoint = self.gds_parse_integer(value, node, 'insertionpoint')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class HybridFlagType


class TradeDesignationNamesType(GeneratedsSuper):
    """Container for trade names."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('TradeDesignationName', ['String', 'xs:normalizedString'], 1, 0, {'maxOccurs': 'unbounded', 'name': 'TradeDesignationName', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/tradeDesignationName', 'type': 'xs:normalizedString'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, TradeDesignationName=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if TradeDesignationName is None:
            self.TradeDesignationName = []
        else:
            self.TradeDesignationName = TradeDesignationName
        self.TradeDesignationName_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TradeDesignationNamesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TradeDesignationNamesType.subclass:
            return TradeDesignationNamesType.subclass(*args_, **kwargs_)
        else:
            return TradeDesignationNamesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_TradeDesignationName(self):
        return self.TradeDesignationName
    def set_TradeDesignationName(self, TradeDesignationName):
        self.TradeDesignationName = TradeDesignationName
    def add_TradeDesignationName(self, value):
        self.TradeDesignationName.append(value)
    def insert_TradeDesignationName_at(self, index, value):
        self.TradeDesignationName.insert(index, value)
    def replace_TradeDesignationName_at(self, index, value):
        self.TradeDesignationName[index] = value
    def validate_String(self, value):
        result = True
        # Validate type String, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on String' % {"value" : value, "lineno": lineno} )
                result = False
        return result
    def hasContent_(self):
        if (
            self.TradeDesignationName
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='TradeDesignationNamesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TradeDesignationNamesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TradeDesignationNamesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TradeDesignationNamesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TradeDesignationNamesType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='TradeDesignationNamesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for TradeDesignationName_ in self.TradeDesignationName:
            namespaceprefix_ = self.TradeDesignationName_nsprefix_ + ':' if (UseCapturedNS_ and self.TradeDesignationName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTradeDesignationName>%s</%sTradeDesignationName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(TradeDesignationName_), input_name='TradeDesignationName')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'TradeDesignationName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TradeDesignationName')
            value_ = self.gds_validate_string(value_, node, 'TradeDesignationName')
            self.TradeDesignationName.append(value_)
            self.TradeDesignationName_nsprefix_ = child_.prefix
            # validate type String
            self.validate_String(self.TradeDesignationName[-1])
# end class TradeDesignationNamesType


class NameAtomizedType(GeneratedsSuper):
    """Atomized data items of the taxon identified, with subtypes according to
    the different Codes of Nomenclature which apply to scientific names."""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('Bacterial', 'NameBacterial', 0, 1, {'minOccurs': '0', 'name': 'Bacterial', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/BacterialScientificName', 'type': 'NameBacterial'}, 5),
        MemberSpec_('Botanical', 'NameBotanical', 0, 1, {'minOccurs': '0', 'name': 'Botanical', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/BotanicalScientificName', 'type': 'NameBotanical'}, 5),
        MemberSpec_('Zoological', 'NameZoological', 0, 1, {'minOccurs': '0', 'name': 'Zoological', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/ZoologicalScientificName', 'type': 'NameZoological'}, 5),
        MemberSpec_('Viral', 'NameViral', 0, 1, {'minOccurs': '0', 'name': 'Viral', 'sawsdl:modelReference': 'http://rs.tdwg.org/abcd/terms/ViralScientificName', 'type': 'NameViral'}, 5),
    ]
    subclass = None
    superclass = None
    def __init__(self, Bacterial=None, Botanical=None, Zoological=None, Viral=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Bacterial = Bacterial
        self.Bacterial_nsprefix_ = None
        self.Botanical = Botanical
        self.Botanical_nsprefix_ = None
        self.Zoological = Zoological
        self.Zoological_nsprefix_ = None
        self.Viral = Viral
        self.Viral_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NameAtomizedType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NameAtomizedType.subclass:
            return NameAtomizedType.subclass(*args_, **kwargs_)
        else:
            return NameAtomizedType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Bacterial(self):
        return self.Bacterial
    def set_Bacterial(self, Bacterial):
        self.Bacterial = Bacterial
    def get_Botanical(self):
        return self.Botanical
    def set_Botanical(self, Botanical):
        self.Botanical = Botanical
    def get_Zoological(self):
        return self.Zoological
    def set_Zoological(self, Zoological):
        self.Zoological = Zoological
    def get_Viral(self):
        return self.Viral
    def set_Viral(self, Viral):
        self.Viral = Viral
    def hasContent_(self):
        if (
            self.Bacterial is not None or
            self.Botanical is not None or
            self.Zoological is not None or
            self.Viral is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='NameAtomizedType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NameAtomizedType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NameAtomizedType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NameAtomizedType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NameAtomizedType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.tdwg.org/schemas/abcd/3.0" ', name_='NameAtomizedType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Bacterial is not None:
            namespaceprefix_ = self.Bacterial_nsprefix_ + ':' if (UseCapturedNS_ and self.Bacterial_nsprefix_) else ''
            self.Bacterial.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Bacterial', pretty_print=pretty_print)
        if self.Botanical is not None:
            namespaceprefix_ = self.Botanical_nsprefix_ + ':' if (UseCapturedNS_ and self.Botanical_nsprefix_) else ''
            self.Botanical.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Botanical', pretty_print=pretty_print)
        if self.Zoological is not None:
            namespaceprefix_ = self.Zoological_nsprefix_ + ':' if (UseCapturedNS_ and self.Zoological_nsprefix_) else ''
            self.Zoological.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Zoological', pretty_print=pretty_print)
        if self.Viral is not None:
            namespaceprefix_ = self.Viral_nsprefix_ + ':' if (UseCapturedNS_ and self.Viral_nsprefix_) else ''
            self.Viral.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Viral', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Bacterial':
            obj_ = NameBacterial.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Bacterial = obj_
            obj_.original_tagname_ = 'Bacterial'
        elif nodeName_ == 'Botanical':
            obj_ = NameBotanical.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Botanical = obj_
            obj_.original_tagname_ = 'Botanical'
        elif nodeName_ == 'Zoological':
            obj_ = NameZoological.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Zoological = obj_
            obj_.original_tagname_ = 'Zoological'
        elif nodeName_ == 'Viral':
            obj_ = NameViral.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Viral = obj_
            obj_.original_tagname_ = 'Viral'
# end class NameAtomizedType


class IdentificationQualifierType(GeneratedsSuper):
    """A term to qualify the identification of the unit when doubts have arisen
    as to its identity (e.g. "cf." or "aff."). If it applies to an atomized
    name, the attribute insertionpoint defines the name element in front of
    which the qualifier should be inserted (1 = before entire name, 2=
    before first epithet, 3 = before second epithet.)"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('insertionpoint', 'xs:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, insertionpoint=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.insertionpoint = _cast(int, insertionpoint)
        self.insertionpoint_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IdentificationQualifierType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IdentificationQualifierType.subclass:
            return IdentificationQualifierType.subclass(*args_, **kwargs_)
        else:
            return IdentificationQualifierType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_insertionpoint(self):
        return self.insertionpoint
    def set_insertionpoint(self, insertionpoint):
        self.insertionpoint = insertionpoint
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IdentificationQualifierType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IdentificationQualifierType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IdentificationQualifierType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IdentificationQualifierType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IdentificationQualifierType'):
        if self.insertionpoint is not None and 'insertionpoint' not in already_processed:
            already_processed.add('insertionpoint')
            outfile.write(' insertionpoint="%s"' % self.gds_format_integer(self.insertionpoint, input_name='insertionpoint'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IdentificationQualifierType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('insertionpoint', node)
        if value is not None and 'insertionpoint' not in already_processed:
            already_processed.add('insertionpoint')
            self.insertionpoint = self.gds_parse_integer(value, node, 'insertionpoint')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class IdentificationQualifierType


class ContactP(Contact):
    """Contact with preferred flag"""
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('preferred', 'xs:boolean', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = Contact
    def __init__(self, UnformattedValue=None, Organization=None, Person=None, Roles=None, Addresses=None, TelephoneNumbers=None, EmailAddresses=None, WebsiteURL=None, ResourceURIs=None, preferred=False, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ContactP, self).__init__(UnformattedValue, Organization, Person, Roles, Addresses, TelephoneNumbers, EmailAddresses, WebsiteURL, ResourceURIs,  **kwargs_)
        self.preferred = _cast(bool, preferred)
        self.preferred_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContactP)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContactP.subclass:
            return ContactP.subclass(*args_, **kwargs_)
        else:
            return ContactP(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_preferred(self):
        return self.preferred
    def set_preferred(self, preferred):
        self.preferred = preferred
    def hasContent_(self):
        if (
            super(ContactP, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ContactP', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ContactP')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ContactP')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ContactP', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ContactP'):
        super(ContactP, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ContactP')
        if self.preferred and 'preferred' not in already_processed:
            already_processed.add('preferred')
            outfile.write(' preferred="%s"' % self.gds_format_boolean(self.preferred, input_name='preferred'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ContactP', fromsubclass_=False, pretty_print=True):
        super(ContactP, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('preferred', node)
        if value is not None and 'preferred' not in already_processed:
            already_processed.add('preferred')
            if value in ('true', '1'):
                self.preferred = True
            elif value in ('false', '0'):
                self.preferred = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(ContactP, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ContactP, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ContactP


GDSClassesMapping = {
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def get_required_ns_prefix_defs(rootNode):
    '''Get all name space prefix definitions required in this XML doc.
    Return a dictionary of definitions and a char string of definitions.
    '''
    nsmap = {
        prefix: uri
        for node in rootNode.iter()
        for (prefix, uri) in node.nsmap.items()
        if prefix is not None
    }
    namespacedefs = ' '.join([
        'xmlns:{}="{}"'.format(prefix, uri)
        for prefix, uri in nsmap.items()
    ])
    return nsmap, namespacedefs


def parse(inFileName, silence=False, print_warnings=True):
    global CapturedNsmap_
    gds_collector = GdsCollector_()
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DataSets'
        rootClass = DataSets
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    CapturedNsmap_, namespacedefs = get_required_ns_prefix_defs(rootNode)
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_=namespacedefs,
            pretty_print=True)
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseEtree(inFileName, silence=False, print_warnings=True):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DataSets'
        rootClass = DataSets
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    # Enable Python to collect the space used by the DOM.
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(str(content))
        sys.stdout.write('\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False, print_warnings=True):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    gds_collector = GdsCollector_()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DataSets'
        rootClass = DataSets
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    if not SaveElementTreeNode:
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseLiteral(inFileName, silence=False, print_warnings=True):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DataSets'
        rootClass = DataSets
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    # Enable Python to collect the space used by the DOM.
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write('#from ABCD3lib import *\n\n')
        sys.stdout.write('import ABCD3lib as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()

RenameMappings_ = {
}

__all__ = [
    "AccessionNamesType",
    "AccessionType",
    "AccessionsType",
    "AcknowledgementsType",
    "AcquisitionType",
    "AddressesType",
    "AnnotationType",
    "AnnotationsType",
    "AssemblageType",
    "AssemblagesType",
    "AssociatedTaxaType",
    "AssociationType",
    "AssociationsType",
    "AtomizedNameType",
    "AudioType",
    "BiostratigraphicTermsType",
    "BiotopeType",
    "BotanicalGardenUnit",
    "ChronostratigraphicTermsType",
    "Contact",
    "ContactP",
    "ContentContactType",
    "ContentContactsType",
    "ContentContactsType3",
    "ContentMetadata",
    "CoordinateSetType",
    "CoordinateSetsType",
    "CoordinatesGridType",
    "CoordinatesLatLongType",
    "CoordinatesUTMType",
    "Country",
    "CreatorsType",
    "CultureCollectionUnit",
    "CultureNamesType",
    "DataSetType",
    "DataSets",
    "DateTime",
    "DescriptionType",
    "DivisionsType",
    "EmailAddressesType",
    "FieldNotesReferencesType",
    "FieldNumberType",
    "FieldNumbersType",
    "Gathering",
    "GatheringAgentType",
    "GatheringAgentsType",
    "GeoecologicalTermsType",
    "GrowthConditionAtomized",
    "GrowthConditionsAtomizedType",
    "GrowthConditionsMeasurementsOrFactsType",
    "HerbariumUnit",
    "HigherTaxaType",
    "HigherTaxon",
    "HybridFlagType",
    "Identification",
    "IdentificationQualifierType",
    "IdentificationsType",
    "IdentifiersType",
    "ImageType",
    "ImagesType",
    "Label",
    "LabelRepr",
    "LegalStatement",
    "LegalStatements",
    "LicensesType",
    "LithostratigraphicTermsType",
    "LoanRestrictionsType",
    "MarkType",
    "MarksType",
    "MeasurementOrFact",
    "MeasurementOrFactAtomizedType",
    "MeasurementsOrFactsType",
    "MeasurementsOrFactsType8",
    "MetadataDescriptionRepr",
    "MultimediaObject",
    "MultimediaObjectsType",
    "MultimediaObjectsType5",
    "MycologicalLiveStagesType",
    "MycologicalUnit",
    "NameAtomizedType",
    "NameBacterial",
    "NameBotanical",
    "NameViral",
    "NameZoological",
    "NamedArea",
    "NamedAreaType",
    "NamedAreasType",
    "NamedCollectionsOrSurveysType",
    "NamedPlaceRelationType",
    "NamedPlaceRelationsType",
    "NomenclaturalTypeDesignationType",
    "NomenclaturalTypeDesignationsType",
    "ObservationUnitIDsType",
    "ObservationUnitType",
    "Organization",
    "OtherLegalStatementsType",
    "OtherMeasurementsOrFactsType",
    "OtherProvidersType",
    "OwnersType",
    "PGRUnit",
    "PaleontologicalUnit",
    "Permit",
    "PermitsType",
    "PersonName",
    "PhasesOrStagesType",
    "PreparationType",
    "PreparationsType",
    "PreservationType",
    "PreservationType14",
    "PreservationsType",
    "PreviousUnitType",
    "PreviousUnitsType",
    "ProjectType",
    "RatingsType",
    "Reference",
    "ReferencesType",
    "ReferencesType12",
    "ReferencesType13",
    "ReferencesType2",
    "ReferencesType4",
    "RepresentationType",
    "ResourceURIsType",
    "ResourceURIsType1",
    "ResourceURIsType10",
    "ResourceURIsType11",
    "ResourceURIsType6",
    "ResourceURIsType7",
    "ResourceURIsType9",
    "ResultType",
    "RevisionData",
    "RolesType",
    "SampleDesignationsType",
    "ScientificName",
    "ScientificNameIdentified",
    "ScopeType",
    "Sequence",
    "SequencesType",
    "SpecimenMeasurementsOrFactsType",
    "SpecimenUnitType",
    "StratigraphicTerm",
    "StratigraphicTermL",
    "Stratigraphy",
    "StringL",
    "StringL255",
    "StringLP",
    "StringLP255",
    "StringP",
    "StringP255",
    "SuggestedCitationsType",
    "SynecologyType",
    "TagsType",
    "TaxaInBackgroundType",
    "TaxonIdentified",
    "TaxonomicTermsType",
    "TechnicalContactsType",
    "TelephoneNumbersType",
    "Temperature",
    "TradeDesignationNamesType",
    "Unit",
    "UnitExtensionsType",
    "UnitReferencesType",
    "UnitsType",
    "VersionType",
    "VideoType",
    "ZoologicalUnit",
    "anyUriP",
    "imageSize"
]
